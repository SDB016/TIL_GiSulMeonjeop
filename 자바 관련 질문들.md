# JVM의 메모리 구조         
**메서드 영역**              
* 클래스파일을 읽어서 분석하여 클래스에 대한 정보를 저장, 클래스 변수도 같이 저장              
             
**힙 영역**           
* 인스턴스가 생성되는 공간, 인스턴스 변수들이 생성되는 공간              
            
**호출 스택** (우리가 아는 스택영역)              
* 메서드의 작업에 필요한 공간을 제공           
* 메서드가 호출되면 호출스택에서 준비한 메모리가 할당된다. -> 메서드의 지역변수들과 연산 중간 결과 저장등에 사용       
* 메서드 작업 종료시 메모리 공간 반환되어 비워짐            
           
# 가비지 컬렉터   
* 메모리가 부족할 때 사용되지 않는 메모리 즉, 쓰레기 메모리를 개발자가 해제하는 것이 아니라 JVM에서 해제해주는 것      
* 메모리 부족 요청시 실행 또는 JVM이 한가할 때 동작한다. -> 다른 말로 그전까지는 할당하고 있음 
                 
# 컬렉션 프레임워크        
* 널리 알려진 자료구조와 알고리즘을 제네릭 기반의 클래스와 메서드 형태로 미리 구현해 놓은것           
* 라이브러리라 하지않고 프레임워크라 한 것은 이러한 자료구조와 알고리즘은 구조와 형태를 가지고 있기 때문입니다.        
  
# 제네릭        
* 비유하자면 상자와 같음 -> 상자에 무엇을 넣느냐에 따라서 상자의 이름이 바뀐다.      
* 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능      
* Object로 받지않고 해당 클래스로 받으므로 형변환 필요가 없음 -> 코드 간결및 가독성 높아짐    
 
# 와일드 카드 
* 제네릭을 보조하기 위한 친구   
* ? 를 사용한다.   

# 오버로딩과 오버라이딩에 대해서 설명해보시오            
          
오버 로딩 : 동일한 메서드의 이름을 가지지만 매개변수 수, 매개변수 타입에 따라 다르게 동작시키기 위해 메서드를 정의하는 방법         
* 한 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것                
* 매개변수의 수, 매개변수의 타입을 기준으로 결정되며 **반환형은 기준이 되지 않습니다.**            
* 가변인자로도 가능하다             
          
오버 라이딩 :        
* 부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것            
* 해당 부모 클래스 메서드의 메서드 형태(이름,매개변수,반환값)가 일치해야 하며 일치 하지 않으면 오버로딩 될 수 있음       
* ```@Override```를 사용하면 오버라이딩 형태는 맞출 수 있음       
              
재정립          
오버 로딩 : 기존에 없는 메서드 정의          
오버 라이딩 : 상속받은 메서드의 내용을 변경하는 것        
              
# 생성자        
       
생성자 :            
* 인스턴스 초기화 메서드로 리턴값이 없다.           
* 마찬가지로 오버라이딩이 가능하다            
* 생성자를 정의하지 않으면 디폴트 생성자가 생기지만 정의할 경우 디폴트 생성자는 사라진다.           
           
# 상속           
* 부모 클래스의 요소를 자식 클래스가 물려받는것           
* 흔히들 재사용 관점으로 얘기하지만 본질적의미로는 **연관된 특성을 가진 클래스들을 묶어주는 것**          
* AA is a BB 관계 성립 -> 원은 점이다. -> ```Circle extends Point``` -> ```Point p = new Circle()```         
          
**super**      
상위 클래스의 요소를 사용하는 것       

# 다형성   
부모 클래스 타입의 참조변수로 자식 클래스의 인스턴스(객체)를 참조할 수 있는 것      
    
```a instanceOf AA``` a 변수가 AA를 참조할 수 있느냐 -> 동등하거나 자식 객체냐   


# 제어자   
1. static, final, abstract      
2. private 같클, public 아무나, protected 같패+해당클래스 상속받을시, default 같패     

# 추상클래스        
* 변수와 추상 메서드를 가진 클래스       
* 인스턴스화가 불가능하며 상속의 용도로 사용되는 클래스        
* 인터페이스에서 변수가 추가된 형태라고 보면 되고, 추상 메서드 외에도 정의된 메서드도 정의 가능하다.          
   
# 인터페이스   
* 일종의 사용 설명서 같은 것   
* 원래는 추상 메서드로 이루어져있지만 자바8 버전부터 디폴트 메서드, static final 변수 지원   
* 이는 기존에 인터페이스를 구현한 클래스들에게서 공통적으로 메서드를 추가해야할 때 사용    

# 내부 클래스   
1. 인스턴스 클래스 : 외부 클래스의 instance 멤버처럼 사용, instatnce 메서드와 같이 사용위함            
2. 스태틱 클래스 : 외부 클래스의 static 멤버처럼 사용, static 메서드와 같이 사용위함         
3. 지역 클래스 : 외부 클래스의 **메서드 안이나 초기화 블럭에 사용** -> 선언된 영역에서만 사용가능   
4. 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 클래스 -> 이름이 없고 1회용이다.   

```java
new ActionListener() {
    pubilc void action(int a){
        sout("a");
    }
}
```  
     
# 오토박싱 언박싱    

