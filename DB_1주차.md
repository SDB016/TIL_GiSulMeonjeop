# 💡 데이터베이스란 무엇인가?
   
* **위키피디아 :**   
  데이터베이스는 여러 사람이 공유하여 사용할 목적으로 체계화해 **통합, 관리하는 데이터의 집합**이다.      
  작성된 목록으로써 **여러 응용 시스템들의 통합된 정보들을 저장하여 운영**할 수 있는 공용 데이터들의 묶음이다.      
    
* **오라클 :**   
  데이터베이스란 일반적으로 컴퓨터 시스템에 **전자 방식으로 저장된 구조화된 정보 또는 데이터의 체계적인 집합**을 의미한다.       
  데이터베이스는 보통 데이터베이스 관리 시스템(DBMS)에 의해 제어된다.      
  데이터와 DBMS는 연관된 어플리케이션들과 함께 `데이터베이스 시스템`으로 일컬어지며,      
  더 짧게는 '데이터베이스'라고 통칭한다.   
                 
**정리하자면 아래와 같다.**          
데이터베이스란, 여러 사람이 공유하여 사용할 목적으로 전자 방식으로 저장된 데이터의 집합이다.         
데이터베이스는 `데이터베이스 관리시스템 DBMS` 에 의해 제어되며            
`Data`와 `DBMS`는 연관된 어플리케이션들과 함께 `데이터베이스 시스템`으로 불리운다.          
  
# 💡 Database의 특징을 설명하시오.
> 데이터 베이스의 특징을 설명하기전에 왜 데이터베이스가 등장했는지에 대해서 알고가면 좋다.   
     
데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다.    
데이터를 **각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다.**      
이 때의 문제점은 **데이터의 `종속성` 문제와 `중복성` 문제가 있다.**               
      
* **종속성 :** 데이터를 저장한 파일구조가 바뀌면 응용 프로그램도 바뀌어야한다.(경로 등등)    
* **중복성 :** 동일한 데이터가 여러곳에 존재할 수 있으며 데이터간의 불일치가 존재할 수 있다.  
 
그리고 이런 파일 시스템의 문제점으로 인해 **`일관성` `보안성` `경제성` `효율성`** 이 발생한다.   
  
* **일관성 :** 데이터 불일치 발생   
* **보안성 :** 같은 데이터에 동일한 보안수준 적용의 어려움    
* **경제성 :** 저장공간 낭비, 갱신 비용    
* **무결성 :** 데이터의 정확성 확보 불가        

이러한 문제점이 발생하기에 우리는 데이터를 하나로 모아 관리하는 데이터베이스를 사용한다.   
  
**데이터베이스의 특징**  
* **데이터의 독립성**     
  * `물리적 독립성 :`    
    데이터베이스 사이즈를 늘리거나 성능 향상을 위해   
    데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
  * `논리적 독립성 :`   
    데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
* **데이터의 무결성**   
  * 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로    
    데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.
* **데이터의 보안성** 
  * 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록   
    계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
* **데이터의 일관성** 
  * 연관된 정보를 논리적은 구조로 관리함으로써    
    어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.   
    또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
* **데이터 중복 최소화** 
  * 데이터베이스는 데이터를 통합해서 관리함으로써    
    파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

# 💡 Database 설계 시, 고려할 점을 설명하시오.
|항목|설명|
|---|----|
|제약조건|저장된 데이터 값이 만족해야 될 주어진 조건|
|데이터베이스 무결성|갱신, 삽입, 삭제 등의 연산이 수행된 뒤에도 데이터 값은 제약조건을 만족해야하는 조건|
|일관성|저장된 두 데이터 값 또는 특정 질의에 대한 응답들에 모순성 없이 일치하는 특성|
|회복|시스템에 장애가 발생했을 때 장애 발생 직전의 일관된 데이터 상태로 돌아가는 기법|
|보안|불법적인 데이터의 변경이나 손실 또는 노출에 대한 보호|
|효율성|응답 시간의 단축, 저장공간의 최적화, 시스템 생산성이 포함|
|데이터베이스 확장성|시스템 운영에 영향을 주지 않으면서 새로운 데이터를 계속적으로 추가 가능한 기법|
         
프로세스는 아래와 같다.       
`요구분석` -> `개념적 설계` -> `논리적 설계` -> `물리적 설계` -> `데이터베이스 구현`        
          
# 💡 Schema가 무엇인가요?   
> 출처 : [코딩팩토리](https://coding-factory.tistory.com/216)     
> 출처 : [지식잡식](https://raisonde.tistory.com/entry/시험대비-외부-스키마-개념-스키마-내부-스키마를-구분하자 )    
     
1. 스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 **메타데이터의 집합**이다.    
2. 스키마는 데이터베이스를 구성하는 데이터 `개체(Entity)`, `속성(Attribute)`, `관계(Relationship)` 및     
   데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.       
3. 스키마는 사용자의 관점에 따라 **외부 스키마**, **내부 스키마**, **개념 스키마**로 나눠진다.           
       
복잡한 설명은 놔두고 쉽게 말하면 `use db명` 의 db를 의미한다.     
즉, 우리가 테이블을 가지고 있는 `DataBase`를 의미한다.          

![image](https://user-images.githubusercontent.com/50267433/113530801-ebcac400-9601-11eb-8bb7-e52968c7d47f.png)   


## 외부 스키마  
응용프로그램 개발자의 관점에서 보는 스키마를 말하며 정확한 표현은 아니지만 쉽게 **View**라고 생각하면 된다.     
사용 주체나 응용 프로그램에 따라서 **같은 데이터가 같은 구조로 저장되어 있는 데이터베이스에서 바라보는 관점이 다를 수도 있다.**       
누군가는 `SELECT * FROM table`에서 특정 테이블의 모든 에트리뷰트와 데이터들을 바라보고         
누군가는 `JOIN이나 MERGE`를 통해 여러 테이블을 동시에 조회 할 수도 있다.     
우리가 DBMS 툴에서 **`SELECT` 쿼리를 던졌을때 볼 수 있는 그 표를 외부 스키마의 대표적인 예**라고 쉽게 생각하자.     
하지만 그렇다고 외부 스키마가 조회된 결과값을 의미 한다는 것은 아니다.(겉으로 보이는 DB, Table의 형태인 것이다.)      
       
- 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것    
- 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마(Sub Schema)하고도 함   
- 하나의 데이터베이스 관리 시스템에는 여러 개의 외부 스키마가 존재할 수 있으며,      
  하나의 외부 스키마는 여러 개의 응용 프로그램이나 사용자에 의해 공유될 수 있음   
- 동일한 데이터베이스에 대해서 서로 다른 관점을 정의할 수 있도록 허용함   
     
## 내부 스키마   

`DBMS 이용자`에겐 잘 드러나지 않는 스키마이다.     
어떤 데이터가 어떤 테이블의 어떤 row의 어떤 애트리뷰트에 있다는 개념이 아니라,         
B-트리 자료구조의 어디에 저장되어 있고, 디스크의 어느 위치에, 메모리의 어느 페이지에 저장돼 있는지의 관점으로 바라보는 개념이다.      
우리는 단순히 `INSERT`로 데이터를 삽입하지만       
이 `INSERT`문에 의해 저장되는 그 `VALUES`는 어떠한 알고리즘으로 하드디스크의 어떠한 부분에 저장이 될 것이다.      
이런 시스템적인, 물리적인 시각의 스키마가 내부 스키마이다.       
   
- 데이터베이스의 물리적 구조를 정의한 것    
- 물리적 저장장치의 관점에서 본 전체 데이터베이스의 명세로서 하나만 존재   
- 개념 스키마의 물리적 저장 구조에 대한 정의를 기술한 것   
- 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마   
           
## 개념 스키마(Conceptual Schema)
  
DA가 설계한 그 DB구조, 그것이 개념 스키마이다.     
보통 스키마라고 하면 이 개념스키마의 개념으로 받아들여지는 경우가 많다.     
외부 스키마랑 다르게 보여지는 형태의 관점이 아니라 그 `구조적 관점`을 생각해야 한다.      
쉽게 이해하려면 ER다이어그램을 떠올려 보자. 어떤 테이블이 어떻게 구성되어 있고 속성은 무엇이며 어떤 테이블과 릴레이션을 이루고 있는가.     
이러한 관점의 스키마가 개념 스키마이다.      
이해를 돕기 위해 말해두자면 한 데이터베이스에서 외부 스키마는 수업이 많은 형태로 수없이 많이 존재할 수 있지만 개념 스키마는 오직 하나 뿐이다.    
    
- 개체 간의 관계와 제약 조건을 나타내고 데이터베이스의 접근 권한, 보안 정책 및 무결성 규정에 관한 명세를 정의한 것
- 데이터베이스의 전체적인 논리적 구조로서,   
  모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스 명세로서 하나만 존재
- 단순히 스키마라고 하면 개념 스키마를 의미
- 기관이나 조직의 관점에서 데이터베이스를 정의한 것
- 데이터베이스 관리자에 의해서 작성됨     
       
# 💡 DBMS는 무엇인가요?           
`DBMS`란, `DataBase Management System(데이터베이스 관리 시스템)`의 약자로          
다수의 사용자들이 **데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어 도구**의 집합이다.     
`DBMS`은 사용자 또는 다른 프로그램의 요구를 처리하고 적절히 응답하여 데이터를 사용할 수 있도록 해준다.    
               
데이터베이스는 단순히 데이터의 집합일 뿐이다.               
그렇기에 데이터베이스 관리 시스템을 통해 데이터베이스를 조작하면서 사용해야한다.       

흔히 우리가 알고있는 MySQL, MariaDB, Oracle, MongoDB, redis 등등이 있다.   
    
# 💡 DBMS의 속성에는 무엇이 있나요?
   
1. 관계형 테이터베이스 관리시스템 (RDBMS)
2. 객체지향 데이터베이스 관리시스템 (OODBMS)
3. 객체관계형 데이터베이스 관리시스템 (ORDBMS)
4. 계층형 데이터베이스 관리시스템 (HDBMS)
5. 네트워크형 데이터베이스 관리시스템 (NDBMS)

## RDBMS 
RDB를 생성하고 수정하고 관리할 수 있는 소프트웨어이다.   
즉, 관계형 데이터 모델을 기반으로 하는 DBMS 유형이다.   
 
* 정규화를 통해 데이터의 중복성을 최소화하며 트랜잭션을 수행하는 것이 쉬운 장점이 있다.       
* 데이터의 원자성, 일관성, 격리 및 내구성을 유지하며 데이터 무결성을 높인다.      
* MSSQL, MySQL, Oracle이 RDBMS의 몇가지 예다.      
   
## OODBMS
정보를 객체의 형태로 표현하는 데이터베이스 모델로 오브젝트 데이터베이스(object database)라고도 부른다.   
객체지향이라는 이름 그대로 실세계의 데이터를 객체로 표현하여 저장하고자 하였다.  
클래스, 인스턴스, 상속 등등의 개념이 있었지만 현재는 몰락하여 잘 사용되지 않는다.
몰락한 이유로는 이미 2차원 DB에 익숙했기에 마이그레이션할 이유를 못찾았으며, RDB가 훨씬 단순하고 유연성이 높았다.    
그리고 가장 큰 이유로는 의존관계가 결합되어 있으므로 대규모 트랜잭션 처리 성능이 떨어진다는 문제가 있었다.    
또한, 오라클에서 OODBMS를 죽이기 위해 ORDBMS 를 내세우면서 몰락을 하게 되었다.   
  
## ORDBMS
객체지향 데이터베이스 모델을 가진 관계형 데이터베이스 관리 시스템(RDBMS, 관계 데이터베이스)을 말한다.  
소프트웨어 개발자가 스스로 데이터 형과 메서드를 자유롭게 정의하여 데이터베이스를 개발할 수 있는 데이터베이스 관리 시스템이다. 
쉽게 설명하면, 하이브리드 방식이다.  

* PostgreSQL.
* Microsoft의 SQL Server
 
## HDBMS    
계층형 데이터 베이스는 데이터의 관계를 트리 구조로 정의하고, 부모, 자식 형태를 갖는 구조이다.      
즉, 데이터가 계층적이고 상하 종속적인 관계로 구성되며, 데이터 중복 문제가 있다.     
   
## NDBMS
네트워크형 데이터베이스는 계층형 데이터의 데이터 중복 문제를 해결하고, 레코드 간 다양한 관계를 그물처럼 갖는 구조이다.      
하지만 복잡한 구조 때문에 이후 구조 변경에서 어려움을 가진다.        
다시 말해 데이터 구조를 네트워크 상의 노드(자료) 형태로 논리적으로 표현한 데이터 모델로써 각각의 노드를 서로 대등한 관계로 구성한 모델이다.   
  
## NoSQL   
NoSQL은 Not Only SQL의 약자로 기존 RDBMs 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며,       
관계형 데이터 베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태로, 수평적 확장성을 갖고 있다.    
문서, 그래프, 키 값, 인 메모리, 검색을 포함해 다양한 데이터 모델을 사용한다.    
RDBMS가 클라이언트/서버 환경에 맞는 데이터 저장기술이라면, NoSQL은 클라우드 환경에 맞는 저장 기술이다.    
   
# 💡 데이터 모델링이 무엇인가요?  
**모델링 :** 복잡한 현실 세계를추상화, 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법      
       
* 추상화 : 현실 세계를 일정한 형식에 맞춰 표현하는 것     
* 단순화 : 현실 세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하는 것  
* 명확화 : 누구나 분명하게 이해하기 위해 정확하게 현상을 기술하는 것   
     
**데이터 모델링 :** 현실 세계에 존재하는 데이터를 단순화 시켜 컴퓨터 세계의 데이터베이스로 변환하고 옮기는 과정이다.       
         
데이터 모델링을 쉽게 설명하면, **DB에 저장할 데이터를 위한 데이터 모델을 만드는 `프로세스`를 의미한다.**                
이런 데이터 모델링에는 3가지 단계가 존재한다.    
     
* 개념적 모델링: 개체와 개체들 간의 관계에서 ER다이어그램을 만드는 과정  
* 논리적 모델링: ER다이어그램을 사용하여 관계 스키마 모델을 만드는 과정  
* 물리적 모델링: 관계 스키마 모델의 물리적 구조를 정의하고 구현하는 과정  
  
## 개념적 모델링
핵심 엔터티와 그들 간의 관계를 발견하고, 그것을 표현하기 위해서 엔터티-관계 다이그램을 생성하는 것.  
엔터티-관계 다이어그램은 조직과 다양한 데이터베이스 사용자에게 어떠한 데이터가 중요한지 나타내기 위해서 사용.   
  
* 개념 데이터 모델은 사용자와 시스템 개발자가 데이터 요구 사항을 발견하는 것을 지원   
* 개념 데이터 모델은 현 시스템이 어떻게 변형되어야 하는가를 이해하는데 유용   
   
## 논리적 데이터 모델링(Logical Data Modeling)
데이터베이스 설계 프로세스의 Input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정    
데이터 모델링 과정에서 가장 핵심이 되는 부분으로 이 단계에서 하는 중요한 활동은 정규화이다.        
      
**정규화에 대해서 간단한 설명**        
* 논리 데이터 모델 상세화 과정의 대표적인 활동.     
* 논리 데이터 모델의 일관성 확보, 중복 제거로 속성들이 가장 적절한 엔터티에 배치되도록 함 → 신뢰성있는 데이터구조를 얻는 목적      
     
## 물리적 데이터 모델링(Physical Data Modeling)
데이터가 물리적으로 컴퓨터에 어떻게 저장될 것인가에 대한 정의를 물리적 스키마라 함.    
이 단계에서 결정되는 것 : 테이블, 칼럼 등으로 표현되는 물리적인 저장구조와 사용될 저장 장치, 자료를 추출하기 위해 사용될 접근 방법 등.   
    

# 💡 메타데이터란 무엇인가?
**데이터를 위한 데이터**       
좀 더 풀어서 설명하면, 데이터의 값이 아니라 데이터의 속성을 설명하기 위해 존재하는 데이터이다.          
    
데이터베이스에서 이 메타 데이터를 **데이터 사전**이라고 부른다.     
그리고 데이터 사전은 다른 말로 **시스템 카탈로그**라고 말한다.       
   
**데이터 사전**   
데이터 사전은 데이터베이스 관리 시스템을 효율적으로 사용하기 위해 데이터베이스에 저장된 정보를 요약한 것이다.        
즉, 일련의 데이터를 정의하고 설명해 주는 메타데이터(metadata)를 유지하는 것을 의미한다.     
     
쉽게 말하면 데이터베이스에 저장되어 있는 모든 데이터 개체들에 대한 정보를 유지, 관리하는 시스템이다.   
   
## 데이터 사전의 분류  
**`ALL_XXXX`**      
ALL_로 시작하는 데이터 사전으로, 한 특정 사용자가 조회 가능한 모든 데이터사전을 의미 한다.
자신이 조회하려는 객체의 주인이 아니더라도 그 객체에 접근 할 수 있는 권한을 가지고 있다면 ALL_XXXX 뷰를 통하여 조회가 가능 하다.

```sql
SELECT table_name, tablespace_name 
  FROM ALL_TABLES;
```
   
**`USER_XXXX`**        
USER_로 시작하는 데이터 사전으로, 한 특정 사용자에게 종속되어 있고,      
그 사용자가 조회 가능한 데이터 사전 뷰들로 ALL_XXXX 데이터 사전의 모든 정보의 부분 집합 이다.   
     
```sql
SELECT table_name, tablespace_name 
  FROM USER_TABLES;
```  

**`DBA_XXXX`**      
DBA권한을 가진 사용자 만이 조회할 수 있는 데이터 사전으로서 모든 오라클 데이터베이스 객체에 대한 정보를 볼 수 있다.     
SELECT ANY TABLE 권한이 있는 사용자 또한 질의가 가능 하며 다른 사용자가 질의 하려면 앞에 SYS.이라는 접두어를 붙여야 한다.     

```sql
SELECT OWNER, OBJECT_NAME 
  FROM SYS.DBA_OBJECTS;
```    
  
**`V$_XXXX`**        
Dynamic Performance View라고도 하며, 현재 Database의 상태에 관한 정보로 주로 DBA에게만 액세스가 허용되어 있다.    
주로 DBA의 모니터링 작업용 정보를 제공하며, X$ 테이블을 베이스로 하는 뷰이다.   
   
**`X$_XXXX`**      
X$ 뷰는 V$ 뷰가 보여주지 않는 정보를 보여준다.       
X$ 테이블은 오라클의 메모리정보를 볼 수있는 SQL 인터페이스 뷰들로 Oracle 데이터베이스의 가장 숨겨진 영역 중 하나이다.    
  
# 💡 키의 종류에는 어떤게 있나요?   

* 후보키 
* 기본키 
* 대체키
* 슈퍼키 
* 외래키

## 후보키 
릴레이션을 구성하는 속성들 중에서 **데이터를 유일하게 식별할 수 있는 속성들을 의미한다**    
즉, 기본키의 후보가 될 수 있는 키들을 의미한다.     
  
* 중복된 튜플이 없게하려면 적어도 1개 이상의 후보키가 존재해야한다.     
* 후보키는 릴레이션에 있는 모든 튜플에 대해서 **유일성**과 **최소성**을 만족시켜야 한다.    
  
## 기본키     
기본키는 후보키 중에서 선택한 **테이블을 대표하는 키**이다.      
그렇기에 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.   

* null 값을 가질 수 없다.   
* 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.  
* 인덱스 정렬의 기준이 된다.   
  
## 대체키    
후보키가 둘 이상일 때, 기본키를 제외한 나머지 후보키들을 말한다.     
다른말로, **보조키**라고도 한다.     
        
## 슈퍼키      
슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서           
릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타나지 않는다.            
       
* 릴레이션을 구성하는 모든 튜플에 대해 **유일성**을 만족시키지만, **최소성**은 만족시키지 못한다.    

## 외래키 
관계를 맺고 있는 릴레이션 R1, R2에서   
릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성을 외래키라 한다.   
릴레이션의 기본키와 대응되어 릴레이션간에 참조 관계를 표현하는데 중요한 도구다.   
 
* 필자 생각으로, `NotNull` + `Unique` 컬럼이면 외래키로 등록할 수 있을 것 같다.      
  
# 💡 무결성 제약조건에 대해 아는대로 서술하시오.    
    
## 개체 무결성 
> 기본키는 null이 될 수 없다.    
   
개체 무결성 제약조건은 기본키를 구성하는 모든 속성은 널 값을 가지면 안된다는 규칙이다.   
기본키는 릴레이션에 포함되는 튜플을 유일하도록 식별해주는 키로서,    
기본키를 구성하는 속성 전체나 일부가 널 값이 되면 튜플의 유일성을 판단할 수 없기 때문에 본질을 상실하게 된다.    
   
## 참조 무결성
> 외래키는 참조할 수 없는 값을 가질 수 없음    
                  
참조 무결성 제약조건은 외래키는 참조할 수 없는 값을 가질 수 없다는 규칙이다.      
외래키는 다른 릴레이션의 기본키를 참조하는 속성이고 릴레이션 간의 관계를 표현하는 역할을 한다.           
그런 외래키가 자신이 참조하는 릴레이션의 기본키와 상관없는 값을 가지게 되면      
두 릴레이션을 연관시킬 수 없으므로 외래키 본래의 의미가 없어진다는 문제점이 발생한다.           
        
## 도메인 무결성        
> 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 한다.            
      
도메인 무결성은 데이터 베이스에 삽입되는 데이터들에 **제약 조건**을 의미합니다.             
각각의 속성은 `숫자, 문자 등의 도메인을 가지면 해당 도메인에 맞는 데이터를 삽입해야 한다.`      
그 뿐만 아니라 삽입되는 데이터를 제한하거나, 삽입되지 않을 경우 기본값, null 제한 등의 기능을 제공한다.  

## 키 무결성
> 릴레이션에는 최소한 하나의 키가 존재해야 함    
  
참고로 꼭 PK일 필요는 없다.     
애초에 DB에서는 Key가 없는 테이블을 작성할 수 있다.     
     
## null 무결성   
> 특정 속성은 null 값을 가질 수 없음    
             
null 무결성은 특정 속성값에는 null 값을 가질 수 없다는 규칙이다.     
기본적으로 속성값으로 null 값을 가질 수 있는데 만약 "유저 아이디"처럼 중요한 정보에는     
스키마를 정의할 때 해당 속성을 null 데이터가 올 수 없음을 미리 정의할 수 이다.      
   
## 고유 무결성
> 특정 속성값은 서로 달라야 함    
     
고유 무결성은 특정 속성에 삽입되는 데이터는 고유한 값을 가져야 한다는 규칙이다.      
이말은 즉, 각 튜플에서 하나의 속성값은 중복된 값이 없는 각각 서로 다른 값을 가져야 한다는 의미이다.       
예를 들어 이름, 나이, 사는 곳과 같은 속성은 튜프들이 서로 같은 값을 가질 수 있지만       
고객 아이디의 경우 각 튜플을 서로 다른 값을 가져야 한다.     
  
# 💡 서브쿼리가 뭐에요? 
> 출처: [기본기를 쌓는 정아마추어 코딩블로그](https://jeong-pro.tistory.com/40 )
   
하나의 SQL 문에 포함되어 있는 또 다른 SQL 문을 말한다.       
쿼리문 관점에서 말하면 `SELECT 문` 안에 또다시 `SELECT문`이 있는 쿼리문이다.   
        
서브쿼리는 위치에 따라 명칭이 다르다.       
`FROM`절에 사용하는 `인라인 뷰(Inline view)`,        
`SELECT`문에 사용하는 `스칼라 서브쿼리(Scala Subquery)`,        
일반적으로 `WHERE`절에 사용하는 것을 `서브쿼리(Subquery)`라고 한다.        
        
## 단일 행 서브쿼리
```sql
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE TEAM_ID = (SELECT TEAM_ID
                 FROM PLAYER
                 WHERE PLAYER_NAME = '김남일')
ORDER BY PLAYER_NAME;
// 조금 억지로 만듦.
// 김남일 선수의 소속팀을 알아냄. 만약 김남일 선수가 동명이인으로 두명이상이 있다면 에러남
 
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버
FROM PLAYER
WHERE HEIGHT <= (SELECT AVG(HEIGHT)
                 FROM PLAYER)
ORDER BY PLAYER_NAME;
// 평균키를 알아내는 서브쿼리와 그 결과로 평균키 이하인 선수를 출력
```

## 다중 행 서브쿼리
서브쿼리의 결과가 2건이상 반환될 수 있다면 '반드시' 다중행 비교연산자(IN, ALL, ANY, SOME)과 함께 사용해야한다.    
      
* **IN(서브쿼리) :**   
  서브쿼리의 결과에 존재하는 값과 동일한 조건의미    
* **비교연산자 ALL(서브쿼리) :** 
  비교연산자에 `>` 를 썼다면 ALL이 모든 값을 만족하는 조건이기 때문에     
  결과중에 가장 큰값보다 커야 만족한다는 뜻.    
* **비교연산자 ANY(서브쿼리) :**    
  비교연산자에 ">" 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에    
  결과중에 가장 작은값보다 크면 만족한다는 뜻. (= SOME)   
* **EXISTS(서브쿼리) :**   
  서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인 1건만 찾으면 더이상 검색 안함    
   
```sql
SELECT REGION_NAME 연고지명, TEAM_NAME 팀명, E_TEAM_NAME 영문팀명
FROM TEAM
WHERE TEAM_ID IN (SELECT TEAM_ID
                  FROM PLAYER
                  WHERE PLAYER_NAME = '정현수')
ORDER BY TEAM_NAME;
// 정현수 선수가 두명이상 일때 소속 팀, 연고지명, 영문팀명 출력
```

## 다중 컬럼 서브쿼리
- 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인쿼리 조건과 동시에 비교되는 것.
```sql
SELECT TEAM_ID 팀코드, PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버, HEIGHT 키
FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (SELECT TEAM_ID, MIN(HEIGHT)
                            FROM PLAYER
                            GROUP BY TEAM_ID)
ORDER BY TEAM_ID, PLAYER_NAME;
// 소속팀별 키가 가장 작은 사람들의 정보를 출력.
// 같은 팀에서 여러명의 선수가 반환될 수 있음. 키가 같은 경우.
```
## 연관 서브쿼리 (Correlated Subquery)
```sql 
SELECT T.TEAM_NAME 팀명, M.PLAYER_NAME 선수명, M.POSITION 포지션, M.BACK_NO 백넘버, M.HEIGHT 키
FROM PLAYER M , TEAM T
WHERE M.TEAM_ID = T.TEAM_ID
AND M.HEIGHT < (SELECT AVG(S.HEIGHT)
                FROM PLAYER S
                WHERE S.TEAM_ID = M.TEAM_ID
                AND S.HEIGHT IS NOT NULL
                GROUP BY S.TEAM_ID)
ORDER BY 선수명;
// 선수 자신이 속한 팀의 평균키보다 작은 선수들의 정보를 출력하는 SQL문
SELECT STARDIUM_ID ID, STARDIUM_NAME 경기장명
FROM STARDIUM A
WHERE EXISTS (SELECT 1
              FROM SCHEDULE X
              WHERE X.STARDIUM_ID = A.STARDIUM_ID
              AND X.SCHE_DATE BETWEEN '20120501' AND '20120502')
// 20120501 과 20120502 사이의 날짜에 경기가 있는 경기장 조회
``` 
 
## SELECT 절에 서브쿼리 (=스칼라쿼리 : 한 행 한 컬럼만 반환하는 쿼리)
```sql
SELECT PLAYER_NAME 선수명, HEIGHT 키, ROUND( (SELECT AVG(HEIGHT)
                                             FROM PLAYER X
                                             WHERE X.TEAM_ID = P.TEAM_ID),3) 팀평균키
FROM PLAYER P
 
## FROM 절에 서브쿼리
SELECT T.TEAM_NAME 팀명, P.PLAYER_NAME 선수명, P.BACK_NO 백넘버
FROM (SELECT TEAM_ID, PLAYER_NAME, BACK_NO
      FROM PLAYER
      WHERE POSITION = 'MF') P,
      TEAM T
WHERE P.TEAM_ID = T.TEAM_ID
ORDER BY 선수명;
// 서브쿼리의 결과가 마치 동적으로 생성된 테이블처럼 사용
// 서브쿼리의 컬럼은 메인에서 사용할 수 없다. 하지만 이건 인라인뷰이기 때문에 사용가능
``` 
## TOP-N 쿼리
인라인 뷰에서는 ORDER BY절이 불가하다. 따라서 인라인 뷰에서 먼저 정렬하고 정렬된 결과에서 일부데이터를 추출하는 것이 TOP-N쿼리
TOP-N 쿼리를 수행하기 위해서는 ROWNUM이라는 연산자를 통해 건수를 제약할 수 있다.
```sql 
SELECT PLAYER_NAME 선수명, POSITION 포지션, BACK_NO 백넘버, HEIGHT ㅣ
FROM (SELECT PLAYER_NAME, POSITION, BACK_NO, HEIGHT
      FROM PLAYER
      WHERE HEIGHT IS NOT NULL
      ORDER BY HEIGHT DESC)
WHERE ROWNUM <= 5;
// 인라인 뷰에서 선수의 키를 내림차순으로 정렬한 후 메인쿼리에서 ROWNUM을 통해 5명만 추출.
// 즉, 키가 큰순서로 상위 5명 뽑음
``` 
## HAVING 절에 서브쿼리
```sql
SELECT P.TEAM_ID 팀코드, T.TEAM_NAME 팀명, AVG(P.HEIGHT) 평균키
FROM PLAYER P , TEAM T
WHERE P.TEAM_ID, T.TEAM_ID
GROUP BY P.TEAM_ID, T.TEAM_NAME
HAVING AVG(P.HEIGHT) < (SELECT AVG(HEIGHT)
                        FROM PLAYER
                        WHERE TEAM_ID = 'K02');
``` 
## UPDATE SET 절 서브쿼리
```sql
UPDATE TEAM A
SET A.E_TEAM_NAME = (SELECT X.STARDIUM_NAME
                     FROM STARDIUM X
                     WHERE X.STARDIUM_ID = A.STARDIUM_ID);
``` 
## INSERT VALUES 절에 서브쿼리
```sql
INSERT INTO PLAYER(PLAYER_ID, PLAYER_NAME, TEAM_ID)
VALUES( (SELECT TO_CAHR(MAX(TO_NUMBER(PLAYER_ID))+1) FROM PLAYER), '홍길동','K06');
```
## 뷰
테이블은 실제 데이터를 가지고 있는 반면, 뷰는 실제 데이터가 없음
테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않아도 됨.
```sql 
CREATE VIEW V_PLAYER_TEAM AS
SELECT P.PLAYER_NAME ,P.POSITION, P.BACK_NO, P.TEAM_ID, T.TEAM_NAME
FROM PLAYER P , TEAM T
WHERE P.TEAM_ID = T.TEAM_ID;
```
# 💡 서브쿼리의 성능은 어때요?
* MySQL 5.5 까지는 서브쿼리 최적화가 최악이라 웬만하면 Join으로 전환하자
  * 메인테이블의 row 수 만큼 서브 쿼리를 수행한다
  * MySQL 5.6 에서 서브 쿼리가 대폭 최적화 되었다.
  * 다만 최적화가 적용 안되는 조건들이 다수 존재한다
* 버전/조건 관계 없이 좋은 성능을 내려면 최대한 Join을 이용하자
  * Join을 사용하기가 너무 어렵다면 Subquery는 사용하되, MySQL 5.5 이하라면 절대 사용하지 않는다. 
  * 차라리 쿼리를 나눠서 2번 실행 (메인쿼리/서브쿼리)하고 애플리케이션에서 조립하는게 낫다.
