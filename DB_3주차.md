# 💡 관계형 데이터베이스의 특징  


# 💡 무결성 제약조건이란 무엇인가?    
데이터베이스의 일관성을 보장하기 위해        
**일관된 데이터베이스 상태를 정의하는 규칙**들을 묵시적으로 또는 명시적으로 정의하는 것     
   
## 개체 무결성 
> 기본키는 null이 될 수 없다.    
   
개체 무결성 제약조건은 기본키를 구성하는 모든 속성은 널 값을 가지면 안된다는 규칙이다.   
기본키는 릴레이션에 포함되는 튜플을 유일하도록 식별해주는 키로서,    
기본키를 구성하는 속성 전체나 일부가 널 값이 되면 튜플의 유일성을 판단할 수 없기 때문에 본질을 상실하게 된다.    
   
## 참조 무결성
> 외래키는 참조할 수 없는 값을 가질 수 없음    
                  
참조 무결성 제약조건은 외래키는 참조할 수 없는 값을 가질 수 없다는 규칙이다.      
외래키는 다른 릴레이션의 기본키를 참조하는 속성이고 릴레이션 간의 관계를 표현하는 역할을 한다.           
그런 외래키가 자신이 참조하는 릴레이션의 기본키와 상관없는 값을 가지게 되면      
두 릴레이션을 연관시킬 수 없으므로 외래키 본래의 의미가 없어진다는 문제점이 발생한다.           
        
## 도메인 무결성        
> 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 한다.            
      
도메인 무결성은 데이터 베이스에 삽입되는 데이터들에 **제약 조건**을 의미합니다.             
각각의 속성은 `숫자, 문자 등의 도메인을 가지면 해당 도메인에 맞는 데이터를 삽입해야 한다.`      
그 뿐만 아니라 삽입되는 데이터를 제한하거나, 삽입되지 않을 경우 기본값, null 제한 등의 기능을 제공한다.  

## 키 무결성
> 릴레이션에는 최소한 하나의 키가 존재해야 함    
  
참고로 꼭 PK일 필요는 없다.     
애초에 DB에서는 Key가 없는 테이블을 작성할 수 있다.     
     
## null 무결성   
> 특정 속성은 null 값을 가질 수 없음    
             
null 무결성은 특정 속성값에는 null 값을 가질 수 없다는 규칙이다.     
기본적으로 속성값으로 null 값을 가질 수 있는데 만약 "유저 아이디"처럼 중요한 정보에는     
스키마를 정의할 때 해당 속성을 null 데이터가 올 수 없음을 미리 정의할 수 이다.      
   
## 고유 무결성
> 특정 속성값은 서로 달라야 함    
     
고유 무결성은 특정 속성에 삽입되는 데이터는 고유한 값을 가져야 한다는 규칙이다.      
이말은 즉, 각 튜플에서 하나의 속성값은 중복된 값이 없는 각각 서로 다른 값을 가져야 한다는 의미이다.       
예를 들어 이름, 나이, 사는 곳과 같은 속성은 튜프들이 서로 같은 값을 가질 수 있지만       
고객 아이디의 경우 각 튜플을 서로 다른 값을 가져야 한다.  

# 💡 View란 무엇인가?    
**Viwe :**    
본래 데이터베이스 객체로 등록할 수 없는 SELECT 명령을,    
객체로서 이름을 붙여 관리할 수 있도록 정의한 것           

뷰는 테이블처럼 취급할 수 있지만 '실체가 존재하지 않는다'라는 의미로 **'가상테이블'** 이라 불리기도 한다.   
뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 저장공간을 가지지 않는다.(물론 예외적인 방법은 있다.)  
이 때문에 테이블처럼 취급할 수 있다고 해도 SELECT 명령에서만 사용 하는 것을 권장한다.   
   
## 뷰의 장점      
**보안에 도움이 된다.**      
개인정보가 들어있는 테이블이 있다고 가정시    
이를 다름사람에게 권한을 부여하면 수정/삭제 등 데이터가 변경될 가능성   
개인정보 데이터를 조회함으로써 개인정보를 유출할 수 있기 때문에    
데이터 테이블 대신에 뷰에만 접근 권한을 주어 이러한 문제를 쉽게 해결한다.   
      
**복잡한 쿼리를 단순화 시켜 줄 수 있다.**  
코드가 긴 SELECT 쿼리가 있을시 이를 처음 작성하는 것은 문제가 없지만  
두번, 세번 즉 여러번 사용할 경우 코드 작성에대한 시간 소비가 많아 질 것이다.    
    
이렇듯 자주 사용하는 SELECT 쿼리문을 뷰로 만들어서    
재사용시 처음부터 다시 코드를 작성할 필요 없이 해당 뷰를 호출하면 된다.   
(WHERE 절 같은 추가 쿼리문도 뷰에 붙여서 사용하면 된다.)     

## 뷰의 약점
뷰는 데이터베이스 객체로서 저장장치에 저장된다.
하지만 테이블과 달리 대용량의 저장공간을 필요로 하지 않는다.
이유는 테이블을 저장하는 것이 아닌 명령어를 저장하는 것이기 때문이다.
다만 저장공간을 소비하지 않는 대신 CPU 자원을 사용한다.
이런 명령어들은 계산능력을 필요로 하기에 컴퓨터의 CPU를 사용하기 때문이다.
        
### 머티리얼라이즈드 뷰      
뷰의 근원이 되는 테이블 안에 보관하는 **데이터 양이 많은 경우,**    
또는 집계처리를 하는 경우에 뷰가 사용된다면 **처리속도가 많이 떨어진다.**   
또한 **뷰를 중첩해서 사용하는 경우에도 처리 속도가 떨어지기 쉽다.**   
        
이러한 문제점을 해결하기 위해 사용하는 것이 `머티리얼 라이즈드 뷰`이다.
일반적으로 뷰는 데이터를 일시적으로 저장했다가 쿼리가 실행 종료될 때 함께 삭제된다.
       
**머티리얼 라이즈드 뷰는 데이터를 `테이블처럼 저장장치에 저장`해두고 사용한다.**
머티리얼 라이즈드 뷰는 처음 참조되었을 때 데이터를 저장해둔다.  
이후 다시 참조할 때 **이전에 저장해 두었던 데이터를 그대로 사용한다.**  
다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 SELECT 명령을 재실행하여 데이터를 다시 저장해야 한다.
   
일종의 캐시 기능을 적용한 뷰   
즉, 뷰에 지정된 테이블의 데이터가 자주 변경되지 않는 경우라면 머티리얼라이즈드 뷰를 사용하자.
단 MySQL에서는 사용할 수 없다. Oracle과DB2에서만 사용할 수 있다.     
      
### 함수 테이블 - 이부분은 모르겠네요  
뷰를 구성하는 SELECT 명령은 단독으로 실행할 수 있어야 한다.
즉, 상관 서브 쿼리처럼, 부모 쿼리와 어떤 식으로든 연관된 서브쿼리의 경우에는 뷰의 SELECT 명령으로 사용할 수 없다.
대신 이 같은 뷰의 약점을 함수 테이블을 사용하여 회피할 수 있다.    
        
함수 테이블은 테이블을 결괏값으로 반환해주는 사용자 정의 함수이다.
함수에는 인수를 지정할 수 있기 때문에 인수의 값에 따라 WHERE 조건을 붙여 결괏값을 바꿀 수 있다.
그에 따라 상관 서브쿼리처럼 동작할 수 있다.   


# 💡 SQL과 NoSQL의 차이점에 대해 설명하시오.

# 💡 Select 쿼리 실행 순서    
![select 절](https://user-images.githubusercontent.com/50267433/116062492-e9b6cb00-a6be-11eb-848d-4537bcce0bbb.png)    
  
```sql
 FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY
```  
```sql  
 FROM - ON - JOIN - WHERE - GROUP BY - HAVING - SELECT - DISTINCT - ORDERBY - TOP    
```     
     
**쿼리 실행 순서는 왜 중요할까? 🤔**   
쿼리가 처리되고 어떻게 쿼리문을 작성하느냐에 따라 퍼포먼스의 차이가 발생한다.         
예를 들어, WHERE 절에 있는 내용을 HAVING절에서 사용할 수 있지만    
HAVING절에서 일반 조건들을 다루면 쿼리 실행 순서에 의해 퍼포먼스가 많이 떨어지게 된다.    
   
[매우 좋은 사이트](https://velog.io/@ha0kim/SQL)      
   
1. ALIAS 사용   
2. Oracle의 경우 Rownum

# 💡 PK와 FK 설명해주세요.
# 💡 서브쿼리가 뭐에요?
# 💡 서브쿼리의 성능은 어때요?
# 💡 %LIKE%와 elasticsearch의 차이점을 설명해주세요.
