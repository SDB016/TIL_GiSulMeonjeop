# JVM 

## JVM 이란?     
                                
자바 바이트 코드를 실행해주는 버츄얼 머신으로 바이트 코드를 현재 OS 환경에 맞추어 기계어로 변역하고 실행해준다.              
   
## JVM 흐름 
 
1. 자바 파일을 작성     
2. 자바 컴파일러를 통해서 바이트 코드인 클래스파일로 생성     
3. **클래스 로더를 통해 class 파일들을 JVM으로 로딩한다.**    
4. 로딩된 class 파일들은 **실행 엔진을 통해 해석된다.(인터프리터 및 JIT compiler)**      
5. 해석된 바이트코드는 **런타임 데이터 에리어(프로세스로부터 할당 받은 메모리)** 에 배치되어 수행이 이루어진다.   

## JVM 런타임 데이터 에리어 구성요소       

* **PC Register** 
    * 스레드의 실행 내역 저장하고, 스레드마다 하나씩 생성된다.        
* **Native Method Stack** 
    * 다른 언어로 작성된 코드를 Java Native Interface 를 통해 실행한다. 
* **Class Area** 
    * 초기화 되는 대상을 저장하는 공간  
    * Runtime Constant Pool, 필드 정보, 메서드 정보, 클래스 정보, 인터페이스 정보 

* **Heap** 
    * 객체들을 저장하는 공간으로, Class Area에 올라온 객체를 저장한다.(GC 범위다)    
* **Stack** 
    * 지역변수와 매개변수가 저장되는 영역    
    * LIFO 구조로 동작을 하고 함수가 종료되면 스택을 비운다.     
    * 스레드마다 별도로 생성된다.     
 
Stack을 공유하지 않는 이유는 스택의 자료구조 때문이다.        
LIFO 구조로되어있기 때문에 공유한다면 여러 스레드의 데이터 동시에 들어와서 순서가 뒤죽박죽 될 것이며       
스택을 비우는 과정에서도 참조가 남아있다면 문제를 유발시킬 수 있다.       

## JAVA는 인터프리터 언어 VS 컴파일 언어  
  
인터프리터의 특징과 컴파일 언어의 특지을 가지는 하이브리드 언어다.    

## JIT Compiler   
  
인터프리터로 해석을 진행하다가 핫스팟 디텍션이 발생하면 해석된 기계어를 캐싱하고 이후 캐싱된 데이터를 활용한다.     
참고로, 캐싱 데이터가 저장되는 곳은 code cache 이다.     

## 가비지 컬렉션이란?   
  
더이상 사용되지않는 인스턴스들을 메모리에서 해제하는 작업   
  
## 가비지 컬렉션 동작 흐름 설명 
   
1. 객체들은 Eden 영역에 생성되다가 꽉 차면 GC 시작        
2. STW : GC 쓰레드를 제외한 모든 쓰레드의 실행을 멈춘다.        
3. GC 발생    
    **GC 알고리즘 2개**      
    * 레퍼런스 카운팅         
        * 객체를 참조하는 레퍼런스의 숫자를 저장하는데 이 숫자가 0이 되면 메모리를 해제한다.         
        * 구현이 쉽지만, 순환참조에서는 GC를 발생시키지 못한다.       
    * 마크앤 스왑    
        * 객체 그래프 탐색을 통해 현재 참조되고 있는 객체에 마킹  
        * 마킹이 되지 않는 객체들은 더이상 사용하지 않는다고 판단하여 메모리 해제    
4. 살아남은 객체를 Survivor 영역에 옮기고 Age 1 증가     
5. 이같은 작업을 반복      
6. age가 특정 기준치 이상이 되면 Old 로 옮긴다.   
   
## Young 과 Old로 나눈 이유
* young Generation은 자주 발생 + 삭제되는 데이터 많음
* Old Generation은 간혹 발생 + 삭제되는 데이터 적음
  
객체들은 생성 시간에 따라 비슷한 영역/지역에 뭉쳐져 있다.  
하지만, 이러한 특징을 고려하지 않고 마킹을 위해 메모리를 풀스캔할 경우 이는 성능저하를 유발한다.   
  
* OLD + Young가 하나의 영역이라면 전체 영역을 순회해야함  
* OLD 한 객체들은 계속 살아있으므로 객체 그래프 탐색 지속적으로 이루어짐   
* 그래프 탐색 시간 길어짐에 따라 STW 도 길어지고 이로인해 성능 저하   

## G1GC 종류  

* Serial GC
* Parallel GC
* Parallel Old GC(Parallel Compacting GC)
* Concurrent Mark & Sweep GC(이하 CMS)
* G1GC (Garbage First GC)   
* ZGC (추가 예정)     

# JAVA 

## JDK 버전에 대한 설명 

**JDK8**
* Stream API 추가     
* Lambda API 추가    
* Functional 인터페이스
* Optional  
* 인터페이스 default 메서드
* 인터페이스 static 메서드
* try-with-resource

## Stream 설명
  
Stream은 대용량 데이터를 처리하기 위해 등장했다.      
    
1. 지연연산을 지원해서, 최종 연산시에만 필터링된 데이터들에 한하여 연산이 진행된다.             
2. 실제 데이터가 아닌, 복사된 데이터를 이용하여 불변을 보장해주며 동시성에도 이점이 있다.           
3. 람다를 지원하기에 문법을 내부로 숨겨 코드가 깔끔해지고 전략패턴과 같이 로직을 교체하면서 사용할 수 있다.       
4. parallel()를 통한 병렬화를 지원(JDK&의 ForkJoin 프레임워크를 이용하여 다수의 쓰레드로 병렬작업을 처리한다)  
    * 문제는 threadPool을 global하게 이용한다는 것      
    * 다른 병렬처리 요청은 블락상태가 되어 지연시간이 증가된다.  
    * 커스텀으로 비동기처리하면 된다는데 여기는 아직 공부를 안했다.   

## Lambda 설명   
  
자바의 익명함수로, 하나의 추상 메서드로 만들어질 수 있다.     
특징으로는 일급 시민으로서 메서드의 인자값으로 활용될 수 있다.                   
    
동작 원리는 variable capture 를 사용하여 외부에 정의된 원본을 복사해서 사용한다.       
람다는 별도의 쓰레드에서 운영되는데, 지역변수의 경우 스택에 저장되어있으니 이를 복사해서 사용한다.     
이 과정에서 쓰레드가 여러개이다 보니까 동시성 문제가 발생할 수 있어서 effectively final 한 요소만 사용하고자한다.     
하지만, effective final 조차 재할당 금지이기 때문에 내부가 불변이 아니면 이를 깨드릴 수 있다.     
   
* 코드를 간결하게 만들 수 있다
* 가독성이 향상된다
* 멀티쓰레드환경에서 용이하다
* 함수를 만드는 과정 없이 한번에 처리하기에 생산성이 높아진다

**단점**
* 람다로 인한 무명함수는 재사용이 불가능하다
* 디버깅이 많이 까다롭다
* 람다를 무분별하게 사용하면 코드가 클린하지 못하다
* 재귀로 만들 경우 부적합하다

## Optional 설명 
     
null 처리와 관련된 로직을 내부 동작으로 바꾸게 해주는 라이브러리다.         
null을 검사하고 실행하는 로직을 내부로 감출수 있으며 코드의 가동성을 증진시킨다.     

## 객체지향프로그래밍이란?  
  
* Object Oriented Programming으로 현실세계에 존재하는 논리적 개념적 개체를 객체로 표현해서 프로그래밍 하는 것      
* 자동차 프레임 객체 + 타이어 -> 자동차
* 오토바이 프레임 객체 + 타이어 -> 오토바이
* 자동차 프레임 객체 + 겨울용 타이어 -> 자동차긴하지만 기능 다름  

## 객체지향프로그래밍의 4가지 특징
  
* **캡슐화 :** 사물의 속성과 행위를 모으고 이를 정보 은닉하는 것           
* **상속 :** 코드의 재사용 보다는, 공통된 특징을 하나의 군집화 하는 것        
* **추상화 :** 사물의 특징을 파악해서 이를 하나의 개념으로 다루는 것      
* **다형성 :** 참조변수가 인스턴스에 따라 다양한 기능을 수행하는 것      

## 객체지향프로그래밍의 5대 원칙 
      
* **단일 책임 원칙(SRP) :** 객체는 단 하나의 책임만 가져야 한다.(변경/사용)      
* **개방-폐쇄 원칙(OCP) :** 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.  
* **리스코프 치환 원칙(LSP) :** 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.    
* **인터페이스 분리 원칙(ISP) :** 인터페이스가 하나의 동작만을 하도록 분리되어야 한다.   
* **의존 역전 원칙(DIP) :** 상위 모듈은 하위 모듈에 의존해서는 안되며 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.     
   
## 클래스와 인스턴스 차이 

* 클래스 사물에 대한 개념이자 틀        
* 객체는 클래스 정보를 기반으로 실제 메모리상에서 구현된 인스턴스      

## 클래스 오브젝트 인스턴스 이름 불리는 이유   
  
* 클래스 : 객체를 만들어 내기 위한 설계도(객체를 구성하느 메소드와 변수의 집합)    
* 오브젝트 : 소프트웨어 세계에 구현할 대상(아직 어떠한 메모리도 차지하지 않음)    
* 인스턴스 : class를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체(메모리에 할당)  
   
## 자바는 Call By Value?     

* 자바는 Call By Value, 참조는 실제 대상이 아닌 참조 대상의 주소값을 복사하는 방식이다.     
* 메서드 인자로 넘기고 메서드 내부에서 참조가 변경되어도 외부 참조 대상은 바뀌지 않는다.(참조 대상의 값이 바뀔지 언정)       
     
## static 은 무엇인가?   

Class Loader가 Class 정보를 로딩하는 과정에서 메모리에 할당하는 작업        
Class Loader가 Class 정보를 로딩하는 과정은 딱 1번만 실행된다.             
클래스 영역에 존재하기 때무네 힙이 해제되어도 계속 존재하며, 클래스별로 관리가 된다.      
    
## 추상 클래스와 인터페이스 설명 

* **추상 클래스 :**
    * 인스턴스 필드/메서드 선언 가능  
    * 하위 구현체는 단일 상속만 가능       
    * 인스턴스 생성 불가    
* **인터페이스** 
    * 인스턴스 필드/메서드 선언 불가능
    * 하위 구현체는 다중 구현 가능
    * static final 상수/메서드 선언 가능
    * 자바8 이후부터는 디폴트 메서드도 선언 가능    
   
이 둘의 장점은 하나의 공통된 규약을 만듬으로써 팀 개발에서 유용하다.       
     
## 추상 클래스와 인터페이스의 사용처   
       
**추상 클래스**  
* 인스턴스 변수나, 인스턴스 메서드가 필요할 때 사용한다.(인터페이스 디폴트로 인해 메서드는 요즘 잘 X)   
* 대표적으로 상태 패턴, 프록시 패턴, 데코레이터 패턴에서 사용된다.    
          
**인터페이스**   
* 거의 대부분의 추상화는 인터페이스를 이용하고 있다.      
* 함수형 인터페이스의 경우 람다로 사용도 가능해서 전략패턴으로 사용도 한다.   
   
## 자바에서 다중 상속을 지원하지 않는 이유와 다른언어는?       
자바의 경우 상위 객체들의 메서드 시그니처나, 변수의 이름 충돌이 발생할 가능성이 높다.   
이를 Diamon Problem 이라고 하는데 오버라이딩으로도 해결하기 힘들어서, 정책적으로 막았다.     
파이썬의 경우에는 먼저 입력한 클래스를 후위 클래스의 상위클래스로 둔다.   
  
참고로 인터페이스의 경우 이러한 문제에서 예외인데     
super.인터페이스.method() 형태로 상위 메서드를 호출할 수 있다.    
이는 큰 이유는 되지 않지만, 추상클래스 대신 인터페이스를 사용할 이유 중 하나가 된다.   

## 상속 VS 구현 어느것을 원하는지   
     
최대한 제약에 자유롭고 기능이 많은 구현을 사용하되     
공통된 메서드가 많거나, 필드를 통해서 상태를 표현해야한다면 상속을 고려해볼 것이다.    
하지만, 완벽한 상속 관계가 이루어지지 않는다면 컴포지션을 이용할 것이다.   
    
왜냐하면, 상속 같은 경우는 상위 클래스에 따라 하위 클래스의 의존도가 높아지는 문제가 있고     
만약 사용하지 않는 요소가 있다면, 에러를 유발할 수 있는 가능성이 높아지기 때문이다.    
      
## 상속을 잘못 구현한 클래스는?  

**Stack 같은 경우 벡터를 상속받는다.**     
1. 다중 상속 불가능        
2. 싱크로나이즈드가 있어서 모든 작업에 Lock을 건다(고유락 실행)        
3. 벡터 메서드를 사용할 수 있기에, 제약 사항 깨짐       
         
## ArrayDeque (더블큐)    
  
1. 초기 용량 설정 가능  
2. 배열이 차면, 2배의 크기로 복사해서 새로 할당한다. 

다만, 불필요한 메서드를 호출할 수 있는데 이는 일급 컬렉션으로 해결할 수 있다.      
 
## 자바의 싱크로나이즈드는 어떤 기법  
  
모니터 기법이다.   

* 뮤텍스 : 프로세스간에 공유 객체에 대해서 사용     
* **모니터 : 프로세스내의 스레드 간의 동기화에 사용되며 프로세스내에서 동작하므로 프레임워크나 라이브러리 자체에서 제공된다.**        
         
## final 클래스는?     
* Integer, Long, Double과 같은 리터럴 박싱 클래스와 String 클래스      
* 상속을 허용할 경우, 메서드 오버라이딩으로 이상한 로직을 호출할 수 있게되고 이로인해 시스템에 악영향 가능        
* String은 자신이 변경되지 않는다는 것을 알고 있기 때문에 해시코드를 캐시한다.         

## String Constant Pool
  
String literal로 생성한 값은 Heap 영역 내 "String Constant Pool"에 저장되어 재사용된다.      
반면에, `new String()`으로 생성하면 Heap 영역에 새로 할당하기 때문에 같은 내용이라도 영역을 차지한다.          
`new String()`으로 생성한 객체도 `intern()`을 사용하면 String Constant Pool 객체로 전환된다.     

## 불변이란?      
## 불변의 장점     
## 불변의 단점   

## 동등성 비교를 위한 작업은? (이퀄스 해시코드 재정의)   
  
일반적인 double equal sign(==) 동등성 비교는 `equals()` 를 재정의하면된다.       
그러나, HashSet, HashMap, HashTable 같은 경우는 `equals()`가 아닌 hashCode를 동등성 비교 기준으로 삼는다.      
더불어, hashCode의 디폴트 연산값은 객체의 기본값이기 때문에, 논리적 동등성이 확립해도 Hash 자료구조에거 값을 꺼내지 못한다.     
그렇기 때문에 재정의는 잊지 말자     

## 해시 알고리즘이란  

입력된 데이터를 특정한 계산 알고리즘을 활용하여 분류하고       
분류된 데이터를 각각의 알맞는 버킷에 저장하는 알고리즘이다.      
데이터 조회시 특정 영역의 버켓만 찾으면 되므로 조회 성능이 빨라진다.  

## 해시 충돌   

해싱을 올바르게 하지 않아, 다른 데이터와 동일한 key값을 갖게되는 것을 의미한다.  
즉, 나중에 들어온 데이터가 기존의 데이터를 덮어쓰면서 원래 바랐던 값이 안나오게 되는 문제다.   

이를 해결하기 위한 작업은 아래와 같다.  

* 체이닝 :  링크드 리스트로 이루어져있지만 키에 여러 데이터가 들어가기에 좋은 방법은 아니다.    
* 개방 주소법 : 키가 충돌되면 다른 버킷으로 옮기지만 나중에 충돌률이 더 높아지기에 좋은 방법은 아니다.  
* 결론적으로는 해싱 알고리즘을 잘 작성하는 것이 좋다.       
   
자바에서는 Objects.hash()를 이용하는 방법이 있다.  

## 해시맵, 해시테이블 차이
     
* HashMap : 
    * 주요 메소드에 synchronized 키워드가 없다. 
    * key, value에 null을 입력할 수 있다.  
* HashTable : 
    * 주요 메소드에 synchronized 키워드가 선언되어 있다.
    * key, value 에 null을 입력할 수 없다.  
* ConcurrentHashMap: 
    * HashMap을 thread-safe 하도록 만든 클래스가 ConcurrentHashMap입니다.    
    * 단, key, value 에 null을 입력할 수 없으며 putIfAbsent라는 메소드 가집니다.     
       
## Serializable   
> Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술   

* **Serialize :** JVM 메모리에 할당되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.           
* **Deserialize :** 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM 메모리에 할당시킨다.          

**직렬화 조건** 
* `java.io.Serializable` 인터페이스를 상속받은 객체여야한다.        
* 메서드가 없는 마커 인터페이스로 JVM에서 컴파일할때 직렬화가 가능한 객체라고 힌트를 준다.             
  
**역직렬화 조건**  
* serialVersionUID 를 가지고 있어야한다.   
* 직렬화/역직렬화는 엄격하기 때문에, 클래스의 정보가 바뀌면 아에 서로 다른 객체로 인식한다.       
* 직렬화 이후, 클래스를 수정하면 다른 객체로 인식하기 때문에 역직렬화가 이루어지지 못한다.       
* 만약 별도로 지정하지 않으면, 자바 소스가 컴파일될 때 자동으로 생긴다.  

**사용처**   
* Ehcache, Redis, Memcached 라이브러리 시스템을 많이 사용됩니다.  
* 자바 RMI(Remote Method Invocation)에서 원격 시스템 간의 메시지 교환을 위해서 사용  

## 얕은 복사와 깊은 복사  
  
* 얕은 복사 : A라는 객체를 복사했을 때 내부에 구현되어 있는 참조변수들의 참조값도 그대로 복사한다.      
* 깊은 복사 : A라는 객체를 복사했을 때 내부에 구현되어 있는 참조변수들의 참조값도 달라진다.       

**얕은 복사 방법**   
* Collections.copy()  
* @Cloneable with super.clone()  
   
**깊은 복사 방법**   
* System.arraycopy();

## Array VS ArrayList 
**Array**   
* 크기가 고정되어 있다.  
* 메모리에 연속적으로 들어가 있다.   
* 탐색시 속도가 `O(1)`        
* 중간에 존재하는 데이터 추가 삭제시 최악의 경우 `O(N)` 발생  
   
**List**      
* 크기가 동적이다.     
* 메모리가 연속적이지 않다.    
* 일반 배열에 없는 컬렉션 메서드를 지원한다.   
* 중간에 데이터를 추가 또는 삭제시 
    * 맨 앞이라면 O(1) 
    * 맨 뒤라면 O(N)    

**ArrayList**      
* 크기가 동적이다.     
* 메모리가 연속적이다.     
* add 되었을 경우 시간복잡도는 O(1)이다.    
    * 기본 사이즈는 10이고, 그 이상 add 될경우 복사후 새로 메모리를 할당한다.       
    * 이때, 시간복잡도를 O(N)으로 생각할 수 있는데 빈도수가 적어서 그냥 O(1)로 처리한다.   


# JDK 버전별 특징 
* JDK 8: 
    * 인터페이스 - default 메서드
    * 인터페이스 - static 메서드
    * try-with-resource : 괄호안에 변수 선언해야함 
* JDK 9: 
    * 인터페이스 - private 선언 가능(default/static) 
    * try-with-resource : 괄호 밖, 실질적인 final 변수 가능 
    * List.of()와 같은 컬렉션 프레임워크 팩토리 메서드 제공(불변 컬렉션)
    * Arrays - Arrays.compare(a,b), 배열의 논리적 순서반환(-1 a빠름, 0 ab같음, 1 b빠름)
    * Arrays - Arrays.missmatch(a,b), 배열비교시 다른 첫번째 인덱스 반환  
* JDK 10:
    * var 타입 추가 
* JDK 11: 
    * String인스턴스.isBlank() - 공백문자로만 이루어졌는지 판단   
    * String인스턴스.lines() - 개행 제거해서 stream 돌림
    * String인스턴스.repeat(10) - 해당문자열을 반복해서 더한 문자열 반환
    * String인스턴스.strip() - 공백문자에 해당하는 앞뒤를 제거 
    * Files.writeString() - 문자열을 파일로 저장 가능
    * Files.readString() - 파일에서 문자열 읽기 가능 
* JDK 12:
    * indent(int n) - 숫자만큼 들여쓰기(양수 들여스기, 음수 내어쓰기)   
    * "".transform(람다) - 문자열을 다른걸로 바꾸는 함수를 넣을 수 있음 
* JDK 14:
    * switch - 식으로 사용할 때, 화살표 함수 및 반환 기능 제공   
* JDK 15: 
    * text블록 : `""" 내용 """`를 이용하면 벡틱 처럼 텍스트 블록 가능 
    * "".formatted() : String.format() 대타  
    * NPE 메시지 (누가 널인지 알려줌)   
* JDK 16: 
    * stream - toList() -> Collectors.toList() 대신
    * stream - mapMulti() -> 값을 하나를 받아서 여러개 생성 가능    
    * instanceOf 패턴 매칭 
    * record 클래스 - 코틀린의 value 클래스 같은 클래스(VO만들때 좋다.)   

# 기타 
## String 인코딩은?   
UTF-16 -> 이것에 대해서 원인을 찾고자 했는데 못찾았다.     
Char가 2바이트인 것을 통해 알 수 있다.      
         
## add vs offer / remove vs poll 
   
**익셉션 발생**
* add : Exception  
* remove : Exception  
* element : Exception 

**널 반환**
* offer : null
* poll : null  
* peek : null

