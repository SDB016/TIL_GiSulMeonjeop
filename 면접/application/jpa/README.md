# JPA
## JPA란?   
  
JPA는 자바 ORM 기술에 대한 API 표준 명세이다.
   
## ORM 이란?  
   
**Object Relation Mapping**     
* 객체와 관계형 데이터베이스를 매핑해주는 기술      
* 객체와 테이블을 매핑해서 패러다임 불일치 문제를 개발자 대신 해결해준다.          
* 자바는 보다 정교한 모델링에 집중, DB는 데이터 중심적인 모델링에 집중 가능    

## JPA를 사용하게 되면 얻게 되는 이점은?     

* 패러다임 불일치 문제 해결 
    * 객체지향 프로그래밍의 특징이 상속을 사용 가능하다.    
    * 객체그래프를 통해, 추가 쿼리없이 객체를 연속적으로 호출하여 사용할 수 있다.    
* 빠른 생산성 
    * 쿼리를 자동으로 만들어준다.  
    * Spring Data JPA와 같은 라이브러리를 활용하면 생산성이 더욱 좋아진다.    
* 성능 
    * 애플리케이션과 DB 사이에 위치하기 때문에 캐싱과 같은 성능 최적화를 지원해준다.   

결과적으로 정교한 객체 모델링을 할수 있도록 해주고 생산성을 높여준다.    

## JPA의 단점 

* JPA만 사용하여 복잡한 연산을 수행하기에는 다소 무리가 있다. (로직이 복잡하거나 불필요한 쿼리가 발생할 수 있다.)
* 초기에는 생산성이 높을 수 있으나 점차 사용하다 보면 성능상 이슈가 발생할 수 있다.(N+1, FetchType, Proxy, 연관관계)
* 고도화 될수록 학습 곡선이 높아질 수 있다. (성능 이슈의 연장선으로 해결 방안에 따라 복잡한 내부 로직을 이해해야 할 필요가 있다)

## JPA VS MyBatis  

* JPA는 ORM이고 MyBatis는 SQL Mapper다.   
* 쿼리매퍼로서 SQL문을 개발자가 직접 작성하여 RDB에 접근하고 반환된 데이터를 객체화 시켜준다.

## DataSource  
   
* Datasource는 java 에서 connection pool을 지원하기 위한 인터페이스    

## Hibernate(하이버네이트)
  
* 하이버네이트는 JPA의 표준을 실제로 구현하는 구현체이다.      

## 영속성 컨텍스트(1차 캐시)    

* 엔티티를 영구 저장하는 환경을 의미한다.(필자는 엔티티 컨테이너라 생각한다.)   
* 일종의 '캐시'와 같은 역할을 수행하며, 내부적으로 엔티티를 보관하고 있다.        
* 논리적인 개념으로 EntityManager를 생성할 때 하나 만들어진다.          

## 엔티티 생명주기 

1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속 : 영속성 컨텍스트에 저장된 상태
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 : 삭제된 상태
  
## flush 와 commit 의 차이  
  
* flush : 단순히 데이터베이스의 값을 갱신하겠다, 롤백시 대상이 되어 초기화될 수 있다.       
* commit : flush를 수행하고, 해당 데이터가 데이터베이스에 영구저장되는 것을 선언한다.        
  
JPA는 **쓰기지연** 방식을 채택해서 commit 같은 경우 주로, 트랜잭션이 끝날 때 발생한다.    
예외로 AUTO_INCREMENT의 경우, 데이터를 저장할 때 flush 통해서 ID값을 갱신하는 추가작업을 한다.       

## 더티체킹(변경감지)   
  
영속성 컨텍스트에 등록된 엔티티의 값이 애플리케이션으로 인해 변경되었을 경우      
update문을 날리지 않고도, 변경 쿼리를 날려주는 작업    

## EAGER 로딩과 LAZY 로딩 차이 
         
FethType 같은 경우, 단일 엔티티의 연관관계 필드에 대해서 영속성을 관리해주는 속성이다.             
* EAGER로 되어있을 경우, 엔티티를 영속화 할때 연관관계 필드도 같이 영속성 조회를 해서 영속성 컨텍스트에 저장한다는 뜻이다.       
* LAZY로 되어있을 경우, 엔티티를 영속화 할때 연관관계 필드의 참조 대상을 프록시로 가져오고 실제 사용시 영속성 조회를 한다.    
  
## 엔티티란?      

* JPA가 관리하는 클래스로 실제 데이터베이스 테이블과 매핑된 클래스를 의미한다.     
* 식별자를 통해서만 식별이 되며, 데이터가 다른데 같은 식별자면 동일 엔티티로 취급한다.   

## VO란?         
    
* 숫자, 알파벳과 같이 하나의 값으로써 취급되는 클래스다.     
* VO는 사실 엔티티에 한정적인 클래스는 아니지만, JPA를 기준으로 보면 엔티티의 내부 객체로 사용될 수 있다.      
* 모든 값이 동일해야 같은 값으로 인정을하고, 불변을 지켜주는 것이 좋다.      

## 엔티티와 VS VO        

* 엔티티는 실제 데이터베이스의 테이블과 매핑된 객체   
    * ID값으로만 동등성을 판단한다.       
    * 생명주기가 있다.
* VO는 JPA 기준으로 엔티티 내부에 선언되어 사용되는 값 객체 
    * 모든 값으로 동등성을 판단한다.    
    * 생명 주기를 엔티티에 의존한다.
    * 엔티티 도메인 로직을 VO로 분산시킬 수 있는 장점이 있다.   
    * 불변 객체로 만드는 것이 안전하다.

## 양방향 연관관계 매핑을 사용하면 안되는 이유  
   
* 순환 참조가 발생해서 시스템에 악영향을 미칠 수 있다.       
* 개인적으로 양쪽에서 참조가 가능하므로 사용시 어떤 엔티티를 사용할 것인지 혼돈을 줄 수도 있을 것 같다.  

## N+1    
  
조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개가 더 발생하는 문제.
     
사실 페치 조인을 하지 않으면 거의 모든 연관관계에서 발생한다.       
findById의 경우 내부적으로 최적화된 메서드를 활용해서 JOIN을 하고 값을 가져오기도 한다.(EAGER/EAGER 제외)       
            
반면에, findAll()를 사용하면 모든 엔티티를 가져오는데 내부적으로 where 를 사용해서 조회하고          
FetchType이 단일 엔티티에 대해서 연관된 엔티티를 영속하는 것이여서 연관된 엔티티의 갯수만큼 추가적으로 쿼리를 날린다.     
      
ManyToOne의 경우 FetchJoin을 활용하고       
OneToMany의 경우 페이징 처리까지 고려해서 In절을 활용하는 배치사이즈를 이용하는 것이 좋다.     
  
## Fetch Join시 Paging이 안되는 이유      
    
* ManyToOne : 데이터가 뻥튀기 되지 않기 때문에 사용이 가능하다.     
* OneToMany : 조인시 One을 기준으로 하기에 Many만큼 데이터가 추가로 늘어난다.      
    * 데이터가 예상치보다 많아지기 때문에 경고 로그를 남기고 인 메모리에서 페이징을 처리한다.    
    * 잘못하면 OOM이 터질수도 있다.     
    
아, 참고로 OneToMany 의 경우 패치조인시 1개의 엔티티당 N만큼 더 엔티티를 가져온다.                 
엔티티로 각성할때 컬렉션 필드에 다 담지만, 실제 테이블에는 여러 행이 있어서 그만큼 더 가져온다.          
이를 해결하기 위해서는 distinct 나 Set 자료구조를 사용해서 최적활르 할 수 있다.     

## 낙관적 락 / 비관적 락   

**낙관적 락**
* 낙관적 락은 이름 그대로 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다. 
* DB 락 기능 대신, JPA가 제공해주는 버전 관리 기능을 사용한다.(애플리케이션에서 제공하는 락)     
* 단점으로, 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다. 
* @Version 을 사용하고, 트랜잭션 종료마다 버전이 증가된다.        
   
**비관적 락**   
* 비관적 락은 이름 그대로 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다.      
* DB가 제공하는 락 기능을 사용하는데 이때, 대표적으로 select for update 구문이 있다.(참고)    
* 이론적으로 표현하자면 동시성 제어를 위하여 특정 데이터(ROW)에 대해 베타적 LOCK을 거는 기능이다.(InnoDB부터)    
* LockModeTypeType.PESSIMISTIC_WRITE 사용     
  
## 2차 캐시   

![3](https://user-images.githubusercontent.com/50267433/147049313-a75725f3-174f-401f-8ea3-50f4e9cb5194.png)

2차 캐시는 애플리케이션 범위의 캐시로 애플리케이션을 종료할 때까지(서버 종료시까지) 캐시가 유지된다.   
엔티티 매니저를 통해 데이터를 조회할 때 우선 2차 캐시에서 찾고 없으면 데이터베이스에서 찾는다.

**흐름**  
1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회한다.
2. 2차 캐시에 엔티티가 없으면 데이터베이스를 조회해서
3. 결과를 2차 캐시에 보관한다.
4. 2차 캐시는 자신이 보관하고 있는 엔티티를 복사해서 반환한다.
5. 2차 캐시에 저장되어 있는 엔티티를 조회하면 복사본을 만들어 반환한다.
   
**사용법** 
* 엔티티에 @Cacheable 를 붙이면 된다.         
* entityManagerFactory의 sharedCacheMode 속성을 ENABLE_SELECTIVE 로 맞춘다.        

## OSIV    

* OSIV(Open Session In View)는 영속성 컨텍스트를 뷰(필터)까지 열어두는 기능이다.  
* 뷰까지 영속성 컨텍스트가 살아있다면 뷰에서도 지연 로딩을 사용할 수가 있다.
* 단점으로, 커넥션이 뷰까지 연결되어있어서 성능 저하를 유발한다.   
* 이러한 문제를 해결하기 위해 CORS도 고려해볼만 하다.  

  
# QueryDSL 이란?   


## QueryDSL 사용 이유   
 
1. 코드로 쿼리를 작성함으로써, 컴파일 시점에 문법 오류를 쉽게 확인할 수 있다.        
2. 코드로 쿼리를 작섬함으로써, 자동 완성 등 IDE의 도움을 받을 수 있다.       
3. 동적인 쿼리 작성이 편리하다.(조건절 추가와 같은)         
4. 쿼리 작성 시 제약 조건 등을 메서드 추출을 통해 재사용할 수 있다.      
        
실제로 진행했던 프로젝트중에서      
데이터를 조회하는데 쿼리 파라미터에 따라 조회 쿼리를 달리하는 경우가 있었다.      
JPQL로 작성하면 `isNull or 조건`과 같은 편법을 이용해야 했는데 QueryDSL 덕분에 손쉽게 개발할 수 있었다.  
  
## QueryDSL 사용시 주의점    
* exist의 경우 카운트 쿼리를 날리므로 limit을 이용해서 성능 개선하자          
* where절의 동치로 묵시적 Join을 하는 경우 Cross Join이 발생하니 명시적으로 바꾼다.     
* 엔티티를 호출할 경우, 불필요한 컬럼과 연관관계를 가져오고 성능이 다소 저하되므로 DTO를 사용하자     

## QueryDSL 단점  
  
* 복잡한 환경설정이 필요하다.   
* 불필요한 Q클래스를 생성하여야 한다.
* 잘못 사용하면, QueryDSL과 JPA에 의존적인 코드를 만든다.  
