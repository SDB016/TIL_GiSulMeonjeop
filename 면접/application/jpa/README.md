# JPA
## JPA란?   
  
JPA는 자바 ORM 기술에 대한 API 표준 명세이다.
   
## ORM 이란?  
   
**Object Relation Mapping**     
* 객체와 관계형 데이터베이스를 매핑해주는 기술      
* 객체와 테이블을 매핑해서 패러다임 불일치 문제를 개발자 대신 해결해준다.          
* 자바는 보다 정교한 모델링에 집중, DB는 데이터 중심적인 모델링에 집중 가능    

## JPA를 사용하게 되면 얻게 되는 이점은?     

* 패러다임 불일치 문제 해결 
    * 객체지향 프로그래밍의 특징이 상속을 사용 가능하다.    
    * 객체그래프를 통해, 추가 쿼리없이 객체를 연속적으로 호출하여 사용할 수 있다.    
* 빠른 생산성 
    * 쿼리를 자동으로 만들어준다.  
    * Spring Data JPA와 같은 라이브러리를 활용하면 생산성이 더욱 좋아진다.    
* 성능 
    * 애플리케이션과 DB 사이에 위치하기 때문에 캐싱과 같은 성능 최적화를 지원해준다.   

결과적으로 정교한 객체 모델링을 할수 있도록 해주고 생산성을 높여준다.    

## JPA의 단점 

* JPA만 사용하여 복잡한 연산을 수행하기에는 다소 무리가 있다. (로직이 복잡하거나 불필요한 쿼리가 발생할 수 있다.)
* 초기에는 생산성이 높을 수 있으나 점차 사용하다 보면 성능상 이슈가 발생할 수 있다.(N+1, FetchType, Proxy, 연관관계)
* 고도화 될수록 학습 곡선이 높아질 수 있다. (성능 이슈의 연장선으로 해결 방안에 따라 복잡한 내부 로직을 이해해야 할 필요가 있다)

## JPA VS MyBatis  

* JPA는 ORM이고 MyBatis는 SQL Mapper다.   
* 쿼리매퍼로서 SQL문을 개발자가 직접 작성하여 RDB에 접근하고 반환된 데이터를 객체화 시켜준다.

## DataSource  
   
* Datasource는 java 에서 connection pool을 지원하기 위한 인터페이스    

## Hibernate(하이버네이트)
  
* 하이버네이트는 JPA의 표준을 실제로 구현하는 구현체이다.      

## 영속성 컨텍스트(1차 캐시)    

* 엔티티를 영구 저장하는 환경을 의미한다.(필자는 엔티티 컨테이너라 생각한다.)   
* 일종의 '캐시'와 같은 역할을 수행하며, 내부적으로 엔티티를 보관하고 있다.        
* 논리적인 개념으로 EntityManager를 생성할 때 하나 만들어진다.          

## 엔티티 생명주기 

1. 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속 : 영속성 컨텍스트에 저장된 상태
3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제 : 삭제된 상태
  
## flush 와 commit 의 차이  
  
* flush : 단순히 데이터베이스의 값을 갱신하겠다, 롤백시 대상이 되어 초기화될 수 있다.       
* commit : flush를 수행하고, 해당 데이터가 데이터베이스에 영구저장되는 것을 선언한다.        
  
JPA는 **쓰기지연** 방식을 채택해서 commit 같은 경우 주로, 트랜잭션이 끝날 때 발생한다.    
예외로 AUTO_INCREMENT의 경우, 데이터를 저장할 때 flush 통해서 ID값을 갱신하는 추가작업을 한다.       

## 더티체킹(변경감지)   
  
영속성 컨텍스트에 등록된 엔티티의 값이 애플리케이션으로 인해 변경되었을 경우      
update문을 날리지 않고도, 변경 쿼리를 날려주는 작업    

## EAGER 로딩과 LAZY 로딩 차이 
         
FethType 같은 경우, 단일 엔티티의 연관관계 필드에 대해서 영속성을 관리해주는 속성이다.             
* EAGER로 되어있을 경우, 엔티티를 영속화 할때 연관관계 필드도 같이 영속성 조회를 해서 영속성 컨텍스트에 저장한다는 뜻이다.       
* LAZY로 되어있을 경우, 엔티티를 영속화 할때 연관관계 필드의 참조 대상을 프록시로 가져오고 실제 사용시 영속성 조회를 한다.    
  
## 엔티티란?      

* JPA가 관리하는 클래스로 실제 데이터베이스 테이블과 매핑된 클래스를 의미한다.     
* 식별자를 통해서만 식별이 되며, 데이터가 다른데 같은 식별자면 동일 엔티티로 취급한다.   

## VO란?         
    
* 숫자, 알파벳과 같이 하나의 값으로써 취급되는 클래스다.     
* VO는 사실 엔티티에 한정적인 클래스는 아니지만, JPA를 기준으로 보면 엔티티의 내부 객체로 사용될 수 있다.      
* 모든 값이 동일해야 같은 값으로 인정을하고, 불변을 지켜주는 것이 좋다.      

## 엔티티와 VS VO        

* 엔티티는 실제 데이터베이스의 테이블과 매핑된 객체   
    * ID값으로만 동등성을 판단한다.       
    * 생명주기가 있다.
* VO는 JPA 기준으로 엔티티 내부에 선언되어 사용되는 값 객체 
    * 모든 값으로 동등성을 판단한다.    
    * 생명 주기를 엔티티에 의존한다.
    * 엔티티 도메인 로직을 VO로 분산시킬 수 있는 장점이 있다.   
    * 불변 객체로 만드는 것이 안전하다.

## Fetch Join시 Paging이 안되는 이유   
## N+1  
## 낙관적 락 / 비관적 락 
## OSIV    


# QueryDSL
## QueryDSL 사용 이유 
## QueryDSL 단점  

* 속도차이 비교했는데 크게 없다.   
