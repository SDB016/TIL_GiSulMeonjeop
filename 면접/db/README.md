# 파티셔닝 
## 파티셔닝이란?   

* 테이블의 데이터가 무수히 많아졌을 때, 하나의 논리적인 테이블을 다수의 물리적인 파티션(테이블)로 나누어 관리하는 방법을 의미한다.     
* 테이블의 데이터 검색 시 필요한 부분만 탐색해 성능이 증가한다.            
* 인덱스의 성능까지 같이 향상시키려면 인덱스 또한 파티션으로 나눠줘야 한다.(로컬 파티션)          
  
## 수평 파티션의 종류와 설명   
  
* 레인지 파티션 : 범위를 기준으로 파티션   
* 리스트 파티션 : 주제를 기준으로 파티션   
* 해시 파티션 : 해시 알고리즘을 이용해서 파티션  

## 파티셔닝의 장단점 

**장점**  
* 테이블이 분할되었기에 액세스 범위가 줄어들어 검색속도가 향상된다.    
  
**단점**
* 테이블의 조인 비용이 증가한다.    
* 하나의 논리적인 테이블을 유지하도록 여러 테이블을 관리해야한다.          
  
# 샤딩
## 샤딩이란?

* 하나의 논리적인 테이블을 다수의 스키마와 파티셔닝 테이블로 나누는 것     
* 수평 파티션과 다르게 스키마까지 복사하여 나누는 작업이다.    

## 샤딩의 종류와 서명

* 모듈러 샤딩 : 해시 알고리즘을 이용해서 샤드키를 만들고 여러 샤드로 나누는 방법, 구현이 쉽다.         
* 레인지 샤딩 : 각각의 범위에 샤드키를 매핑하고 여러 샤드로 나누는 방법, 샤드 개수가 변경될때 유용하다.       
* 엔티티 그룹 : 파티션한 테이블과 연관된 테이블도 함께 샤딩하여 동일한 스키마안에서 관리하는 것(조인에 유리)     

## 샤딩의 장단점   
  
**장점**    
* 무거운 테이블을 분리했기에 데이터 액세스 범위가 줄어들어 조회 속도가 향상되었다.        

**단점** 
* 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다.   
* 스키마가 나뉘어졌기에 auto increment 등은 샤드 별로 달라질 수 있다.      

# 쿼리 동작과 Explain  
## 쿼리 실행시 동작 흐름 서명

1. 쿼리를 입력하면 처음에는 쿼리 캐시에서 캐싱이 가능한지 확인한다.   
2. 캐싱이 가능하지 않다면 쿼리 파서를 통해서 쿼리를 작은 단위로 나누어 파스트리를 만든다.  
3. 쿼리 파서로부터 나온 파스트리를 전처리기를 통해서 문법 검사를 한다.       
4. 문법 검사까지 완료된 파스트리를 쿼리 옵티마이저가 분석해서 실행계획을 도출한다.  
5. Explain일 경우 실행계획을 보여주는 것으로 끝난다.  
6. 쿼리 실행엔진이 API Calls 를 통해 스토리지 엔진을 호출하여 쿼리를 실행한다.(innoDB)

## SlowQuery란?

데이터 조회가 느린 쿼리를 말한다.  

## SlowQuery를 해결하기 위해서 어떻게 작업하는지?  

필자 같은 경우는 EXPLAIN 키워드를 사용하여 쿼리가 어떻게 돌아가는지 확인한다.       
풀테이블 스캔이 일어나는지, 인덱스를 탔는지 확인하고(type, extra)            
MySQL Virtual EXPLAIN을 사용하면 실행 속도도 예측할 수 있다.            
       
# 인덱스      
## 인덱스란?  
  
데이터베이스에서 데이터를 찾기 위한 색인이다.     
     
## 인덱스 컬럼 선정 순위(상황설명 가능)    

* 카디널리티가 높은 순으로 인덱스 컬럼을 설정한다.        
    * 카디널리티가 높다는 것은 중복이 없이 최대한 고유한 값들을 의미한다.      
* 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정합니다.
* '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둡니다  

## 인덱스 알고리즘은?        

MySQL의 인덱스 알고리즘은 과거에는 B-Tree 였지만, 현재는 B+Tree로 알고 있다.   

## B-Tree 및 B+Tree 설명    

B-Tree는 밸런스드 트리로서, 좌우 균형을 맞추는 트리이다.         
데이터베이스는 각각의 페이지를 통해서 데이터에 접근하는데           
페이지에 접근하는 횟수가 적어야 데이터를 더 빨리 찾을 수 있기 때문에     
비교적 트리 레벨을 낮게 유지시켜주는 B-Tree가 유용하다.   
    
B+Tree는 B트리의 개량형 트리로서          
리프 노드에만 데이터들이 있어서 페이지에 더 많은 데이터들이 들어가 레벨이 더 낮아지고     
리프 노드들은 서로 양방향 연결 리스트로 이루어져있어, 범위 탐색에 있어서 상위 페이지를 들리지 않고 바로 범위 검색이 가능하다.  
  
## B-Tree VS Hash 방식  
     
Hash 방식 같은 경우는 O(1)로 매우 빠르지만, 범위 탐색을 지원해주지 않는다.      
반면에 B-Tree는 범위 탐색에 유용해서 MySQL은 B-Tree를 사용한다.    

## Red-Black Tree를 사용하지 못하는 이유      
  
레드-블랙 트리의 경우 페이지에 데이터를 한개만 넣어야 하며        
비트리는 물리적으로 비슷한 위치에 데이터가 있는 반면,      
레드 블랙은 다음 페이지를 찾고 이동하는 작업까지 있어서 퍼포먼스에서 조금 아쉽다.  

## 클러스터드 인덱스란?  

테이블에 단 1개만 존재하는 인덱스로    
주로 PK 컬럼이거나 PK컬럼이 없다면 Unique NotNull 키가 클러스터드 인덱스가 된다.(이마저도 없으면 내부적으로 만드는걸로 안다)     
데이터 페이지의 정렬 기준이되기도하며, 리프 페이지가 데이터 페이지여서 데이터를 가지고 있다.        
    
## 논클러스터드(보조) 인덱스란?     
       
사용자가 추가로 정의한 인덱스이다.         
Unique를 설정하면 자동으로 생성되고, CREATE Index로도 생성할 수 있다.         
리프 페이지가 클러스터드 인덱스의 루트 페이지이다.    
클러스터드가 없다면, 데이터페이지의 페이지번호 와 순서를 값으로 가진다   

## 클러스터드 인덱스 VS 논클러스터드 인덱스  
  
클러스터드 인덱스의 경우 리프 노드가 데이터 페이지이고 바로 데이터 조회도 가능하다.     
반면에 논클러스터드 인덱스는 인덱스를 타고도 클러스터드 인덱스의 루트 페이지로 이동하기에 속도가 비교적 느리다.  
  
참고로 인덱스의 개수는 총 4~5개가 적절하다고 한다.  
   
## 멀티 컬럼 인덱스   
  
이름 그대로 인덱스 설정 컬럼의 기준으로 여러개로 잡는 것이다.   

## 멀티 컬럼 인덱스 주의사항 
  
* 카디널리티가 높은 컬럼을 앞으로 가져오는게 속도면에서 좋다.         
* 맨 앞에 있는 컬럼을 조회로 사용하지 않으면 인덱스를 타지 않는다.    
* 단일 컬럼 인덱스보다 공수비용이 커서 정말 조회만 하는 데이터에 사용하는게 낫다.    

# 인덱스 튜닝  
## 인덱스 튜닝 방법은?   

* 인덱스 스캔 범위를 줄인다.  
    * 조건절을 이용해 범위를 좁히면 성능이 좋아진다.   
* 랜덤 액세스 최소화  
    * 조회에 사용될 컬럼값들을 인덱스로 설정 
    * 모든 컬럼에 대해서 할 경우, 커버링 인덱스도 가능       

# 이중화     
## 이중화란?     
      
데이터베이스 서버와 스토리지를 하나 더 두고, DB간의 데이터를 동기화하는 작업     
   
## 이중화 사용 이유   

* 스케일 아웃 : 부하분산을 한다.        
* 데이터 백업 : DB가 고장나도 백업 서버를 통해 가용성을 높인다.  
* 데이터 분석 : 대용량의 데이터는 조회하는데 시간이 걸리는데, 분석용 DB로 사용하여 지연을 막는다.  
* 데이터의 지리적 분석 : 클라이언트와 비교적 가까운곳에 서버를 두어 조회 속도를 높인다.   
  
## 바이너리 로그      

* MySQL 서버에서 발생하는 모든 변경사항을 별도의 로그 파일에 순서대로 저장하는 파일    
  
**이중화 작업**   
* 소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고
* 레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤
* 자신이 가진 데이터에 반영함으로써 소스 서버와 레플리카 서버가 동기화가 이루어진다.

# 정규화와 비정규화 
## 정규화란?
## 제1 정규화란?
## 제2 정규화란?
## 제3 정규화란?
## 비정규화란? 
## 비정규화 예시 

# 트랜잭션 
## 트랜잭션 특징 4가지 

* Atomic : 모든 세부 작업들이 완료되어야 완료되고, 하나라도 실패하면 다 실패해야한다.
* Consistency : 모든 트랜잭션은 무결성 제약 조약 조건을 만족해야한다.(무결성 제약조건)
* Isolation : 트랜잭션이 동작을 할때 다른 트랜잭션의 간섭을 받지 않아야한다.
* Dulablity : 커밋이 완료되면 해당 데이터는 DB에 지속적으로 반영이 되어야한다.

## 트랜잭션 Isolation 4단계  

* **read uncommitted :** 커밋되기전의 데이터도 읽을 수 있다.
    * Dirty Read : 롤백이되는데 다른 트랜잭션에서 그 값을 그대로 가지고 있을 수 있다.
* **read committed :** 커밋된 이후의 데이터만 읽을 수 있다.
    * UnRepeatable Read : 데이터를 읽었는데 도중에 또 커밋이 일어나면 데이터의 불일치가 발생한다.
* **repeatable read :** 트랜잭션이 종료될 때까지 처음 조회한 데이터를 반복해서 조회한다.
    * Phantom Read : 데이터베이스는 로우 단위로 락을 걸기 때문에, 새로 추가되거나 삭제된 락에 대해서는 처리를 못한다.
* **serializable :** 트랜잭션이 종료될 때까지 다른 트랜잭션의 접근을 막는다.


