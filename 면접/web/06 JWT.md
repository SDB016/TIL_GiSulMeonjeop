# JWT 

JWT는 하나의 인터넷 표준 인증 방식으로 인증에 필요한 정보들을 Token에 담아 암호화시킨다.      
Cookie와 크겓 다르지는 않지만, 강조되는 점은 **서명된 토큰**이라는 것이다.     
              
공개/개인 키를 쌍으로 사용하여 서명할 경우             
개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 인증할 수 있다는 것이다.        
이러한 JWT의 구조 때문에 인증 정보를 담아 안전하게 인증을 시도하게끔 전달할 수 있는 것이다.      
  
**구성요소**  
* Header : 토큰 타입, 서명 생성 알고리즘 
* Payload : 실제 데이터 본문 
* Signature : 

## Header   

```json
{
  "typ": "JWT",
  "alg": "HS512"
}
```  
header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장한다.     

## Payload  

```json
{
  "sub": "1",
  "iss": "ori",
  "exp": 1636989718,
  "iat": 1636987918
}
```
playload 은 보통 Claim 이라는 사용자/토큰에 대한 프로퍼티를 Key-Value 형태로 저장한다.   
Claim이라는 말 그대로 토큰에서 사용할 정보의 조각을 의미한다.     
  
**JWT 표준 Claim 스펙**     *
1. iss(Issure): 토큰 발급자 
2. sub(Subject): 토큰 제목(사용자에 대한 식별값)    
3. aud(Audience): 토큰 대상자  
4. exp(Expiration Time): 토큰 만료 시간  
5. iat(Issued At): 토큰 발급 시간
6. nbf(Not Before): 토큰 활성 날짜(이 날짜 이전의 토큰은 활성화 되지 않음을 보장)   
7. jti(JWT id): JWT 토큰 식별자(Issure가 여럿일 경우 사용한다)   

JWT 표준 Claim 스펙은 단순히 스펙일 뿐이지 꼭 이 7가지만 사용해야하는 법은 없다.    
상황에 따라 사용하고 필요시 사용자가 커스텀하게 만들어 사용할 수 있다.    
        
**단, 중요한 것은 payload 에는 민감한 정보를 담지 않아야한다.**           
header와 payload의 경우 base64로 인코딩 되어있을 뿐이지 특별한 암호화가 걸려있는 것이 아니다.            
누구나 jwt를 가지고 있다면 base64 디코딩을 통해 header나 payload에 담긴 값을 알 수 있다.        
그렇기 때문에 JWT Payload는 단순히 **식별하기 위한 정보**만을 담아두는게 좋다.    
      
**그렇다면, Header와 Payload에도 암호화를 해야하지 않나? 🤔**         
* 아니다. 만약 그렇게 한다면 매 요청시마다 복호화하는 작업을 추가로 진행해야한다.        
* 그렇기 때문에 유출되었을 때 그렇게 큰 상관이 없는 비민감 정보를 토큰에 담는 것이 기본 스펙이다.  

## Signature
JWT에서 가장 중요한 요소인 서명이다.       

![다운로드](https://user-images.githubusercontent.com/50267433/146970625-188ee54e-b235-4bd8-8960-61cb5e25da22.png)
  
서명은 위와 같이 header를 디코딩한 값, payload를 디코딩한 값을 합치고      
이를 `your-256-bit-secret` 즉, 서버가 가지고 있는 개인키를 가지고 암호화되어있는 상태다.    
    
따라서 signature는 서버에 있는 개인키로만 암호화를 풀 수 있고           
**다른 클라이언트는 임의로 Signature를 복호화할 수 없다.**         
  
1. JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달한다.      
2. 서버가 가지고있는 개인키를 가지고 Signature를 복호화한다.     
3. base64UrlEncode(header)가 JWT의 heaer값과 일치한지 확인한다     
4. base64UrlEncode(payload)가 JWT의 payload값과 일치한지 확인한다.  
5. 모든 데이터가 일치할 경우 인증을 허용한다.        
   
여기서 중요한 점은 개인키를 통해 복호화를 하는 것뿐만 아니라 기존값을 비교한다는 것이다.   

* 동일한 Header/Payload라 할지라도 공개키/개인키 조합이 달라 복호화가 안된다.    
* 탈취해서 Header/Payload 값을 바꿀지라도 복화후 비교작업시 값이 달라 실패한다.    
  
# JWT 장점 
   
1. 이미 토큰 자체가 인증된 정보이기 때문에 세션 저장소와 같은 별도의 인증 저장소가 `필수적`으로 필요하지 않는다.
2. 세션과는 다르게 클라이언트의 상태를 서버가 저장해두지 않아도 된다.
3. signature를 공통키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보완성이 늘어난다.
4. 다른 서비스(웹/앱)에 이용할 수 있는 공통적인 스펙으로써 사용할 수 있다.

# JWT 단점(한계)  
   
1. 쿠키, 세션때와는 다르게 base64인코딩을 통한 정보를 전달하므로 전달량이 많다. 
   따라서 네트워크 전달 시 많은 데이터량으로 부하가 생길 수 있다.
2. Payload에는 암호화가 되어있지 않기 때문에 민감 정보를 저장할 수 없다.
3. **토큰이 탈취당하면 만료될 때까지 대처가 불가능하다**   
   
**해결 방법은? 🤔**     
JWT는 클라이언트가 관리하는 요소라 서버에서 크게 해결할 수 있는 요소가 없다.     
대신, exp 만료시간을 짧게 가져가는 방식으로 최소한의 보안성을 보장하게끔 한다.(30분~1시간)            
      
시간이 짧음으로서 유저들이 겪는 불편함이 증가할 수 있는데 이를 보안해줄 2가지가 기능이 있다.

1. Sliding Session 
2. Refresh Token 

## Sliding Session
특정 서비스를 사용하고 있는 유저에 대해 만료 시간을 연장 시켜주는 방법이다.       
`글쓰기`, `결제` 등과 같은 특정 action을 유저가 행동하였을 때           
새롭게 만료시간을 늘린 JWT를 다시 제공함으로써 만료시간을 연장하여 보완하는 방법이다.      
  
## Refresh Token

JWT를 처음 발급할 때, Access Token과 함께 **Refresh Token이라는 토큰을 발급하는 방법이다.**    
이름 그대로 Access Token을 Refresh해주는 것을 보장하는 토큰이며       
Refresh Token은 짧은 시간이 아닌 비교적 긴시간 (7일, 30일 등)의 만료시간을 가진다.    
   
클라이언트가 Access Token이 만료됨을 본인이 인지하거나, 서버로부터 만료됨을 확인받았다면      
Refresh Token으로 서버에게 새로운 Access Token을 발급하도록 요청하여 발급받는 방식이다.   

1. 클라이언트가 ID, PW로 서버에게 인증을 요청하고 서버는 이를 확인하여 Access Token과 Refresh Token을 발급한다.   
2. 클라이언트는 이를 받아 Refresh Token를 본인이 잘 저장하고 Access Token을 가지고 서버에 자유롭게 요청한다.    
3. 요청을 하던 도중 Access Token이 만료되어 더이상 사용할 수 없다는 오류를 서버로부터 전달 받는다.     
4. 클라이언트는 본인이 사용한 Access Token이 만료되었다는 사실을 인지하고     
   본인이 가지고 있던 Refresh Token를 서버로 전달하여 새로운 Access Token의 발급을 요청한다.     
5. 서버는 Refresh Token을 받아 서버의 Refresh Token Storage에 해당 토큰이 있는지 확인하고, 있다면 Access Token을 생성하여 전달한다.  
        
**Refresh Token Storage :** 서버에서 Refresh Token을 저장하는 저장소다.(주로 Redis)          
Refresh Token이 서버의 token 저장소에 있는지 확인 후 Access Token을 발급하는 형태이다.      

특정 Storage에 I/O작업이 발생하게 되면서 세션의 단점을 하나 가져가게 되면서    
반대로, 토큰이 탈취되었다고 판단되면 Refresh Token Storage를 초기화하여       
탈취된 토큰이 더 Refresh 못하도록 막는 등과 같은 부가 옵션이 생기기도한다.    
  
참고로 세션은 인증 요청시마다 I/O 작업을 하는 반면에       
리프레시 토큰은 갱신 요청때만 I/O 작업을 진행한다.        
더불어, 리프레시 토큰을 사용했다해서 Stateful 해지지는 않는다.   

# 참고 
* 봄공부님 블로그 : https://jinyoungchoi95.tistory.com/39  
* 조언 : RestAPI 서버는 Stateless해야한다.  
