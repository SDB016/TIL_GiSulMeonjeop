# Socket 
  
Socket이란, 두 개의 프로그램이 서로간의 실시간 통신을 지원하기 위해 등장한 기술이다.            
**통상적인 HTTP 통신은 클라이언트가 요청을 하면, 서버가 응답을 하는 구조의 단방향 통신이다.**         
반면에, 소켓 통신은 클라이언트와 서버가 서로 필요시에 데이터를 전송할 수 있다는 특징이 있다.       

**정리**
* Server와 Client가 특정 Port를 통해 계속 연결을 유지하는 양방향 프로그래밍 방식이다.
* Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
* 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.
   
소켓을 통해 네트워크 연결(Connection)이 되기 위해서는        
최초 어느 한 곳에서 그 대상이 되는 곳으로 연결을 요청해야 한다.  
이러한 관점에서 소켓을 구현하는 대표적인 방식 2가지가 있다.     
  
1. TCP/IP Socket 통신  
2. Http Socket 통신

# TCP/IP Socket 
## 클라이언트 소켓과 서버 소켓      
   
TCP/IP는 `IP 주소`와 `포트 번호`로 식별되는 대상에게,         
자신이 데이터 송수신을 위한 네트워크 연결을 요청하는 방식이다.    
           
* 클라이언트 소켓 : 요청을 하는 쪽 
* 서버 소켓 : 요청을 받는 쪽 
    
클라이언트 소켓과 서버 소켓이 별개의 소켓인 것처럼 느껴질 수 있는데, 사실 두 소켓은 동일하다.      
소켓의 역할과 구현 절차 구분을 위해 다르게 부르는 것이며        
**역할에 따라 처리되는 흐름, 즉, 호출되는 API 함수의 종류와 순서들이 다를 뿐이다.**    
  
더불어, 클라이언트 소켓과 서버 소켓이 직접 데이터를 주고 받는다고 생각할 수 있는데     
서버 소켓은 클라이언트 소켓의 연결 요청을 받아들이는 역할만 수행할 뿐,      
**직접적인 데이터 송수신은 서버 소켓의 연결 요청 수락의 결과로 만들어지는 새로운 소켓을 통해 처리된다.**      

## 소켓 API 실행흐름 
   
![995C23465C7DD7E30B](https://user-images.githubusercontent.com/50267433/148018483-aae99542-79f2-4bc3-8a18-9b3191ac926b.png)    

**클라이언트 소켓(Client Socket)**     
1. 소켓을 생성한다.     
2. 서버 측에 연결을 요청한다.    
3. 서버 소켓에서 연결이 받아들여지면 데이터를 송수신할 수 있다.        
4. 모든 처리가 완료되면 소켓을 닫는다.       
     
**서버 소켓(Server Socket)**       
1. 소켓을 생성한다.      
2. 서버가 사용할 IP 주소와 포트번호를 소켓에 결합시킨다.         
3. 클라이언트로부터 연결 요청이 수신되는지 주시(listen)한다.     
4. 요청이 수신되면 이를 받아들여 데이터 통신을 위한 소켓을 생성한다.   
5. 새로운 소켓을 통해 연결이 수립되면 데이터를 송수신 할 수 있다.     
6. 모든 데이터 송수신이 완료되면 소켓을 닫는다.    

## 클라이언트 소켓
### 1. 소켓을 생성한다.    
     
소켓 생성을 위해 가장 먼저 해야할 일로 소켓의 종류를 선택할 수 있다.      
  
* TCP : 스트림(Stream) 타입    
* UDP : 데이터그램(Datagram) 타입   
* 이외에도 family, raw 타입도 존재한다.     
  
최초의 소켓은 어떠한 "연결 대상"에 대한 정보도 들어 있지 않은 껍데기일 뿐인 소켓이다.        
연결 대상(IP:PORT)을 지정하고 연결 요청을 전달하기 위해서는, **소켓을 사용하여 connect() API를 호출해야 한다.**      
  
### 2. 서버 측에 연결을 요청한다.      

`connect() API`는 `IP주소`와 `포트 번호`로 식별되는 대상으로 연결 요청을 보낸다.           
  
* `connect()` API는 Blocking 방식으로 동작한다.            
* 즉, 연결 요청에 대한 결과(성공, 거절, 시간 초과 등)가 결정되기 전에는 실행이 끝나지 않는다.          
* 그러므로 connect() API가 실행되지마자 실행 결과와 관계없이 무조건 바로 리턴될 것이라 가정해선 안된다.      
  
`connect() API` 호출이 성공하면, 이제 `send() / recv API`를 통해 데이터를 주고 받을 수 있습니다.   

### 3. 서버 소켓에서 연결이 받아들여지면 데이터를 송수신할 수 있다.     

연결된 소켓을 통해 데이터를 보낼 때는 `send()`, 데이터를 받을 때는 `recv API`를 사용한다.    

* 한 가지 중요한 사실이 있는데 send()와 recv() API가 모두 Blocking 방식으로 동작한다.  
* 두 API 모두 실행 결과(성공, 실패, 종료)가 결정되기 전까지는 API가 리턴되지 않는다.  
* 특히, `recv()`는 데이터가 수신되거나,   
    에러가 발생하기 전에는 실행이 종료되지 않기 때문에    
    데이터 수신 작업을 생각만큼 단순하게 처리하기 쉽지 않다.     
  
`send()`의 경우 주체가 자기 자신이기 때문에 **얼마만큼의 데이터를 보낼 것인지**, **언제 보낼 것인지를 알 수 있다.**       
`recv()`의 경우, 통신 대상이 언제, 어떤 데이터를 보낼 것인지를 알 수 없기 때문에 언제 끝날지 모르는 상태가 된다.      
      
이를 해결하기 위해서 데이터 수신을 위한 recv() API는 별도의 스레드에서 실행한다.       
수신을 위한 쓰레드가 돌고, 나머지 전송을 하는 쓰레드를 따로 두어서       
수신을 위해 전송이 블락킹 되는 것을 막도록 하는 것이다.          
즉, 소켓의 생성과 연결이 완료된 후 새로운 스레드를 하나 만든 다음 그곳에서 `recv()`를 실행하고 데이터가 수신되길 기다린다.    

### 4. 모든 처리가 완료되면 소켓을 닫는다. 
   
더 이상 데이터 송수신이 필요없게되면, 소켓을 닫기 위해 `close() API`를 호출한다.         
close()에 의해 닫힌 소켓은 더 이상 유효한 소켓이 아니기 때문에, 해당 소켓을 사용하여 데이터를 송수신할 수 없다.     
만약, 소켓 연결이 종료된 후 다시 데이터를 주고 받아야 한다면 연결 과정을 다시 시행해야한다.     
   
## 서버 소켓 
### 1. 소켓을 생성한다.   
소켓 생성을 위해 가장 먼저 해야할 일로 소켓의 종류를 선택할 수 있다.

* TCP : 스트림(Stream) 타입
* UDP : 데이터그램(Datagram) 타입
* 이외에도 family, raw 타입도 존재한다.

최초의 소켓은 어떠한 "연결 대상"에 대한 정보도 들어 있지 않은 껍데기일 뿐인 소켓이다.          
  
### 2. 서버가 사용할 IP 주소와 포트번호를 소켓에 결합시킨다.          
  
컴퓨터에는 다수의 프로세스가 동작하고 이들은 각자만의 필요한 포트들을 사용하고 있다.         
**그런데 만약 소켓이 사용하는 포트 번호가 다른 프로세스의 포트 번호와 중복된다면 어떤 상황이 된다면? 🤔**       
    
운영체제에서는 소켓들이 중복된 포트 번호를 사용하지 않도록, 내부적으로 포트 번호와 소켓 연결 정보를 관리한다.       
이를 통해 `bind() API`는 해당 소켓이 지정된 포트 번호를 사용할 것이라는 것을 운영체제에 요청하는 API인 것이고       
만약 지정된 포트 번호를 다른 소켓이 사용하여 중복이 발생한다면, `bind() API`는 에러를 리턴한다.      
보통 소켓에 `bind() API`를 호출하는 것을 **소켓 바인드** 또는 **소켓 바인딩**이라고 부릅니다.       
(또 다른 관점으로 보자면, 서버 소켓은 포트를 하나 지정하고 이를 고정으로 계속 사용한다는 말이기도하다.)         

### 3. 클라이언트로부터 연결 요청이 수신되는지 주시(listen)한다.       
  
OS에게 포트를 알리고, 서버 소켓에 (IP 주소+포트 번호)를 결합하고 나면 클라이언트의 연결 요청을 수신 받을 수 있다.   
이제 할 일은 클라이언트에 의한 연결 요청이 수신될 때까지 기다리는 것인데, `listen API`가 그 역할을 수행한다.       
           
`listen() API`는 **서버 소켓에 바인딩된 포트 번호로 클라이언트의 연결 요청이 있는지 확인하며 대기 상태에 머무른다.**            
`connect() API`에 의해 연결 요청이 수신되는지 대기하고 있다가, 요청이 수신되면 그 때 대기 상태를 종료하고 리턴한다.    
   
**listen() API가 대기 상태에서 빠져나오는 경우는 크게 두 가지이다.**     
1. 클라이언트 요청이 수신되는 경우  
2. 에러가 발생(소켓 close() 포함)하는 경우  
     
그런데 listen() API가 성공한 경우라도, **리턴 값에 클라이언트의 요청에 대한 정보는 들어 있지 않다.**             
클라이언트 연결 요청이 수신되었는지(SUCCESS), 그렇지 않고 에러가 발생했는지(FAIL)의 정보만 들어있다.    
         
**대신 클라이언트 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐(Queue)에서 쌓이게 되는데,**              
이 시점에서 클라이언트와의 연결은 **아직 완전히 연결되지 않은(not ESTABLISHED state) 대기 상태이다.**              

### 4. 요청이 수신되면 이를 받아들여 데이터 통신을 위한 소켓을 생성한다.   
연결을 완료하기 위해서는 대기 중인 연결 요청을 큐(Queue)로부터 꺼내와서 `accept() API`를 호출해야 한다.  
  
그런데 주의할 점은 **최종적으로 데이터 통신을 위해 연결되는 소켓이,**              
**앞서 bind() 또는 listen() API에서 사용한 서버 소켓이 아니라는 것이다.**           
    
결론부터 말하자면, 최종적으로 클라이언트 소켓과 연결이 만들어지는 소켓은         
앞서 사용한 서버 소켓이 아니라, **accept API 내부에서 새로 만들어지는 소켓이다.**       
 
**정리**     
* 서버 소켓은 단순히 클라이언트 소켓의 연결 요청에 응답을 위한 소켓이다.     
* bind() 및 listen()을 통해 소켓에 포트 번호를 바인딩하고 요청 대기 큐를 생성하여 클라이언트의 요청을 대기한다.      
* `accept()` 를 실행하여 새로운 소켓이 생성하고, 요청 대기 큐의 맨 앞 요청을 꺼내서 소켓과 매핑시켜준다.       
* 서버 소켓은 다른 연결 요청을 처리하기 위해 다시 대기하거나, 서버 소켓을 닫는 역할을 한다.          
* 마찬가지로, 서버 소켓과 실제 사용 소켓은 별도의 쓰레드에서 동작할 것 같다.    
  
### 5. 새로운 소켓을 통해 연결이 수립되면 데이터를 송수신 할 수 있다.     
연결된 소켓을 통해 데이터를 보낼 때는 `send()`, 데이터를 받을 때는 `recv API`를 사용한다.    
  
* 한 가지 중요한 사실이 있는데 send()와 recv() API가 모두 Blocking 방식으로 동작한다.  
* 두 API 모두 실행 결과(성공, 실패, 종료)가 결정되기 전까지는 API가 리턴되지 않는다.  
* 특히, `recv()`는 데이터가 수신되거나,   
    에러가 발생하기 전에는 실행이 종료되지 않기 때문에    
    데이터 수신 작업을 생각만큼 단순하게 처리하기 쉽지 않다.     
  
`send()`의 경우 주체가 자기 자신이기 때문에 **얼마만큼의 데이터를 보낼 것인지**, **언제 보낼 것인지를 알 수 있다.**       
`recv()`의 경우, 통신 대상이 언제, 어떤 데이터를 보낼 것인지를 알 수 없기 때문에 언제 끝날지 모르는 상태가 된다.      
      
이를 해결하기 위해서 데이터 수신을 위한 recv() API는 별도의 스레드에서 실행한다.       
수신을 위한 쓰레드가 돌고, 나머지 전송을 하는 쓰레드를 따로 두어서       
수신을 위해 전송이 블락킹 되는 것을 막도록 하는 것이다.          
즉, 소켓의 생성과 연결이 완료된 후 새로운 스레드를 하나 만든 다음 그곳에서 `recv()`를 실행하고 데이터가 수신되길 기다린다.    

### 6. 모든 데이터 송수신이 완료되면 소켓을 닫는다.    
  
더 이상 데이터 송수신이 필요없게되면, 소켓을 닫기 위해 `close() API`를 호출한다.          
close()에 의해 닫힌 소켓은 더 이상 유효한 소켓이 아니기 때문에, 해당 소켓을 사용하여 데이터를 송수신할 수 없다.       
만약, 소켓 연결이 종료된 후 다시 데이터를 주고 받아야 한다면 연결 과정을 다시 시행해야한다.       
 
# Web Socket(HttpSocket) 

## STOMP - SubSocket 

# Socket 이전 실시간 통신 기술들 
# 고려해볼만한 것 
 
케이블 분리로 인한 네트워크 단절,     
트래픽 증가에 따른 데이터 전송 지연,     
시스템 리소스 관리 문제로 인한 에러 등,    
네트워크 환경에서 발생할 수 있는 다양한 예외사항에 대해서도 처리가 필요   
