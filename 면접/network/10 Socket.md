# Socket 
  
Socket이란, 두 개의 프로그램이 서로간의 실시간 통신을 지원하기 위해 등장한 기술이다.            
**통상적인 HTTP 통신은 클라이언트가 요청을 하면, 서버가 응답을 하는 구조의 단방향 통신이다.**         
반면에, 소켓 통신은 클라이언트와 서버가 서로 필요시에 데이터를 전송할 수 있다는 특징이 있다.       

**정리**
* Server와 Client가 특정 Port를 통해 계속 연결을 유지하는 양방향 프로그래밍 방식이다.
* Server와 Client가 실시간으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
* 실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.
   
소켓을 통해 네트워크 연결(Connection)이 되기 위해서는        
최초 어느 한 곳에서 그 대상이 되는 곳으로 연결을 요청해야 한다.  
이러한 관점에서 소켓을 구현하는 대표적인 방식 2가지가 있다.     
  
1. TCP/IP Socket 통신  
2. Http Socket 통신

# TCP/IP Socket 
## 클라이언트 소켓과 서버 소켓      
   
TCP/IP는 `IP 주소`와 `포트 번호`로 식별되는 대상에게,         
자신이 데이터 송수신을 위한 네트워크 연결을 요청하는 방식이다.    
           
* 클라이언트 소켓 : 요청을 하는 쪽 
* 서버 소켓 : 요청을 받는 쪽 
    
클라이언트 소켓과 서버 소켓이 별개의 소켓인 것처럼 느껴질 수 있는데, 사실 두 소켓은 동일하다.      
소켓의 역할과 구현 절차 구분을 위해 다르게 부르는 것이며        
**역할에 따라 처리되는 흐름, 즉, 호출되는 API 함수의 종류와 순서들이 다를 뿐이다.**    
  
더불어, 클라이언트 소켓과 서버 소켓이 직접 데이터를 주고 받는다고 생각할 수 있는데     
서버 소켓은 클라이언트 소켓의 연결 요청을 받아들이는 역할만 수행할 뿐,      
**직접적인 데이터 송수신은 서버 소켓의 연결 요청 수락의 결과로 만들어지는 새로운 소켓을 통해 처리된다.**      

## 소켓 API 실행흐름 
   
![995C23465C7DD7E30B](https://user-images.githubusercontent.com/50267433/148018483-aae99542-79f2-4bc3-8a18-9b3191ac926b.png)    

**클라이언트 소켓(Client Socket)**     
1. 소켓을 생성한다.     
2. 서버 측에 연결을 요청한다.    
3. 서버 소켓에서 연결이 받아들여지면 데이터를 송수신할 수 있다.        
4. 모든 처리가 완료되면 소켓을 닫는다.       
     
**서버 소켓(Server Socket)**       
1. 소켓을 생성한다.      
2. 서버가 사용할 IP 주소와 포트번호를 소켓에 결합시킨다.         
3. 클라이언트로부터 연결 요청이 수신되는지 주시(listen)한다.     
4. 요청이 수신되면 이를 받아들여 데이터 통신을 위한 소켓을 생성한다.   
5. 새로운 소켓을 통해 연결이 수립되면 데이터를 송수신 할 수 있다.     
6. 모든 데이터 송수신이 완료되면 소켓을 닫는다.    

## 클라이언트 소켓
### 1. 소켓을 생성한다.    
     
소켓 생성을 위해 가장 먼저 해야할 일로 소켓의 종류를 선택할 수 있다.      
  
* TCP : 스트림(Stream) 타입    
* UDP : 데이터그램(Datagram) 타입   
* 이외에도 family, raw 타입도 존재한다.     
  
최초의 소켓은 어떠한 "연결 대상"에 대한 정보도 들어 있지 않은 껍데기일 뿐인 소켓이다.        
연결 대상(IP:PORT)을 지정하고 연결 요청을 전달하기 위해서는, **소켓을 사용하여 connect() API를 호출해야 한다.**      
  
### 2. 서버 측에 연결을 요청한다.      

`connect() API`는 `IP주소`와 `포트 번호`로 식별되는 대상으로 연결 요청을 보낸다.           
  
* `connect()` API는 Blocking 방식으로 동작한다.            
* 즉, 연결 요청에 대한 결과(성공, 거절, 시간 초과 등)가 결정되기 전에는 실행이 끝나지 않는다.          
* 그러므로 connect() API가 실행되지마자 실행 결과와 관계없이 무조건 바로 리턴될 것이라 가정해선 안된다.      
  
`connect() API` 호출이 성공하면, 이제 `send() / recv API`를 통해 데이터를 주고 받을 수 있습니다.   

### 3. 서버 소켓에서 연결이 받아들여지면 데이터를 송수신할 수 있다.     

연결된 소켓을 통해 데이터를 보낼 때는 `send()`, 데이터를 받을 때는 `recv API`를 사용한다.    

* 한 가지 중요한 사실이 있는데 send()와 recv() API가 모두 Blocking 방식으로 동작한다.  
* 두 API 모두 실행 결과(성공, 실패, 종료)가 결정되기 전까지는 API가 리턴되지 않는다.  
* 특히, `recv()`는 데이터가 수신되거나,   
    에러가 발생하기 전에는 실행이 종료되지 않기 때문에    
    데이터 수신 작업을 생각만큼 단순하게 처리하기 쉽지 않다.     
  
`send()`의 경우 주체가 자기 자신이기 때문에 **얼마만큼의 데이터를 보낼 것인지**, **언제 보낼 것인지를 알 수 있다.**       
`recv()`의 경우, 통신 대상이 언제, 어떤 데이터를 보낼 것인지를 알 수 없기 때문에 언제 끝날지 모르는 상태가 된다.      
      
이를 해결하기 위해서 데이터 수신을 위한 recv() API는 별도의 스레드에서 실행한다.       
수신을 위한 쓰레드가 돌고, 나머지 전송을 하는 쓰레드를 따로 두어서       
수신을 위해 전송이 블락킹 되는 것을 막도록 하는 것이다.          
즉, 소켓의 생성과 연결이 완료된 후 새로운 스레드를 하나 만든 다음 그곳에서 `recv()`를 실행하고 데이터가 수신되길 기다린다.    

### 4. 모든 처리가 완료되면 소켓을 닫는다. 
   
더 이상 데이터 송수신이 필요없게되면, 소켓을 닫기 위해 `close() API`를 호출한다.         
close()에 의해 닫힌 소켓은 더 이상 유효한 소켓이 아니기 때문에, 해당 소켓을 사용하여 데이터를 송수신할 수 없다.     
만약, 소켓 연결이 종료된 후 다시 데이터를 주고 받아야 한다면 연결 과정을 다시 시행해야한다.     
   
## 서버 소켓 
### 1. 소켓을 생성한다.   
소켓 생성을 위해 가장 먼저 해야할 일로 소켓의 종류를 선택할 수 있다.

* TCP : 스트림(Stream) 타입
* UDP : 데이터그램(Datagram) 타입
* 이외에도 family, raw 타입도 존재한다.

최초의 소켓은 어떠한 "연결 대상"에 대한 정보도 들어 있지 않은 껍데기일 뿐인 소켓이다.          
  
### 2. 서버가 사용할 IP 주소와 포트번호를 소켓에 결합시킨다.          
  
컴퓨터에는 다수의 프로세스가 동작하고 이들은 각자만의 필요한 포트들을 사용하고 있다.         
**그런데 만약 소켓이 사용하는 포트 번호가 다른 프로세스의 포트 번호와 중복된다면 어떤 상황이 된다면? 🤔**       
    
운영체제에서는 소켓들이 중복된 포트 번호를 사용하지 않도록, 내부적으로 포트 번호와 소켓 연결 정보를 관리한다.       
이를 통해 `bind() API`는 해당 소켓이 지정된 포트 번호를 사용할 것이라는 것을 운영체제에 요청하는 API인 것이고       
만약 지정된 포트 번호를 다른 소켓이 사용하여 중복이 발생한다면, `bind() API`는 에러를 리턴한다.      
보통 소켓에 `bind() API`를 호출하는 것을 **소켓 바인드** 또는 **소켓 바인딩**이라고 부릅니다.       
(또 다른 관점으로 보자면, 서버 소켓은 포트를 하나 지정하고 이를 고정으로 계속 사용한다는 말이기도하다.)         

### 3. 클라이언트로부터 연결 요청이 수신되는지 주시(listen)한다.       
  
OS에게 포트를 알리고, 서버 소켓에 (IP 주소+포트 번호)를 결합하고 나면 클라이언트의 연결 요청을 수신 받을 수 있다.   
이제 할 일은 클라이언트에 의한 연결 요청이 수신될 때까지 기다리는 것인데, `listen API`가 그 역할을 수행한다.       
           
`listen() API`는 **서버 소켓에 바인딩된 포트 번호로 클라이언트의 연결 요청이 있는지 확인하며 대기 상태에 머무른다.**            
`connect() API`에 의해 연결 요청이 수신되는지 대기하고 있다가, 요청이 수신되면 그 때 대기 상태를 종료하고 리턴한다.    
   
**listen() API가 대기 상태에서 빠져나오는 경우는 크게 두 가지이다.**     
1. 클라이언트 요청이 수신되는 경우  
2. 에러가 발생(소켓 close() 포함)하는 경우  
     
그런데 listen() API가 성공한 경우라도, **리턴 값에 클라이언트의 요청에 대한 정보는 들어 있지 않다.**             
클라이언트 연결 요청이 수신되었는지(SUCCESS), 그렇지 않고 에러가 발생했는지(FAIL)의 정보만 들어있다.    
         
**대신 클라이언트 연결 요청에 대한 정보는 시스템 내부적으로 관리되는 큐(Queue)에서 쌓이게 되는데,**              
이 시점에서 클라이언트와의 연결은 **아직 완전히 연결되지 않은(not ESTABLISHED state) 대기 상태이다.**              

### 4. 요청이 수신되면 이를 받아들여 데이터 통신을 위한 소켓을 생성한다.   
연결을 완료하기 위해서는 대기 중인 연결 요청을 큐(Queue)로부터 꺼내와서 `accept() API`를 호출해야 한다.  
  
그런데 주의할 점은 **최종적으로 데이터 통신을 위해 연결되는 소켓이,**              
**앞서 bind() 또는 listen() API에서 사용한 서버 소켓이 아니라는 것이다.**           
    
결론부터 말하자면, 최종적으로 클라이언트 소켓과 연결이 만들어지는 소켓은         
앞서 사용한 서버 소켓이 아니라, **accept API 내부에서 새로 만들어지는 소켓이다.**       
 
**정리**     
* 서버 소켓은 단순히 클라이언트 소켓의 연결 요청에 응답을 위한 소켓이다.     
* bind() 및 listen()을 통해 소켓에 포트 번호를 바인딩하고 요청 대기 큐를 생성하여 클라이언트의 요청을 대기한다.      
* `accept()` 를 실행하여 새로운 소켓이 생성하고, 요청 대기 큐의 맨 앞 요청을 꺼내서 소켓과 매핑시켜준다.       
* 서버 소켓은 다른 연결 요청을 처리하기 위해 다시 대기하거나, 서버 소켓을 닫는 역할을 한다.          
* 마찬가지로, 서버 소켓과 실제 사용 소켓은 별도의 쓰레드에서 동작할 것 같다.    
  
### 5. 새로운 소켓을 통해 연결이 수립되면 데이터를 송수신 할 수 있다.     
연결된 소켓을 통해 데이터를 보낼 때는 `send()`, 데이터를 받을 때는 `recv API`를 사용한다.    
  
* 한 가지 중요한 사실이 있는데 send()와 recv() API가 모두 Blocking 방식으로 동작한다.  
* 두 API 모두 실행 결과(성공, 실패, 종료)가 결정되기 전까지는 API가 리턴되지 않는다.  
* 특히, `recv()`는 데이터가 수신되거나,   
    에러가 발생하기 전에는 실행이 종료되지 않기 때문에    
    데이터 수신 작업을 생각만큼 단순하게 처리하기 쉽지 않다.     
  
`send()`의 경우 주체가 자기 자신이기 때문에 **얼마만큼의 데이터를 보낼 것인지**, **언제 보낼 것인지를 알 수 있다.**       
`recv()`의 경우, 통신 대상이 언제, 어떤 데이터를 보낼 것인지를 알 수 없기 때문에 언제 끝날지 모르는 상태가 된다.      
      
이를 해결하기 위해서 데이터 수신을 위한 recv() API는 별도의 스레드에서 실행한다.       
수신을 위한 쓰레드가 돌고, 나머지 전송을 하는 쓰레드를 따로 두어서       
수신을 위해 전송이 블락킹 되는 것을 막도록 하는 것이다.          
즉, 소켓의 생성과 연결이 완료된 후 새로운 스레드를 하나 만든 다음 그곳에서 `recv()`를 실행하고 데이터가 수신되길 기다린다.    

### 6. 모든 데이터 송수신이 완료되면 소켓을 닫는다.    
    
더 이상 데이터 송수신이 필요없게되면, 소켓을 닫기 위해 `close() API`를 호출한다.(서버 소켓, accept 생성 소켓)          
close()에 의해 닫힌 소켓은 더 이상 유효한 소켓이 아니기 때문에, 해당 소켓을 사용하여 데이터를 송수신할 수 없다.       
만약, 소켓 연결이 종료된 후 다시 데이터를 주고 받아야 한다면 연결 과정을 다시 시행해야한다.       
 
# Web Socket(HttpSocket) 
       
웹소켓은 TCP/IP 소켓과 다르게 애플리케이션 레이어에서 소켓을 연결하는 방식을 사용한다.       
Http와 Https를 이용하여 연결을 확립시킨 후 ws 와 wss라는 웹소켓의 독자적인 프로토콜을 이용해서 살사건 양방향 통신을 지원한다.          
   
기존 TCP/IP 소켓은 물론, Polling, Long Polling 에서의 IP, PORT를 이용한다는점은 비슷하지만   
ws와 wss라는 웹소켓의 독자적인 프로토콜을 이용해서 살사건 양방향 통신을 지원하고    
**ws와 wss는 기존 http 메시지보다 header가 작아 overhead가 적다는 특징이 있다.**       

**웹소켓이 필요한 경우**   
1. 실시간 양방향 데이터 통신이 필요한 경우    
2. 많은 수의 동시 접속자를 수용해야하는 경우   
3. 브라우저에서 TCP 기반의 통신으로 확장해야 하는 경우 
4. 개발자에게 사용하기 쉬운 API가 필요한 경우 
5. 클라우드 환경이나 웹을 넘어 SOA로 확장해야하는 경우  

**웹의 실시간 양방향 통신을 위해 등장한 기술이라고 생각하면 된다.**      
HTML5를 기반으로 나왔으며, 이전 버전과의 호환을 위해 `socket.io`와 같은 라이브러리를 지원한다.     

**정리하자면**   
* 최초 연결시 Http/Https를 통해서 핸드쉐이킹한다.   
* 웹소켓 별도 포트는 없으며, 기존 http(80)/https(443)의 포트를 사용한다.  
* 프레임으로 구성된 메시지라는 논리적 단위로 송수신한다.   
* 메시지에 포함될 수 있는 교환 가능한 메시지는 텍스트와 바이너리 타입이다.     

## Web Socket HandShake 및 실행 흐름 
      
최초 연결은 HTTP와 HTTPS 를 이용한 WebSocket HandShake 과정을 통해 이루어진다.         
주의할 사항으로 반드시 GET 메서드를 활용하며 HTTP 버전은 1.1 이상이어야한다.      

![unnamed](https://user-images.githubusercontent.com/50267433/148031319-7c7a4702-ae91-47a7-befe-2006e7087ec8.jpeg)
  
**WebSocket HandShake**     
1. 클라이언트는 서버에게 HTTP/HTTPS를 이용해 연결 요청을 보낸다.   
    * ```http
      GET /chat HTTP/1.1
      Host: example.com:8000
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
      Sec-WebSocket-Protocol: chat, superchat 
      Sec-WebSocket-Version: 13
      ```
    * Upgrade 헤더 : 클라이언트와 서버 전송 프로토콜 연결에서 다른 프로토콜로 업그레이드 위한 헤더  
    * Conncetion 헤더 : Upgrade 헤더가 명시되어있으면 이를 적용하기 위해 반드시 지정해야할 헤더 
    * Sec-WebSocket-Key 헤더 : 클라이언트와 서버간의 신원 인증을 위한 헤더(16바이트 난수 값을 base64로 인코딩)
    * Sec-WebSocket-Protocol 헤더 : 
        * 클라이언트가 요청하는 여러 서브프로토콜을 의미한다. 
        * 공백 문자로 구분되며 순서에 따라 우선권이 부여된다.  
        * 서버에서 여러 프로토콜 혹은 프로토콜 버전을 나눠서 서비스할 경우 필요한 헤더다.
        * stomp 도 이러한 서브 프로토콜이다.   
    * Sec-WebSocket-Version 헤더 : 버전 정보 
2. 서버는 클라이언트의 요청을 받고 응답을 해준다.     
    * ```http
      HTTP/1.1 101 Switching Protocols
      Upgrade: websocket
      Connection: Upgrade
      Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
      ```
    * 101 응답을 통해 프로토콜이 바뀌었음을 알린다.  
    * Upgrade 헤더 : 클라이언트와 서버 전송 프로토콜 연결에서 다른 프로토콜로 업그레이드 위한 헤더 
    * Conncetion 헤더 : Upgrade 헤더가 명시되어있으면 이를 적용하기 위해 반드시 지정해야할 헤더 
    * Sec-WebSocket-Accept 헤더 : 
        * Sec-WebSocket-Key 헤더를 계산하여 만든 값
        * 클라이언트와 서버간의 신원 인증을 위한 헤더(base64로 인코딩)    
        * 이후, 클라이언트가 보낸 Sec-WebSocket-Key가 일치하지 않으면 연결하지 않는다.   
3. ws 또는 wss 프로토콜을 이용해 데이터를 주고받는다.  
    * 메시지 단위를 통해 데이터를 주고받는다.   
    * 메시지 : 여러 프레임들이 모여서 구성된 하나의 논리적인 메시지 단위  
    * 프레임 : 커뮤니케이션에서 가장 작은 단위(작은 헤더 + Payload로 구성)     
    * 웹소켓에서 사용되는 데이터 : UTF8 인코딩(0x00, 0xff 등등)
        * END 비트 : 해당 프레임이 메시지의 끝인지 알려주는 비트 
        * Opcode 비트 : 해당 프레임이 어떻게 사용될지 부연 설명 
            * Continue(0x0): 전체 메시지의 일부임을 말해줌(END와 연관) 
            * Text(0x1): 포함된 데이터가 UTF-8 텍스트라는 의미 
            * Binary(0x2): 포함된 데이터가 이진 데이터라는 의미       
            * Close(0x8): 클로즈 핸드쉐이크를 한다는 의미 
        * length 비트 : 헤딩 프레임에 포함된 데이터의 총 길이를 나타내는 단위 
4. 더 이상 보낼 데이터가 없다면 close 프레임을 통해 연결을 종료한다.  

## WebSocket 한계 

### Socket.io 및 SocketJS
웹 소켓은 HTML5를 기반으로 등장한 기술이다.      
그렇기 때문에 이전 버전과의 호환이 문제가 될 수 있다.  
  
**Socket.io 및 SocketJS**    
* HTML5 이전에 구현된 서비스에서 웹소켓처럼 사용할 수 있도록 지원해주는 라이브러리이다.  
* 즉, 브라우저와 웹 서버의 종류와 버전을 파악하여 가장 적합한 기술을 선택하도록 해준다.  
        
### STOMP - SubSocket 
WebSocket은 문자열들을 주고 받을 수 있게 해주는 역할만 수행한다.          
즉, 주고 받은 문자열의 해독은 오롯이 애플리케이션에 맡긴다.      
HTTP는 형식을 지정해두었기에 모두가 약속을 따르기만하면 해석이 가능하다.       
하지만 WebSocket은 형식이 정해져있지 않아서 애플리케이션에서 해석이 힘들다.    
때문에 WebSocket은 SubSocket을 사용해서 주고받는 메시지의 형태를 약속한다.  

**STOMP**  
* STOMP는 채팅 통신을 하기 위한 형식을 정의한다.    
* HTTP와 유사하게 간단히 정의되어 해석하기 편한 프로토콜이다.    
* 일반적으로 웹 소켓 위에서 사용된다.  

**STOMP 프레임 구조**  
* ```
  COMMAND
  header1:value1
  header1:value1
  
  bodybodybodybody^@
  ``` 
* 프레임 기반의 프로토콜이다.(명령, 헤더, 바디로 구성)  
* 자주 사용되는 명령은 아래와 같다.  
    * CONNECT
    * SEND
    * SUBSCRIBE
    * DISCONNECT
* 헤더와 바디는 빈 라인으로 구분하며, 바디의 끝 부분은 NULL문자로 설정한다.  

# Socket 이전 실시간 통신 기술들  
# 고려해볼만한 것 
 
케이블 분리로 인한 네트워크 단절,     
트래픽 증가에 따른 데이터 전송 지연,     
시스템 리소스 관리 문제로 인한 에러 등,    
네트워크 환경에서 발생할 수 있는 다양한 예외사항에 대해서도 처리가 필요   

# 참고  
* https://codesk.tistory.com/57  
