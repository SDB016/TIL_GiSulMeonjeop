# 네트워크 통신 흐름  
## 인터넷 
  
전세계에 걸쳐 파일 전송등의 데이터 통신 서비스를 받을 수 있는 **컴퓨터 네트워크의 시스템**         
참고로, 프로토콜은 네트워크 통신을 위해 미리 정해 놓은 공통된 메뉴얼을 의미한다.    

## TCP/IP 계층
TCP/IP란, 인터넷에서 컴퓨터들이 서로 정보를 주고받는데 쓰이는 **프로토콜의 집합** 
  
**Application Layer** 
* 특정 서비스를 제공하기 위해 애플리케이션끼리 정보를 주고 받는 것   
* 애플리케이션끼리 어떤 데이터를 교환할지 정하는 것 
* FTP, HTTP, SSH, TELNET, DNS, SMTP 

**Transport Layer**    
* 송신된 데이터를 수신측 애플리케이션에 확실히 전달하게 한다.     
* 네트워크 통신을 하는 애플리케이션은 포트번호를 사용하는데,  
   Transport Layer는 포트번호를 사용해서 애플리케이션을 찾아주는 역할을 한다.   
* TCP, UDP, RTP, RTCP  

**Internet Layer**
* 수신 측까지 데이터를 전달하기 위해 사용된다.  
* IP, ARP, ICMP, RARP, OSPF 

**Network Access Layer**    
* 네트워크에 직접 연결된 기기 간의 데이터 전송을 돕는다.    
* Ethernet, PPP, Token Ring

## TCP/IP 흐름  

면접 질문 : www.google.com을 입력하면 무슨일이 일어날까?        
     
* 구글 웹 서버의 80 포트로 HttpRequest 메시지를 보낸다는 뜻이다.    
* 해당 요청을 인터넷에 전달하기 위해 우리는 패킷을 만든다.    
* 패킷에는 각 계층에 필요한 정보들이 담겨야 한다.    

### Application Layer
  
* HTTP Request가 들어간다.     
  
### Transport Layer   

![header-600x336](https://user-images.githubusercontent.com/50267433/146664001-8ebbb357-db86-46a2-9f84-77be0a71a48e.jpeg)

* TCP/UDP 와 같은 전송 프로토콜을 결정한다.    

### Internet Layer   

![IPv4_header](https://user-images.githubusercontent.com/50267433/146664080-f788ca9c-ea5c-4a22-95a4-e44aea6c1ad9.jpeg)

* IP Header 를 설정하는데, SA와 DA를 설정한다.    
    * SA : 시작 IP 주소(내 IP 주소)    
    * DA : 목적지 IP 주소    
* DA를 구하기 위해서 DNS를 통해 IP주소를 검색하는 작업을 진행한다.       

```
브라우저는 OS에게  domain 에 대한 ip 주소를 알고 싶다고 요청을 한다.      
(os는 DNS 어떻게알지? - DNS 서버 주소는 이미 컴퓨터에 등록되어 있음)       
  
DNS 프로토콜 또한, Applicaion Layer의 프로토콜인데 53번 포트를 사용한다.          
DNS 도 HTTP Request와 비슷하게 도메인이 담긴 쿼리를 도메인 서버로 보낸다.         
그러면 도메인 서버가 IP주소를 응답해준다.    
    
DNS는 TransportLayer에서 UDP라는 프로토콜을 사용한다.     
UDP는 TCP와 다르게 헤더가 간단하다(위에서 보면 알 수 있듯이)          
DNS를 통해 성공적으로 도메인에 대한 IP 주소를 받아왔다.     
``` 

### Network Access Layer 
    
Ethternet 프로토콜에 대한 헤더를 만들어야 하는데 아직 Mac주소를 모른다.        
참고로 여기서 필요한 Mac 주소는, 실제 우리집 컴퓨터와 물리적으로 연결된 공유기를 말하는 것이다.         
목적지는 IP를 통해 찾아갈 수 있으며, 송신측은 공유기를 통해 다른 네트워크에 전송되니까 공유기 Mac이 필요한 것이다.       

우리는 이미 게이트웨이 IP를 알고 있다.     
그렇기 때문에 IP주소를 MAC 주소로 변환해주는 ARP 프로토콜을 이용하여 Mac 주소를 찾으면 된다.   
     

## TCP 3 Way HandShake 
    
1. 클라이언트는 서버에게 접속을 요청하는 SYN 패킷을 보낸다.     
2. 서버는 SYN 요청을 받고, 요청을 수락한다는 ACK 와 SYN 플래그가 설정된 패킷을 보낸다.      
3. 클라이언트는 서버에게 다시 ACK 을 보낸다.       

이제부터 연결이 이루어지고 데이터가 오가게 된다.     

## 이제 전송해보자   
이제 3-way-handshaking으로 연결이 성립되었으니 데이터가 보내질 차례다.   
참고로, 내가 사용하는 컴퓨터는 private ip를 사용한다.    
private ip는 외부의 네트워크 환경에서 IP주소를 찾지 못하게 하기위해 설계된 것이다.   

하지만, 실제 데이터를 보내려면 이 private ip를 실제 public ip로 보내서 전송해야한다.      
그래서 공유기(게이트웨이)를 통해서 나갈때, private ip를 public ip 주소로 변환해서 나가는 작업을 하는데  
이 같은 작업이 바로 NAT(Network Address Translation)이다.    
  
이후, 우리집 공유기를 걸쳐 구글 서버에 도착하기 위해 여러 라우터를 거쳐야한다.       
라우터는 네트워크와 네트워크를 연결해주는 역할을 하는데, 이러한 라우터들을 여럿 거쳐가야한다.        
참고로, 라우터가 목적지 경로를 찾아 나가는 과정을 라우팅이라고 한다.     
 
라우팅을 거쳐 구글 서버가 연결된 라우터까지 데이터가 도착을 한다면       
패킷의 IP 헤더에 기록된 구글 서버 IP 주소를 통해 MAC 주소를 얻어와야한다.     
이때, 이전에 설명했던 ARP 기능을 한번 더 사용한다.(이전에는 나의 공유기의 IP -> MAC이였고, 이번엔 DNS로 찾은 IP -> MAC)     
   
이때, ARP는 라우터가 연결된 네트워크에 브로드 캐스팅이된다.(연결된 노드들에 너 IP 맞냐고 다 보낸다)        
이제 해당하는 노드는 자신의 MAC 주소를 응답해준다.     
이제 목적지 구글 서버의 MAC주소를 알았으니 데이터가 물리적으로 전달될 수 있다.     

## 도착후   
ARP로 IP주소를 통해 MAC주소를 얻고 드디어 목적지 구글 서버에 도착하게 되었다.   
Internet Layer의 IP주소와 Network Access Layer의 Mac 주소를 사용해서 올바른 목적지에 잘 도착했으니   
이후 Layer에 대해서 어떻게 동작하는지 알아보자   

Transport 목적지 포트 번호에는 80 포트가 적혀있다.   
이것을 보고 80번 포트를 사용하는 애플리케이션에게 데이터를 전달해줘야하는 것을 알 수 있다.     
Application Layer까지오면, 웹 서버가 사용될 HTTP Request 데이터를 얻을 수 있다.       

## 응답  
이제 서버에서 HTTP Request를 받고 응답을 돌려보내줘야 한다.       
`/`에 매핑된 URL 요청에 따라 적절한 로직으 수행하고 그 결과값을 돌려준다.   

## 4 WAY HAND SHAKE  
HTTP 요청과 응답과정이 끝나면 연결을 종료해야한다.      
이 과정에서도 TCP 컨트롤 비트가 사용되는데 ACK과 FIN 플래스를 사용한다.     
  
1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 플래그를 전송한다.     
2. 서버는 클라이언트에게 ACK 메시지를 보내고 자신의 남은 통신이 끝날때까지 기다린다.   
3. 서버가 통신이 끝나면 클라이언트로 FIN을 보낸다.     
4. 클라이언트는 확인했다는 의미로 서버에게 ACK을 보내면 연결이 종료가 완료된다.   

그런데 서버가 클라이언트에게 FIN을 보내는 과정에서, 한가지 문제가 발생할 수 있다.     
서버가 클라이언트에게 응답하는 데이터가 FIN보다 늦게 도착할 경우,        
클라이언트가 FIN을 받았다고 소켓을 닫아버리면 응답 받던 데이터를 더이상 못받게 된다.     
   
그래서 클라이언트는 서버로부터 FIN요청을 받더라도 일정시간동안, 소켓을 닫지않고 혹시나 아직 도착하지 않은 잉여 패킷을 기다린다.         
이렇게 4 way handshaking 과정이 완료되어도 소켓을 닫지않고 잉여 패킷을 기다리는 상태를 TIME_WAIT 이라 부른다.    
   
