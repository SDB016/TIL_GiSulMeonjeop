# 📚 들어가면서    

데이터를 전송할 때 아래와 같은 문제가 발생할 수 있다.  

1. 잘못된 수신지  
2. 네트워크 에러 
3. 패킷 손상 
     
이처럼 여러 이유들로 인하여 데이터가 목적지로 도착하지 못하는 경우가 있다.             
그리고 이들은 TCP/IP에서 네트워크 액세스 영역에서 해결해 줄 수 없는 부분이기도 하다.           
(전송중인 데이터가 손상되거나 분실되면 아무런 후속 작업을 해줄 수 없다)       
      
이러한 문제를 해결하기 위해, **데이터에 전송/수신 관련 패킷을 붙이고 관리하는 전송계층영역이 등장했다.**         
       
# 📕 전송 계층       
      
전송 계층은 **두 시스템 간에 신뢰성 있는 데이터를 전송하기 위해 존재한다.**          
**즉, 오류를 식별하는 기능을 통해 데이터 전송 실패 및 오류 발생시 재전송을 할 수 있다.**                   
더불어, **포트 통해 데이터를 알맞는 Application 으로 전달해주기도 한다.**       
 
1. 흐름제어  
2. 혼잡제어 
3. 오류제어 


## 흐름제어 
> 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법   
    
**TCP Buffer**   
* 송신자 : 버퍼에 세그먼트를 보관하고 이후 순차적으로 전송한다.     
* 수신자 : 응용프로그램이 세그먼트를 읽을때까지 버퍼에 저장한다.    
     
**TCP Window Size**        
* Window Size == 수신 TCP Buffer 크기      
* 송신측에서 보내는 데이터가 버퍼를 넘지 않도록 사이즈를 조절하는 것이다.       
    * 송신측은 ACK를 수신하기 전까지 윈도우 크기 만큼의 세그먼트를 연속해서 전송할 수 있다.       
    * 송신측이 ACK를 수신하면 다시 보낼 수 있는 세그먼트의 수 만큼 윈도우 사이즈를 조절한다.     
    * 윈도우 크기가 0이되면, 더이상 전송을 하지 못하고 ACK를 받을 때까지 대기한다.         

**재전송**   
* TCP는 ACK를 수신하지 못할 경우 무한정 기다리는 것을 피하기 위해    
  일정시간이 지나면(time_out) 재전송을 한다.    
* 단, 버퍼가 차서 못보내는 것이라면 상황을 더 악화시키는 것이기도 하다.  
             
**수신측의 버퍼크기를 어떻게 전송하고 있는 것일까? 🤔**         
* 수신 TCP는 현재의 남아있는 버퍼 크기를 **ACK로 전송할 때 window size 필드릁 통해서 알려준다.**        
      
## 혼잡제어   
> 망에 입력되는 트래픽 양이 망이 처리할 수 있는 한도를 초과할 경우 체증이 발생한다.    

* 패킷망에서는 트래픽의 흐름은 일정하지 않다.(회선망과의 차이점)           
* 망의 트래픽 처리 용량을 최대 트래픽 전송율보다 크게 유지할 수 있으면 체증을 피할 수 있다.   
* Congestion(혼잡)은 패킷망에서 해결해야 할 가장 중요한 과제이자 가장 어려운 과정 중 하나이다.         

입력되는 패킷의 수가 많아질 수록 처리해야할 양이 많아지는 것은 당연하며,      
패킷의 수가 증가할수록 딜레이가 되는 비율은 기하급수적으로 증가되는 형태를 보인다.    
   
이러한 혼잡 제어를 해결하기 위해서는 2가지 제어 방식이 존재한다.   

1. 예벙적 체증 제어   
2. 반응적 체증 제어   

## 예방적 체증제어 


## 반응적 체증제어  


* 느린 출발
* 혼잡 회피
* 손실 복구
* Fast Retransmission
* Fast Recovery 
    
## 오류제어 

* 시퀀스넘버 기반
* ACK로 수신 확인
* 오류 발생 시 CRC이용, 송신측에 프레임 재전송 요청
    
## 📖 포트번호    
포트는 **TCP가 상위 계층으로 데이터를 전송하거나 상위 계층에서 TCP로 데이터를 전송할 때 상호간에 사용하는 데이터의 이동 통로를 말한다.**        
즉, 데이터를 전송할 때는, 수신 측의 IP 주소가 필요하지만, **어떤 애플리케이션이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요하다.**    
`TCP/IP 4Layer`에서는 상위 계층 프로토콜과 하위 계층 프로토콜이 같은 포트를 사용한다는 특징도 있다.   

# 📗 TCP
TCP는 **연결지향형 프로토콜로 신뢰성 있는 바이트 스트림 서비스를 제공한다.**       
  
* **연결 지향 :** 응용 프로그램이 데이터를 교환하기 전에 서로 TCP 연결을 확립해야한다.(양방향-이중)            
* **신뢰성 :** 데이터를 성공적으로 수신했거나 오류가 발생했음을 알려주는 것       
      
**상호간에 네트워크 연결 합의하에 데이터를 보내고 성공적으로 수신할 때까지 재전송한다.**          
  
## 📖 TCP 헤더      
       
![header-600x336](https://user-images.githubusercontent.com/50267433/146669497-6c2a79bd-7be8-4438-b78b-c1c49c584362.jpeg)   
         
TCP 헤더에는 데이터를 보조해주는 다양한 정보들이 있다.                 
특히 **발신지 포트**, **목적지 포트**, **코드 비트**가 중요한 요소들이다.        
        
|코드 비트|설명|      
|--------|----|  
|URG|긴급하게 처리할 데이터가 들어 있음|   
|URG|응답 확인 번호 사용|    
|PSH|TCP가 받은 데이터를 상위 계층에 전달|    
|RST|연결 재설정|    
|SYN|연결을 초기화하려고 순서 번호 동기화|     
|FIN|데이터 송신 종료|        
  

## 📖 TCP 3-way Handshake    
  
TCP 전송 프로토콜을 사용한다면, 실제 데이터를 전송하기 전에 노드간에 연결이 확립 되어있어야한다.      
즉, **정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정**이 필요한데 이것이 TCP 3-way Handshake 이다.  

1. 클라이언트는 서버에게 접속을 요청하는 SYN 패킷을 보낸다.
2. 서버는 SYN 요청을 받고, 요청을 수락한다는 ACK 와 SYN 플래그가 설정된 패킷을 보낸다.
3. 클라이언트는 서버에게 다시 ACK 을 보낸다.

    
## 📖 TCP 4-way Handshake    
TCP 4-Way handshake는 두 시스템(컴퓨터)간에 연결된 세션을 종료하기 위해 수행되는 절차이다.               
      
1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 클라이언트에게 ACK 메시지를 보내고 자신의 남은 통신이 끝날때까지 기다린다.
3. 서버가 통신이 끝나면 클라이언트로 FIN을 보낸다.
4. 클라이언트는 확인했다는 의미로 서버에게 ACK을 보내면 연결이 종료가 완료된다.
     
**TIME_OUT**    
* 서버가 클라이언트에게 FIN을 보냈는데 기존에 보내줘야할 데이터가 FIN보다 늦게 도착할 수도 있다는 문제가 있다.           
* 아무런 조치를 취하지 않는다면 클라이언트는 FIN을 받아 소켓을 닫아버릴거고 더이상 데이터를 받을 수 없을 것이다.         
* 이를 해결하기 위해 클라이언틑 **TIME_OUT** 을 두어 일정시간 동안 서버로부터 아직 받지 못한 데이터를 받는다.       
   
# 📘 UDP
UDP는 **비연결 지향형 프로토콜로 패킷이나 흐름제어, 단편화 및 전송보장등의 기능을 제공하지 않는다**             
`출발 포트`, `목적지 포트`, `메시지`를 제외한 부가적인 데이터가 없기 때문에 TCP 보다 가볍고    
노드간 연결 작업도 하지 않기에 데이터 전송이 비교적 빠르고 실시간 데이터 전송에 많이 사용된다.(스트리밍 서비스, 계속 데이터를 전송)   
    
UDP를 사용하는 대표적인 응용 계층 프로토콜은 DNS, DHCP, SNMP 등이 있다.       
    
## UDP 헤더 
                
![header-600x336 복사본 2](https://user-images.githubusercontent.com/50267433/146669915-e01a0ce4-f068-4a8f-ba19-c6e0b64268da.jpeg)   

UDP 헤더는 **출발/목적지 포트 및 메시지와 응답 메시지로 구성되며 주로 적은 양의 데이터 전송에 사용된다.**        
그리고, 부가적인 정보가 없으므로 개발자가 어느정도 커스텀하게 사용할 수 있다.      
   
# UDP가 신뢰성이 없는 이유 

1. TCP와 달리 노드간에 연결을하지 않고 데이터를 보낸다.(대신, 그래서 빠름)      
2. TCP와 달리 UDP는 송신 순서와 수신 순서가 같지 않다.    
3. TCP와 달리 `오류제어`와 `흐름제어`가 거의 없다.          
     
그렇기에 UDP는 실시간 멀티미디어 정보를 처리할 때 좋고, 패킷 소실이 있어도 다음 패킷을 수신하는 실시간 처리에 적합하다.         
