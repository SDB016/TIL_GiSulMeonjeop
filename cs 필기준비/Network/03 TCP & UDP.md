# 📚 들어가면서    

데이터를 전송할 때 아래와 같은 문제가 발생할 수 있다.  

1. 잘못된 수신지  
2. 네트워크 에러 
3. 패킷 손상 
     
이처럼 여러 이유들로 인하여 데이터가 목적지로 도착하지 못하는 경우가 있다.             
그리고 이들은 TCP/IP에서 네트워크 액세스 영역에서 해결해 줄 수 없는 부분이기도 하다.           
(전송중인 데이터가 손상되거나 분실되면 아무런 후속 작업을 해줄 수 없다)       
      
이러한 문제를 해결하기 위해, **데이터에 전송/수신 관련 패킷을 붙이고 관리하는 전송계층영역이 등장했다.**         
       
# 📕 전송 계층       
      
전송 계층은 **두 시스템 간에 신뢰성 있는 데이터를 전송하기 위해 존재한다.**          
**즉, 오류를 식별하는 기능을 통해 데이터 전송 실패 및 오류 발생시 재전송을 할 수 있다.**                   
더불어, **포트 통해 데이터를 알맞는 Application 으로 전달해주기도 한다.**       
 
1. 흐름제어  
2. 혼잡제어 
3. 오류제어 

## 흐름제어 
> 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법   
    
**TCP Buffer**   
* 송신자 : 버퍼에 세그먼트를 보관하고 이후 순차적으로 전송한다.     
* 수신자 : 응용프로그램이 세그먼트를 읽을때까지 버퍼에 저장한다.    
     
**TCP Window Size**        
* Window Size == 수신 TCP Buffer 크기      
* 송신측에서 보내는 데이터가 버퍼를 넘지 않도록 사이즈를 조절하는 것이다.       
    * 송신측은 ACK를 수신하기 전까지 윈도우 크기 만큼의 세그먼트를 연속해서 전송할 수 있다.       
    * 송신측이 ACK를 수신하면 다시 보낼 수 있는 세그먼트의 수 만큼 윈도우 사이즈를 조절한다.     
    * 윈도우 크기가 0이되면, 더이상 전송을 하지 못하고 ACK를 받을 때까지 대기한다.         

**재전송**   
* TCP는 ACK를 수신하지 못할 경우 무한정 기다리는 것을 피하기 위해    
  일정시간이 지나면(time_out) 재전송을 한다.    
* 단, 버퍼가 차서 못보내는 것이라면 상황을 더 악화시키는 것이기도 하다.  
             
**수신측의 버퍼크기를 어떻게 전송하고 있는 것일까? 🤔**         
* 수신 TCP는 현재의 남아있는 버퍼 크기를 **ACK로 전송할 때 window size 필드를 통해서 알려준다.**        
      
## 혼잡제어   
> 망에 입력되는 트래픽 양이 망이 처리할 수 있는 한도를 초과할 경우 체증이 발생한다.    

* 패킷망에서는 트래픽의 흐름은 일정하지 않다.(회선망과의 차이점)           
* 망의 트래픽 처리 용량을 최대 트래픽 전송율보다 크게 유지할 수 있으면 체증을 피할 수 있다.   
* Congestion(혼잡)은 패킷망에서 해결해야 할 가장 중요한 과제이자 가장 어려운 과정 중 하나이다.         

입력되는 패킷의 수가 많아질 수록 처리해야할 양이 많아지는 것은 당연하며,      
패킷의 수가 증가할수록 딜레이가 되는 비율은 기하급수적으로 증가되는 형태를 보인다.    
   
이러한 혼잡 제어를 해결하기 위해서는 2가지 제어 방식이 존재한다.   

1. 예벙적 체증 제어 
2. 반응적 체증 제어   

**예방적 체증제어** 
* 사전에 망에 입력되는 트래픽양을 조절하는 기법이다.     
* 2단계로 이루어진다.      
    1. 망사용자와 사용자가 계약하여, 사전에 전송할 데이터양을 정한다(call admission control)  
    2. 망사업자는 사용자가 사전에 약속된 내용을 준수하는지 감시한다.(policing)   
* 라우터에 패킷을 전송할 때, 사전에 약속된 계약에 따라 패킷의 전송 순위를 결정한다.(priority control)     
      
**반응적 체증제어**           
* 체증현상이 발생할 때 트래픽양을 감소시킨다.(줄이라고 통보)            
* 패킷의 지연시간(증가되는지), 라우터의 버퍼 길이 등을 계속 측정하면서 혼잡 상태를 초기에 발견한다.             
* 반응적 체증 제어를 수행하기에 적합한 계층은 사실 네트워크 계층이며 라우터가 적당하다.(모니터링 및 전송량이므로)         
* 하지만, 인터넷 프로토콜에서는 체증 제어의 임무를 TCP가 수행하도록 하고 있다.   

### TCP의 혼잡제어   
  
**혼잡 발견(Congestion Detection)**      
* TCP는 송신한 패킷에 대해서 ACK를 수신한다.  
* 만약 정해진 시간(time_out)이 지날 때까지 ACK이 도착하지 않으면 Congestion이 발생한 것으로 판단한다. 
* 흐름제어와 유사한데, 사실 혼잡제어와 흐름제어를 별개로 볼게 아니라 흐름제어를 기본으로 진행한다고 이해하자     

**혼잡 제어(Congestion Control) 2가지 대응**        
* Slow Start : 
    * TCP 호스트(송신측)은 처음에는 적은 양의 패킷을 전송하고 점차 양을 늘려나간다.       
    * Congestion 발생과 time out과 상관없이 모든 TCP 호스트(송신측)는 Slow Start로 패킷을 보낸다.      
* Congestion Avodiance : 
    * Congestion 발생으로 판단되면(time_out), 전송되는 패킷의 양을 초기 상태로 줄여서 다시 시작한다.   
   
**Congestion Control의 2개의 Window**     

* Awnd(advertised window)   
    * 초기 연결 설정 단계에서, TCP는 상대 TCP에게 자신의 최대 버퍼크기(초기 Awnd)를 알려준다.        
    * 세그먼트를 수신할 때마다 TCP는 현재 자신의 버퍼 중 비어있는 공간의 크기(Awnd)를 알려준다.      
    * 이것은 TCP 흐름제어에서도 언급하는 window size이다.     
* Cwnd(congestion window)     
    * TCP가 세그먼트를 전송할 때 ACK을 받지않고 연속해서 보낼 수 있는 세그먼트의 양을 결정한다.         
    * 즉, TCP 흐름제어에 의하면 Tcp는 Awnd 만큼 연속해서 세그먼트를 전송할 수 있다.          
    * 하지만 **Congestion Control에 의해서 Awnd만큼 전송할 수 없고 Cwnd만큼 전송하게 된다.**         

### Slow Start 

![image](https://user-images.githubusercontent.com/50267433/146672173-78624a16-f07a-4cd3-9f86-bfab612dccc7.png)

```
Cwnd = Cwnd + 1 until min(Cwnd, Awnd)  
```

처음에는 1을 보내고, ACK을 받으면 Cwnd를 1 늘리고 개수를 증가시키고 다시 전송한다.        
즉, 1씩 계속 증가하다가 그 혼잡이 탐지되면 다시 그 값을 줄이고 보내는 작업을 반복한다.(증가률 다시)       

### Congestion Avoidance 

* TCP는 timeout 될때까지 ACK를 받지 못하면 
  congestion이 발생한 것으로 판단하고, congestion avoidance를 수행한다.  
* 즉, 전송률을 감소시킨다.   

**Congestion Avoidance algorithm**
1. timeout이 발생할때 까지, Cwnd를 1씩 증가하면서 데이터를 전송한다.  
2. timeout이 발생하면, Awnd 의 1/2 만큼의 위체에 threshold를 설정하고 cwnd를 1로 맞춘다.   
3. Cwnd가 threshold 까지 증가하다가 이를 넘어가버리면 다시 1씩 증가된다.(증가률 다시 봐야할듯) 

![image](https://user-images.githubusercontent.com/50267433/146672387-6064991d-0b83-4748-9271-40ce043a95c1.png)


### Fast Retransmit 와 Fast Recovery   
  
**동일한 ACK를 3개 받을 경우**     
* 동일한 ACK가 계속 도착한다는 것은 Congestion 으로 판단하지만,  
  그렇더라도 상태가 심각하지 않다고 해석할 수 있다.   
* 그래서 Congestion Avoidance 보다는 좀더 적극적으로 전송한다.    
  
**Fast Retransmit**     
* time out 되기전에 바로 재전송한다.   

**Fast Recovery**   
* Cwnd를 현재의 Cwnd의 반으로 줄인다.     
* 그리고 줄인 Cwnd에서부터 Linear 하게 증가시킨다.   
 
![image](https://user-images.githubusercontent.com/50267433/146672505-6f3aaa88-99db-4060-9cec-a87a2e58a0db.png)
   
![image](https://user-images.githubusercontent.com/50267433/146672517-7c8e2a44-fa5f-4973-b9ac-e7665ce83d1c.png)
   
    
## 오류제어 

https://www.youtube.com/watch?v=FxDRd71xfpw&ab_channel=%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99   
 
* 시퀀스넘버 기반
* ACK로 수신 확인
* 오류 발생 시 CRC이용, 송신측에 프레임 재전송 요청
    
## 📖 포트번호    
포트는 **TCP가 상위 계층으로 데이터를 전송하거나 상위 계층에서 TCP로 데이터를 전송할 때 상호간에 사용하는 데이터의 이동 통로를 말한다.**        
즉, 데이터를 전송할 때는, 수신 측의 IP 주소가 필요하지만, **어떤 애플리케이션이 사용되고 있는지 구분하려면 TCP는 포트 번호가 필요하다.**    
`TCP/IP 4Layer`에서는 상위 계층 프로토콜과 하위 계층 프로토콜이 같은 포트를 사용한다는 특징도 있다.   

# 📗 TCP
TCP는 **연결지향형 프로토콜로 신뢰성 있는 바이트 스트림 서비스를 제공한다.**       
  
* **연결 지향 :** 응용 프로그램이 데이터를 교환하기 전에 서로 TCP 연결을 확립해야한다.(양방향-이중)            
* **신뢰성 :** 데이터를 성공적으로 수신했거나 오류가 발생했음을 알려주는 것       
      
**상호간에 네트워크 연결 합의하에 데이터를 보내고 성공적으로 수신할 때까지 재전송한다.**          
  
## 📖 TCP 헤더      
       
![header-600x336](https://user-images.githubusercontent.com/50267433/146669497-6c2a79bd-7be8-4438-b78b-c1c49c584362.jpeg)   
         
TCP 헤더에는 데이터를 보조해주는 다양한 정보들이 있다.                 
특히 **발신지 포트**, **목적지 포트**, **코드 비트**가 중요한 요소들이다.        
        
|코드 비트|설명|      
|--------|----|  
|URG|긴급하게 처리할 데이터가 들어 있음|   
|URG|응답 확인 번호 사용|    
|PSH|TCP가 받은 데이터를 상위 계층에 전달|    
|RST|연결 재설정|    
|SYN|연결을 초기화하려고 순서 번호 동기화|     
|FIN|데이터 송신 종료|        
  

## 📖 TCP 3-way Handshake    
  
TCP 전송 프로토콜을 사용한다면, 실제 데이터를 전송하기 전에 노드간에 연결이 확립 되어있어야한다.      
즉, **정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정**이 필요한데 이것이 TCP 3-way Handshake 이다.  

1. 클라이언트는 서버에게 접속을 요청하는 SYN 패킷을 보낸다.
2. 서버는 SYN 요청을 받고, 요청을 수락한다는 ACK 와 SYN 플래그가 설정된 패킷을 보낸다.
3. 클라이언트는 서버에게 다시 ACK 을 보낸다.

    
## 📖 TCP 4-way Handshake    
TCP 4-Way handshake는 두 시스템(컴퓨터)간에 연결된 세션을 종료하기 위해 수행되는 절차이다.               
      
1. 클라이언트가 서버로 연결을 종료하겠다는 FIN 플래그를 전송한다.
2. 서버는 클라이언트에게 ACK 메시지를 보내고 자신의 남은 통신이 끝날때까지 기다린다.
3. 서버가 통신이 끝나면 클라이언트로 FIN을 보낸다.
4. 클라이언트는 확인했다는 의미로 서버에게 ACK을 보내면 연결이 종료가 완료된다.
     
**TIME_OUT**    
* 서버가 클라이언트에게 FIN을 보냈는데 기존에 보내줘야할 데이터가 FIN보다 늦게 도착할 수도 있다는 문제가 있다.           
* 아무런 조치를 취하지 않는다면 클라이언트는 FIN을 받아 소켓을 닫아버릴거고 더이상 데이터를 받을 수 없을 것이다.         
* 이를 해결하기 위해 클라이언틑 **TIME_OUT** 을 두어 일정시간 동안 서버로부터 아직 받지 못한 데이터를 받는다.       
   
# 📘 UDP
UDP는 **비연결 지향형 프로토콜로 패킷이나 흐름제어, 단편화 및 전송보장등의 기능을 제공하지 않는다**             
`출발 포트`, `목적지 포트`, `메시지`를 제외한 부가적인 데이터가 없기 때문에 TCP 보다 가볍고    
노드간 연결 작업도 하지 않기에 데이터 전송이 비교적 빠르고 실시간 데이터 전송에 많이 사용된다.(스트리밍 서비스, 계속 데이터를 전송)   
    
UDP를 사용하는 대표적인 응용 계층 프로토콜은 DNS, DHCP, SNMP 등이 있다.       
    
## UDP 헤더 
                
![header-600x336 복사본 2](https://user-images.githubusercontent.com/50267433/146669915-e01a0ce4-f068-4a8f-ba19-c6e0b64268da.jpeg)   

UDP 헤더는 **출발/목적지 포트 및 메시지와 응답 메시지로 구성되며 주로 적은 양의 데이터 전송에 사용된다.**        
그리고, 부가적인 정보가 없으므로 개발자가 어느정도 커스텀하게 사용할 수 있다.      
   
# UDP가 신뢰성이 없는 이유 

1. TCP와 달리 노드간에 연결을하지 않고 데이터를 보낸다.(대신, 그래서 빠름)      
2. TCP와 달리 UDP는 송신 순서와 수신 순서가 같지 않다.    
3. TCP와 달리 `오류제어`와 `흐름제어`가 거의 없다.          
     
그렇기에 UDP는 실시간 멀티미디어 정보를 처리할 때 좋고, 패킷 소실이 있어도 다음 패킷을 수신하는 실시간 처리에 적합하다.         
