# 개요 

```
START 라인
헤더 

본문
```

# STRAT LINE 

# HTTP Header 

## 구조
```  
field-name : field-value      
// field-name 은 대소문자 구분이 없다.(field-value는 있다.)   
```
 
* HTTP 전송에 필요한 모든 부가정보를 나타낸다.(바디 내용, 바디 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 정보)         
* 표준 헤더들도 존재하는데 그 수가 상당하며 필요시 임의의 헤더를 추가할 수 있다.        


## 분류

1. General 헤더 : 
    * 메시지 전체에 적용되는 정보 (Connection: Close)   
2. Request 헤더 : 
    * 요청 정보 (User-Agent: Mozilla/5.0)  
3. Response 헤더 : 
    * 응답 정보 (Server:Apache)
4. Representation 헤더(엔티티 헤더) : 
    * 기존에는 Entity 헤더라는 명칭이었으나, 2014년 표준에 의해 이름이 변경되었다.   
    * **Representation(엔티티 바디)의 정보(Content-Type:text/html, Conent-Length:3423)**   

# HTTP BODY

![image](https://user-images.githubusercontent.com/50267433/146711357-b58d4075-dad2-451e-af0b-3d622007a2cc.png)

* 메시지 본문을 통해 표현 데이터를 전달한다.      
* 메시지 본문 == 페이로드(payload)       
* Representation은 요청이나 응답에서 전달할 실제 데이터다.(2014년 표준 이전에는 Entity로 명칭)        
* Representation Header는 Representation 데이터를 해설할 수 있는 정보를 제공한다.    
* 참고 : 표현 헤더는 표현 메타 데이터와, 페이로드 메시지를 구분해야 하지만, 복잡해서 이를 생략한다.   
  
# 표현(Representation)  
> 요청/응답시 바디 데이터에 대한 메타 정보    
    
* Content-Type : 표현 데이터의 형식      
* Content-Encoding : 표현 데이터의 압축 방식       
* Content-Language : 표현 데이터의 자연 언어      
* Content-Length : 표현 데이터의 길이(파싱 종료 기준)     
     
참고로 표현 헤더는 요청,응답 둘다 사용가능하다.      

# 협상(컨텐츠 네고시에이션)   
> 클라이언트가 선호하는 표현 요청   
  
* Accept : 클라이언트가 선호하는 미디어 타입 전달 
* Accept-Charset : 클라이언트가 선호하는 문자 인코딩 
* Accept-Encoding : 클라이언트가 선호하는 압축 인코딩  
* Accept-Language : 클라이언트가 선호하는 자연 언어  

참고로, 협상 헤더는 요청시에만 사용가능하다.  

**협상이라는 이름에 걸맞게 요청하는 데이터가 없다면 우선순위에 따라 데이터를 응답해준다.**   
1. 우선 순위를 지정하는 방법 
    * `Accept-Langauge:ko-KR,ko;q=0.9,en-US:q=0.8` 
    * 0~1(소수점), 클수록 높은 우선 순위이다. 생략하면 1   
2. 구체적인 것을 우선시 하는 방법
    * `Accept: text/*, text/plain, text/plain;format=flowed, */*`
    * text/plain;format=flowed -> text/plain -> text/* -> */* 순이다.     
3 요청하는 값이 아에 없으면 서버는 기본값을 보낸다.    
  
# 전송 방식 

* 단순 전송 : Content-Length  
* 압축 전송 : Content-Encoding
* 분할 전송 : Transfer-Encoding: chunked(분할해서 데이터 전송), Content-Length 안됨(분할범위 예상 안되서) 
* 범위 전송 : Content-Range: bytes 1001-2000 / 2000

# 일반 정보 

* From: 유저 에이전트의 이메일 정보   
* Referer : 이전 웹 페이지 주소 (자주 사용, `referer: 이전 url`)     
* User-Agent : 유저 에이전트 애플리케이션 정보(클라이언트 웹 브라우저 정보, 특정 브라우저 버그 파악, 통계등)         
* Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보     
* Date : 메시지가 발생한 날짜와 시간     

# 특별한 정보   
  
* Host : 요청한 호스트 정보(도메인), **요청에서 필수값(동일 IP의 여러 도메인 존재하므로 명확한 도메인이름 선정)**      
* Location : 페이지 리다이렉션   
* Allow : 허용 가능한 HTTP 메서드    
* Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간    

# 인증 
 
* Authorization : 클라언트 인증 정보를 서버에 전달    
* WWW-AUthenticate : 리소스 접근시 필요한 인증 방법 정의(인증실패시 알려줄 정보들)  

# 쿠키 

* set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)     
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달   

웹 클라이언트에서 로그인을하고 welcome 페이지에 접근을 했다고 가정하자     
서버 내 이름을 불러줄 것을 희망했지만, 그러지 않았다.   

사실 HTTP는 Stateless 하다.   
 
* HTTP는 무상태 프로토콜이다.        
* 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.      
* 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.    
* 클라이언트와 서버는 서로 상태를 유지하지 않는다.    

대안으로, 모든 요청에 사용자 정보를 포함할 수 있지만 보안등등의 문제가 발생한다.     
이러한 문제를 해결하기 위해서 쿠키를 도입했다. 
   
1. 서버는 특정 작업 처리시 쿠키에 key/value 형태를 저장하고 이를 클라이언트에 보낸다.    
2. 클라이언트는 요청시마다 항상 쿠키를 같이 보내서, 서버에서 쿠키에 맞는 value값을 사용하도록 한다.    
3. 쿠키는 클라이언트에 저장되기 때문에 보안 문제가 있다.

**보안 헤더**   
* Secure를 적용하면 Https의 경우에만 쿠키를 전송한다.     
* HttpOnly를 적용하면, XSS 공격 방지하고, jS에서 접근을 막고, HTTP 전송에만 사용된다.      
* SameSite를 적용하면, CSRF 공격을 방지하며, 요청 도메인과 설정된 도메인이 같은 경우만 쿠키를 전송한다.  

  
### 참고 
쿠키 세션 토큰 차이   
  
https://tofusand-dev.tistory.com/89   
 
# HTTP CACHE 
## 캐시 기본 동작 

**캐시가 없다면**   
* 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다.     
* 인터넷 네트워크는 매우 느리고 비싸다.    
* 브라우저 로딩 속도가 느리다.    
* 느린 사용자 경험을 제공한다.  
  
**캐시 동작**      
* 최초 요청시 캐시 시간(cache-control: max-age=60)과 데이터를 넘겨주면,   
  웹 브라우저 내부 캐시 저장소에 저장한다.       
* HTTP 메시지 요청시 캐시 저장소를 먼저 찾고 있으면 해당 데이터를 이용한다.     

**캐시 적용**   
* 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.    
* 비싼 네트워크 사용량을 줄일 수 있다.     
* 브라우저 로딩 속도가 매우 빠르다.        
* 빠른 사용자 경험을 제공해준다.    
   
그런데 만약, 캐시 시간이 초과된다면?        
* 서버로부터 데이터를 다시 요청하고, 갱신된 데이터를 캐시 저장소에 저장한다.     
* 그런데, 캐시 시간이 초과되었다 가정해도 데이터가 변경되지 않았으면 과연 다시 요청을해야할까?  

## 검증 헤더와 조건부 요청1  

### 캐시 시간 초과   
    
* 캐시 만료후에도 서버에서 데이터를 변경하지 않음        
* 생각해보면, 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다.      
* 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.    

#### 검증헤더 추가  
   
* 마지막 수정된 시간 : `Last-Modified: 2020년 11월 10일 10:00:00`
* 이 데이터를 캐시 저장소에 같이 저장한다.       
* 캐시 시간이 초과되면, `if-modified-since: 2020년 11월 10일 10:00:00`를 요청으로 보낸다.    
* 최종 수정일이 같으면 데이터를 받지않고(body만 빼고), 최종 수정일이 다르면 데이터를 받고 캐시 저장소를 갱신한다.  
  
즉, 검증헤더(last)와 조건부 요청 헤더(if)를 같이 사용한다.       

* 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면       
* 304 Not Modified + 헤더 메타 정보만 응답한다.(바디x)            
* 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신한다.   
* 클라이언트는 캐시에 저장되어 있는 데이터를 재활용하면 된다.   
* 결과적으로 네트워크 다운로드가 발생하지만, 용량이 적은 헤더 정보만 다운로드된다.   
* 매우 실용적인 해결책이다.   

## 검증 헤더와 조건부 요청2 ETAG  

**검증헤더**   
* 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터  
* Last-Modified, Etag 

**조건부 요청 헤더**  
* 검증 헤더로 조건에 따른 분기     
* if-Modified-Since: Last-Modified 사용    
* if-None-Match: Etag 사용   
* 조건이 만족하면 200 OK  
* 조건이 만족하지 않으면 304 Not Modified  

