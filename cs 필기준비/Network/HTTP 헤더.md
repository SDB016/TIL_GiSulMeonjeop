# 개요 

```
START 라인
헤더 

본문
```

# STRAT LINE 

# HTTP Header 

## 구조
```  
field-name : field-value      
// field-name 은 대소문자 구분이 없다.(field-value는 있다.)   
```
 
* HTTP 전송에 필요한 모든 부가정보를 나타낸다.(바디 내용, 바디 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 정보)         
* 표준 헤더들도 존재하는데 그 수가 상당하며 필요시 임의의 헤더를 추가할 수 있다.        


## 분류

1. General 헤더 : 
    * 메시지 전체에 적용되는 정보 (Connection: Close)   
2. Request 헤더 : 
    * 요청 정보 (User-Agent: Mozilla/5.0)  
3. Response 헤더 : 
    * 응답 정보 (Server:Apache)
4. Representation 헤더(엔티티 헤더) : 
    * 기존에는 Entity 헤더라는 명칭이었으나, 2014년 표준에 의해 이름이 변경되었다.   
    * **Representation(엔티티 바디)의 정보(Content-Type:text/html, Conent-Length:3423)**   

# HTTP BODY

![image](https://user-images.githubusercontent.com/50267433/146711357-b58d4075-dad2-451e-af0b-3d622007a2cc.png)

* 메시지 본문을 통해 표현 데이터를 전달한다.      
* 메시지 본문 == 페이로드(payload)       
* Representation은 요청이나 응답에서 전달할 실제 데이터다.(2014년 표준 이전에는 Entity로 명칭)        
* Representation Header는 Representation 데이터를 해설할 수 있는 정보를 제공한다.    
* 참고 : 표현 헤더는 표현 메타 데이터와, 페이로드 메시지를 구분해야 하지만, 복잡해서 이를 생략한다.   
  
# 표현(Representation)  
> 요청/응답시 바디 데이터에 대한 메타 정보    
    
* Content-Type : 표현 데이터의 형식      
* Content-Encoding : 표현 데이터의 압축 방식       
* Content-Language : 표현 데이터의 자연 언어      
* Content-Length : 표현 데이터의 길이(파싱 종료 기준)     
     
참고로 표현 헤더는 요청,응답 둘다 사용가능하다.      

# 협상(컨텐츠 네고시에이션)   
> 클라이언트가 선호하는 표현 요청   
  
* Accept : 클라이언트가 선호하는 미디어 타입 전달 
* Accept-Charset : 클라이언트가 선호하는 문자 인코딩 
* Accept-Encoding : 클라이언트가 선호하는 압축 인코딩  
* Accept-Language : 클라이언트가 선호하는 자연 언어  

참고로, 협상 헤더는 요청시에만 사용가능하다.  

**협상이라는 이름에 걸맞게 요청하는 데이터가 없다면 우선순위에 따라 데이터를 응답해준다.**   
1. 우선 순위를 지정하는 방법 
    * `Accept-Langauge:ko-KR,ko;q=0.9,en-US:q=0.8` 
    * 0~1(소수점), 클수록 높은 우선 순위이다. 생략하면 1   
2. 구체적인 것을 우선시 하는 방법
    * `Accept: text/*, text/plain, text/plain;format=flowed, */*`
    * text/plain;format=flowed -> text/plain -> text/* -> */* 순이다.     
3 요청하는 값이 아에 없으면 서버는 기본값을 보낸다.    
  
# 전송 방식 

* 단순 전송 : Content-Length  
* 압축 전송 : Content-Encoding
* 분할 전송 : Transfer-Encoding: chunked(분할해서 데이터 전송), Content-Length 안됨(분할범위 예상 안되서) 
* 범위 전송 : Content-Range: bytes 1001-2000 / 2000

# 일반 정보 

* From: 유저 에이전트의 이메일 정보   
* Referer : 이전 웹 페이지 주소 (자주 사용, `referer: 이전 url`)     
* User-Agent : 유저 에이전트 애플리케이션 정보(클라이언트 웹 브라우저 정보, 특정 브라우저 버그 파악, 통계등)         
* Server : 요청을 처리하는 오리진 서버의 소프트웨어 정보     
* Date : 메시지가 발생한 날짜와 시간     

# 특별한 정보   
  
* Host : 요청한 호스트 정보(도메인), **요청에서 필수값(동일 IP의 여러 도메인 존재하므로 명확한 도메인이름 선정)**      
* Location : 페이지 리다이렉션   
* Allow : 허용 가능한 HTTP 메서드    
* Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간    

# 인증 
 
* Authorization : 클라언트 인증 정보를 서버에 전달    
* WWW-AUthenticate : 리소스 접근시 필요한 인증 방법 정의(인증실패시 알려줄 정보들)  

# 쿠키 

* set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)     
* Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달   

웹 클라이언트에서 로그인을하고 welcome 페이지에 접근을 했다고 가정하자     
서버 내 이름을 불러줄 것을 희망했지만, 그러지 않았다.   

사실 HTTP는 Stateless 하다.   
 
* HTTP는 무상태 프로토콜이다.        
* 클라이언트와 서버가 요청과 응답을 주고 받으면 연결이 끊어진다.      
* 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.    
* 클라이언트와 서버는 서로 상태를 유지하지 않는다.    

대안으로, 모든 요청에 사용자 정보를 포함할 수 있지만 보안등등의 문제가 발생한다.     
이러한 문제를 해결하기 위해서 쿠키를 도입했다. 
   
1. 서버는 특정 작업 처리시 쿠키에 key/value 형태를 저장하고 이를 클라이언트에 보낸다.    
2. 클라이언트는 요청시마다 항상 쿠키를 같이 보내서, 서버에서 쿠키에 맞는 value값을 사용하도록 한다.    
3. 쿠키는 클라이언트에 저장되기 때문에 보안 문제가 있다.

**보안 헤더**   
* Secure를 적용하면 Https의 경우에만 쿠키를 전송한다.     
* HttpOnly를 적용하면, XSS 공격 방지하고, jS에서 접근을 막고, HTTP 전송에만 사용된다.      
* SameSite를 적용하면, CSRF 공격을 방지하며, 요청 도메인과 설정된 도메인이 같은 경우만 쿠키를 전송한다.  

  
### 참고 
쿠키 세션 토큰 차이   
  
https://tofusand-dev.tistory.com/89   
 
# HTTP CACHE 
## 캐시 기본 동작 

**캐시가 없다면**   
* 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다.     
* 인터넷 네트워크는 매우 느리고 비싸다.    
* 브라우저 로딩 속도가 느리다.    
* 느린 사용자 경험을 제공한다.  
  
**캐시 동작**      
* 최초 요청시 캐시 시간(cache-control: max-age=60)과 데이터를 넘겨주면,   
  웹 브라우저 내부 캐시 저장소에 저장한다.       
* HTTP 메시지 요청시 캐시 저장소를 먼저 찾고 있으면 해당 데이터를 이용한다.     

**캐시 적용**   
* 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.    
* 비싼 네트워크 사용량을 줄일 수 있다.     
* 브라우저 로딩 속도가 매우 빠르다.        
* 빠른 사용자 경험을 제공해준다.    
   
그런데 만약, 캐시 시간이 초과된다면?        
* 서버로부터 데이터를 다시 요청하고, 갱신된 데이터를 캐시 저장소에 저장한다.     
* 그런데, 캐시 시간이 초과되었다 가정해도 데이터가 변경되지 않았으면 과연 다시 요청을해야할까?  

## 검증 헤더와 조건부 요청1  

### 캐시 시간 초과   
    
* 캐시 만료후에도 서버에서 데이터를 변경하지 않음        
* 생각해보면, 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다.      
* 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.    

#### 검증헤더 추가  
   
* 마지막 수정된 시간 : `Last-Modified: 2020년 11월 10일 10:00:00`
* 이 데이터를 캐시 저장소에 같이 저장한다.       
* 캐시 시간이 초과되면, `if-modified-since: 2020년 11월 10일 10:00:00`를 요청으로 보낸다.    
* 최종 수정일이 같으면 데이터를 받지않고(body만 빼고), 최종 수정일이 다르면 데이터를 받고 캐시 저장소를 갱신한다.  
  
즉, 검증헤더(last)와 조건부 요청 헤더(if)를 같이 사용한다.       

* 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면       
* 304 Not Modified + 헤더 메타 정보만 응답한다.(바디x)            
* 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신한다.   
* 클라이언트는 캐시에 저장되어 있는 데이터를 재활용하면 된다.   
* 결과적으로 네트워크 다운로드가 발생하지만, 용량이 적은 헤더 정보만 다운로드된다.   
* 매우 실용적인 해결책이다.   

## 검증 헤더와 조건부 요청2 ETAG  

**검증헤더**   
* 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터  
* Last-Modified, Etag 

**조건부 요청 헤더**  
* 검증 헤더로 조건에 따른 분기     
* if-Modified-Since: Last-Modified 사용    
    * 데이터 미변경시(시간 같으면) -> 헤더 데이터만 받는다. + 304   
    * 데이터 변경시(시간 다르면) -> 바디 데이터도 받는다. + 200
* if-None-Match: Etag 사용    
* 조건이 만족하면 200 OK  
* 조건이 만족하지 않으면 304 Not Modified  

### Last-Modified + if-Modified-Since 단점 

* 1초 미만 단위로 캐시 조정이 불가능하다.(초단위이다.)     
* 날짜 기반의 로직 사용 
* 같은 데이터를 수정해서 데이터 결과가 똑같은 경우(데이터를 수정해서 날짜가 달라지긴 함)      
* 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 
    * 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우 

## ETag    
**ETag**    
* 캐시용 데이터에 임의의 고유한 버전 이름을 달아둘 수 있다.   
    * `ETag v1.0` 또는 `ETag: a2jiodwjekjl3`  
* 데이터가 변경되면 이 이름을 바꾸어서 변경한다(Hash를 다시 생성한다)   
    * `ETag:aaaa` ->  `ETag:bbbb`
* 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 받기 매커니증이다.  

이때 사용하는 조건부 헤더는 `if-None-Match`이다. if-None-Match: aaaaa     
이후 작업은 날짜 캐싱과 같다.     

* 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 받기 매커니증이다.  
* 캐시 제어 로직을 서버에서 완전히 관리할 수 있다.     
* 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 매커니즘을 모른다.)    
     * 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지할 수 있음 
     * 애플리케이션 배초 주기에 맞추어 ETag로 모두 갱신  

## 캐시와 조건부 요청 헤더  
### 캐시제어 해더 

* Cache-Control: 캐시 제어 
* Pragma : 캐시 제어(하위 호환)  
* Expires : 캐시 유효기간(하위 호환)  

Pragma 와 Expires는 하위 버전의 호환을 위해 존재하고, 현재는 Cache Control로 다 해결할수 있다.  

### Cache Control 
  
* Cache-Control: max-age : 캐시 유효 시간, 초 단위     
* Chche-Control: no-cahce : **데이터는 캐시해도 되지만(캐시 저장소), 사용전에 항상 원래 서버에 검증하고 사용한다.**       
* Cache-Control: no-store : 데이터에 민감한 정보가 있으므로 저장하면 안된다.(메모리에 사용하고 최대한 빨리 삭제)  

### 이외에 
* pragma : no-cache 
     * HTTP 1.0 하위 호환이다.      
* expires : Mon, 01 Jan 1990 00:00:00 GMT   
     * 캐시 만료일을 정확한 날짜로 지정한다.(초단위는 몇초동안이라서 더 유연하다)    
     * HTTP 1.0부터 사용한다.     
     * 지금은 더 유연한 Cache-Control:max-age 를 권장한다.     
     * Cache-Control: max-age 와 함께 사용하면 expires는 무시된다.    

### 검증 헤더와 조건부 요청 헤더 정리  

**검증 헤더**     
* Etag = `ETag: v1.0`, `ETag: asid93jkrh2l`      
* Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT    
  
**조건부 요청 헤더**     
* if-Match, if-None-Match: Etag 값 사용   
* if-Modified-Since, if-Unmodified-Since: Last-Modified 값 사용  
  
# 프록시 캐시 

`원서버 == 진짜 서버`  
그런데 구글서버와 넷플릭스 같은 경우 미국에 있기에 실제 통신을 한다면 오래걸릴 것이다.        
이를 해결하기 위해, 지역 가까운 곳에 서버를 두는 **프록시 캐시 서버가 있다.**(시간 빨라짐)    

이러한 구조에서 프록시 캐시 서버에 들어있는 데이터를 public cache    
웹 브라우저에 저장된 캐시를 private cache 라고 한다.     

* Cache-Control: public
    * 응답이 public 캐시에 저장이되어도 된다. - NGINX     
* Cache-Control: private    
    * 응답이 해당 사용자만을 위한 것임(private 캐시에 저장해야함 - 기본값)    
* Cache-Control: s-maxage
    * 프록시 캐시에만 적용되는 max-age  
* Age: 60(HTTP 헤더)   
    * 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)   
  
# 캐시 무효화   
> 캐시 적용 안한다 해도 웹 브라우저들이 Get요청인 경우 임의로 캐시를 하기도 한다.  

* Cache-Control: no-cache, no-store, must-revalidate
* Prgma: no-chache    
    * HTTP 1.0 하위호환    

**설명**
* Cache-Control: no-cache
    * 데이터는 캐시해도 되지만, 항상 원서버에 검증하고 사용(프록시 캐시 놉)    
* Cache-Control: no-store 
    * 데이터에 민감한 정보가 있으므로 저장하면 안된다. 
    * 메모리에서 사용하고 최대한 빠르게 삭제    
* Cache-Control: must-revalidate  
    * 캐시 만료후 최초 조회시 원 서버에 검증해야함
    * 원 서버 접근 실패시 반드시 오류가 발생해야함 504(Gateway timeout)   
    * must-revalidate는 캐시 유효 시간이라면 캐시를 사용한다.  
* Pragma: no-cache   
    * HTTP 1.0 하위 호환     
