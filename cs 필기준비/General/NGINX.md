# NGINX 

NGINX 는 웹서버이며 리버스 프록시, 로드 밸러서, HTTP 캐시로도 쓰일 수 있는 소프트웨어입니다.    
요청에 응답하기 위해 이벤트 기반 구조를 채택했고 덕분에 현재 웹 서버 분야 1등을 했습니다.  
    
* 이벤트 기반 구조가 어떤점이 좋은가?     
* Apache HTTP Server 와 다른점은?    

# 역사 
## 1995 

1995년 당시, 유닉스 기반으로 만들어진 NCSA HTTPd 라는 최초의 웹서버가 있었다.      
그러나 이 프로그램은 버그가 많아서 개발자들이 사용할 때 불편함을 느꼈다.   
    
몇몇 뛰어난 개발자들이 버그를 수정하기 시작했다.    
그러면서 구조를 변경하고 기능을 추가해서 만든것이 아파치 서버이다.   
 
### 아파치(APACHE HTTP SERVER PROJECT)   

아파치 서버는 요청이 들어오면, 커넥션을 형성하기 위해 프로세스를 생성한다.   
즉, 새로운 클라이언트의 요청이 들어올 때마다, 새로운 프로세스를 만든다.    
(유닉스 계열 OS가 네트워크 커넥션을 형성하는 모델을 그대로 적용한 것)  
   
그러나, 프로세스를 만드는 시간이 오래 걸리는 작업이다보니,       
요청이 들어오기전에 프로세스를 미리 만들어 놓는 PREFORK 방식을 채택했다.    
즉, 새로운 클라이언트로부터 요청이 오면 미리 만들어 놓은 프로세스를 가져다 사용했고    
만들어 놓은 프로세스가 모두 할당되었다면 추가로 프로세스를 만들었다.   
   
이런 구조는 개발하기 쉽다는 장점이있어,     
다양한 모듈을 만들 수 있었고 서버에 빠르게 기능을 추가할 수 있었다.    
이런 기능들이 생기면서 동적 콘텐츠를 처리할 수 있는 기능도 추가되었다.  
   
그리고 확장성이 좋다는 그 장점 덕분에      
요청을 받고 응답을 처리하는 과정을 하나의 서버에서 해결하기 좋았다.  

## 1999
인터넷 트래픽이 계속 증가하는 시대였다.     
점점 컴퓨터가 보급되고 요청이 많아지면서 서버에 이상한 문제가 생김    

서버에 동시에 연결된 커넥션이 많아졌을때, 더이상 커넥션을 형성하지 못하는 문제가 발생했다.    
* C10K : Connection 10000 problem     

### 동시에 연결된 커넥션 수 VS 초당 요청 처리 수 
   
**초당 요청 처리 수** 
* 말 그대로 서버가 얼마나 빨리 요청을 처리할 수 있는지를 나타내는 지표 

**동시에 연결된 커넥션 수** 
* 요청을 처리하기 위해 서버가 한 시점에 많은 클라이언트와 커넥션을 형성하고 있는지를 나타냄  
   
한 클라이언트는 하나의 커넥션을 이용해서 여러 요청을 보낼 수 있다.     
그리고 커넥션은 긴 시간동안 유지될 수 있기 때문에, 이 두 지표는 서로 같다고 할 수 없다.   

이렇게 커넥션이 길게 유지되는 이유는 커넥션을 형성하는데 여러 절차들이 있기 때문이다.    
그래서 이 당시에는 각 요청마다 매번 커넥션을 만들기에는 비효율적이고 속도도 느렸다.    
   
그래서 사람들이 요청을 보낼때 이미 만들어진 커넥션이 있다면 이를 재활용하자는 생각을 한다.    
Keep-alive 헤더에 적힌 시간만큼 클라이언트와 서버는 한번 형성한 커넥션을 계속 유지한다.       
그런데, 이 같은 커넥션이 10000 단위로 넘어가는 순간 더이상 커넥션을 형성하지 못하는 문제가 생겼던 것이다.  

그런데 C10K 문제에서 하드웨어 문제되는게 전혀 없었다.     
문제는 아파치 서버의 구조였다.     
 
아파치 서버는 구조상 커넥션이 형성될 때마다 프로세스를 할당한다.      
그렇기 때문에 동시에 처리하고 있는 커넥션이 많아지면     
그만큼 형성되는 프로세스가 많다는 것이고 이는 곧 메모리 부족현상으로 이어진다.   

설상가상으로 여러 기능을 쉽게 추가할 수 있는 특징은 프로세스가 차지하는 리소스의 양을 늘렸다.   
그리고 많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가면서 일을 했어야했다(컨텍스트 스위칭)  
  
즉, 수많은 동시 커넥션을 감당하기에는 아파치 서버의 구조가 부적합하다는 것이었다.       
물론, 아파치 진영이랑 서버 개발자들은 이런 구조적인 한계를 극복하기 위해서 다양한 시도를 하고 있다.    
아파치 서버의 구조를 완벽히 바꾸지는 못하지만 성능개선이 지금까지도 이루어지고 있다.  
그리고 새롭게 만들어진 서버들은 아에 다른 구조를 채택하기도 했다.   

그리고 2004년에 새로운 구조를 채택하면서 아파치 서버를 보완하기 위한 NGINX가 등장했다.   

초창기 NGINX는 아파치 서버와 함께 사용되기 위해서 만들어졌다.     
웹 서버이긴하지만, 아파치 서버를 완벽히 대체할 목적은 아니었다.         
아파치 서버가 지닌 구조적 한계를 NGINX를 사용해 극복하려했다.    

사용법은 간단했다.   
아파치 서버 앞단에 NGINX 서버를 두어, 아파치 서버가 감당해야했던 동시 커넥션을 NGINX가 대신해서 유지할 수 있다.  
즉, 구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 NGINX를 이용해서 크게 줄일 수 있었다.  
그리고 NGINX 또한 웹 서버이기 때문에, 정적 파일에 대한 요청은 스스로 처리할 수 있다.     
그렇기 때문에 정적 파일이 들어오면 NGINX에서 처리하고,     
동적 파일에 대한 요청만을 NGINX가 아파치 서버와 커넥션을 형성하여 처리한다.      

그렇다면 NGINX는 어떤 구조로 되어있기에 그 많은 동시 커넥셔을 유지할 수 있었을까? 비결은 만들어진 프로세스 수에 있다.   

NGINX의 구조를 살펴보면, 가장 먼저 Master Process 를 볼 수 있다.    
설정 파일을 읽고, 설정에 맞게끔 Worker Process 를 생성하는 프로세스이다.  
  
Worker Process가 실제로 일을 하는 프로세스인데       
Worker Process가 만들어질때, 각자 지정된 listen 소켓을 배정받는다.        
그리고 그 소켓에 새로운 클라이언트로부터 요청이 들어오면 커넥션을 형성하고 그 요청을 처리한다.  
(그 커넥션은 정해진 Keep-Alive 시간만큼 유지할 것이다.)       
 
그런데 커넥션이 형성되었다고, Worker Process가 해당 커넥션 하나만 한정적으로 담당하지는 않는다.      
형성된 커넥션에 아무런 요청이 없으면, 새로운 커넥션을 형성하거나     
이미 만들어진 다른 커넥션으로부터 요청을 처리한다.    
  
NGINX 에서는 이런 커넥션 형성, 커넥션 제거 그리고 새로운 요청을 처리하는 것을 이벤트라고 부른다.     
이 이벤트들은 OS 커널이 큐 형식으로 Worker Process에게 전달해준다.        
이 이벤트는 큐에 담긴 상태에서 Worker Process가 처리할 때까지 비동기 방식으로 대기한다.    
그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해나간다.   
 
이 같은 구조로, Worker Process가 쉬지 않고 일을 계속한다는 장점이 있다.      
이는 아파치 서버의 구조와 비교했을 때, 요청이 없다면 방치되는 프로세스보다 서버 자원을 훨씬 효율적으로 쓰는셈이다.    
그런데 만약 큐에 들어있는 이벤트들 중에서 I/O 작업과 같이 읽고 쓰는데 오래 걸리는 이벤트가 있다면 어떻게 될까?  
당연하게도 그 뒤에있는 이벤트들은 요청을 처리하는 시간동안 블록킹 된다.   
NGINX는 이러한 문제를 해결하기 위해서, 시간이 오래 걸리는 작업을 따로 수행하는 Thread Pool 을 만들어 놓았다.  
즉, Worker Process가 지금 처리할 요청이 시간이 오래걸릴 것 같다 싶으면      
해당 이벤트를 Thread Pool에 위임하고 큐 안에 있는 다른 이벤트를 처리한다.   
     
이런 Worker Process 는 보통 CPU의 코어 갯수만큼 생성한다.          
이러면 코어가 담당하는 프로세스를 바꾸는 횟수를 대폭 줄일 수 있다.        
CPU가 굳이 그런 부가적인 일을 하지 않아도 되는 것이다.(컨텍스트 스위칭을 줄이는 것)     

이게바로, NGINX가 채택한 Event Driven Model이고(이벤트 기반 구조) 아파치 서버와 가장 큰 차이점이다.  
단, 단점도 있는데 개발자가 기능을 추가했다가 돌아가고 있는 Worker Process를 종료시킬 수 있다.    
이는 곧, 해당 Worker Process가 관리하고 있는 커넥션과 관련된 요청을 더이상 처리할 수 없는 문제가 발생한다.    
그래서 NGINX 는 개발자가 직접 모듈을 만들기는 까다롭다.   
     
하지만, 단점에 비해 장점이 너무나도 명확했다.    
수많은 동시 커넥션
















그렇다면 NGINX는 어떤 구조로 되어있기에 그 많은 동시 커넥셔을 유지할 수 있었을까?    






그렇기 때문에 동시에 처리하고 있는 커넥션이 많아지면 그만큼 형성되는 프로세스가 많다는 것이고 이는 곧 메모리 부족현상으로 이어진다. ㅇㅕ러 
그렇기 때문에 동시에 처리하고 있는 커넥션이 많아지면 그만큼 형성되는 프로세스가 많다는 것이고 이는 곧 메모리 부족현상으로 이어진다. 




