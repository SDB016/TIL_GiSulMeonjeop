# NGINX 

NGINX 는 웹서버이며 리버스 프록시, 로드 밸러서, HTTP 캐시로도 쓰일 수 있는 소프트웨어입니다.    
요청에 응답하기 위해 이벤트 기반 구조를 채택했고 덕분에 현재 웹 서버 분야 1등을 했습니다.  
    
* 이벤트 기반 구조가 어떤점이 좋은가?     
* Apache HTTP Server 와 다른점은?    

# 역사 
## 1995 

1995년 당시, 유닉스 기반으로 만들어진 NCSA HTTPd 라는 최초의 웹서버가 있었다.      
그러나 이 프로그램은 버그가 많아서 개발자들이 사용할 때 불편함을 느꼈다.   
    
몇몇 뛰어난 개발자들이 버그를 수정하기 시작했다.    
그러면서 구조를 변경하고 기능을 추가해서 만든것이 아파치 서버이다.   
 
### 아파치(APACHE HTTP SERVER PROJECT)   

아파치 서버는 요청이 들어오면, 커넥션을 형성하기 위해 프로세스를 생성한다.   
즉, 새로운 클라이언트의 요청이 들어올 때마다, 새로운 프로세스를 만든다.    
(유닉스 계열 OS가 네트워크 커넥션을 형성하는 모델을 그대로 적용한 것)  
   
그러나, 프로세스를 만드는 시간이 오래 걸리는 작업이다보니,       
요청이 들어오기전에 프로세스를 미리 만들어 놓는 PREFORK 방식을 채택했다.    
즉, 새로운 클라이언트로부터 요청이 오면 미리 만들어 놓은 프로세스를 가져다 사용했고    
만들어 놓은 프로세스가 모두 할당되었다면 추가로 프로세스를 만들었다.   
   
이런 구조는 개발하기 쉽다는 장점이있어,     
다양한 모듈을 만들 수 있었고 서버에 빠르게 기능을 추가할 수 있었다.    
이런 기능들이 생기면서 동적 콘텐츠를 처리할 수 있는 기능도 추가되었다.  
   
그리고 확장성이 좋다는 그 장점 덕분에      
요청을 받고 응답을 처리하는 과정을 하나의 서버에서 해결하기 좋았다.  

## 1999
인터넷 트래픽이 계속 증가하는 시대였다.     
점점 컴퓨터가 보급되고 요청이 많아지면서 서버에 이상한 문제가 생김    

서버에 동시에 연결된 커넥션이 많아졌을때, 더이상 커넥션을 형성하지 못하는 문제가 발생했다.    
* C10K : Connection 10000 problem     

### 동시에 연결된 커넥션 수 VS 초당 요청 처리 수 
   
**초당 요청 처리 수** 
* 말 그대로 서버가 얼마나 빨리 요청을 처리할 수 있는지를 나타내는 지표 

**동시에 연결된 커넥션 수** 
* 요청을 처리하기 위해 서버가 한 시점에 많은 클라이언트와 커넥션을 형성하고 있는지를 나타냄  
   
한 클라이언트는 하나의 커넥션을 이용해서 여러 요청을 보낼 수 있다.     
그리고 커넥션은 긴 시간동안 유지될 수 있기 때문에, 이 두 지표는 서로 같다고 할 수 없다.   

이렇게 커넥션이 길게 유지되는 이유는 커넥션을 형성하는데 여러 절차들이 있기 때문이다.    
그래서 이 당시에는 각 요청마다 매번 커넥션을 만들기에는 비효율적이고 속도도 느렸다.    
   
그래서 사람들이 요청을 보낼때 이미 만들어진 커넥션이 있다면 이를 재활용하자는 생각을 한다.    
Keep-alive 헤더에 적힌 시간만큼 클라이언트와 서버는 한번 형성한 커넥션을 계속 유지한다.       
그런데, 이 같은 커넥션이 10000 단위로 넘어가는 순간 더이상 커넥션을 형성하지 못하는 문제가 생겼던 것이다.  

그런데 C10K 문제에서 하드웨어 문제되는게 전혀 없었다.     
문제는 아파치 서버의 구조였다.     
 
아파치 서버는 구조상 커넥션이 형성될 때마다 프로세스를 할당한다.      
그렇기 때문에 동시에 처리하고 있는 커넥션이 많아지면     
그만큼 형성되는 프로세스가 많다는 것이고 이는 곧 메모리 부족현상으로 이어진다.   

설상가상으로 여러 기능을 쉽게 추가할 수 있는 특징은 프로세스가 차지하는 리소스의 양을 늘렸다.   
그리고 많은 커넥션에서 요청이 들어오기 시작하면, CPU 코어는 계속해서 프로세스를 바꿔가면서 일을 했어야했다(컨텍스트 스위칭)  
  
즉, 수많은 동시 커넥션을 감당하기에는 아파치 서버의 구조가 부적합하다는 것이었다.       
물론, 아파치 진영이랑 서버 개발자들은 이런 구조적인 한계를 극복하기 위해서 다양한 시도를 하고 있다.    
아파치 서버의 구조를 완벽히 바꾸지는 못하지만 성능개선이 지금까지도 이루어지고 있다.  
그리고 새롭게 만들어진 서버들은 아에 다른 구조를 채택하기도 했다.   

그리고 2004년에 새로운 구조를 채택하면서 아파치 서버를 보완하기 위한 NGINX가 등장했다.   

초창기 NGINX는 아파치 서버와 함께 사용되기 위해서 만들어졌다.     
웹 서버이긴하지만, 아파치 서버를 완벽히 대체할 목적은 아니었다.         
아파치 서버가 지닌 구조적 한계를 NGINX를 사용해 극복하려했다.    

사용법은 간단했다.   
아파치 서버 앞단에 NGINX 서버를 두어, 아파치 서버가 감당해야했던 동시 커넥션을 NGINX가 대신해서 유지할 수 있다.  
즉, 구조적으로 동시 커넥션을 많이 유지 못하는 아파치 서버의 부하를 NGINX를 이용해서 크게 줄일 수 있었다.  
그리고 NGINX 또한 웹 서버이기 때문에, 정적 파일에 대한 요청은 스스로 처리할 수 있다.     
그렇기 때문에 정적 파일이 들어오면 NGINX에서 처리하고,     
동적 파일에 대한 요청만을 NGINX가 아파치 서버와 커넥션을 형성하여 처리한다.      

그렇다면 NGINX는 어떤 구조로 되어있기에 그 많은 동시 커넥셔을 유지할 수 있었을까? 비결은 만들어진 프로세스 수에 있다.   

NGINX의 구조를 살펴보면, 가장 먼저 Master Process 를 볼 수 있다.    
설정 파일을 읽고, 설정에 맞게끔 Worker Process 를 생성하는 프로세스이다.  
  
Worker Process가 실제로 일을 하는 프로세스인데       
Worker Process가 만들어질때, 각자 지정된 listen 소켓을 배정받는다.        
그리고 그 소켓에 새로운 클라이언트로부터 요청이 들어오면 커넥션을 형성하고 그 요청을 처리한다.  
(그 커넥션은 정해진 Keep-Alive 시간만큼 유지할 것이다.)       
 
그런데 커넥션이 형성되었다고, Worker Process가 해당 커넥션 하나만 한정적으로 담당하지는 않는다.      
형성된 커넥션에 아무런 요청이 없으면, 새로운 커넥션을 형성하거나     
이미 만들어진 다른 커넥션으로부터 요청을 처리한다.    
  
NGINX 에서는 이런 커넥션 형성, 커넥션 제거 그리고 새로운 요청을 처리하는 것을 이벤트라고 부른다.     
이 이벤트들은 OS 커널이 큐 형식으로 Worker Process에게 전달해준다.        
이 이벤트는 큐에 담긴 상태에서 Worker Process가 처리할 때까지 비동기 방식으로 대기한다.    
그리고 Worker Process는 하나의 스레드로 이벤트를 꺼내서 처리해나간다.   
 
이 같은 구조로, Worker Process가 쉬지 않고 일을 계속한다는 장점이 있다.      
이는 아파치 서버의 구조와 비교했을 때, 요청이 없다면 방치되는 프로세스보다 서버 자원을 훨씬 효율적으로 쓰는셈이다.    
그런데 만약 큐에 들어있는 이벤트들 중에서 I/O 작업과 같이 읽고 쓰는데 오래 걸리는 이벤트가 있다면 어떻게 될까?  
당연하게도 그 뒤에있는 이벤트들은 요청을 처리하는 시간동안 블록킹 된다.   
NGINX는 이러한 문제를 해결하기 위해서, 시간이 오래 걸리는 작업을 따로 수행하는 Thread Pool 을 만들어 놓았다.  
즉, Worker Process가 지금 처리할 요청이 시간이 오래걸릴 것 같다 싶으면      
해당 이벤트를 Thread Pool에 위임하고 큐 안에 있는 다른 이벤트를 처리한다.   
     
이런 Worker Process 는 보통 CPU의 코어 갯수만큼 생성한다.          
이러면 코어가 담당하는 프로세스를 바꾸는 횟수를 대폭 줄일 수 있다.        
CPU가 굳이 그런 부가적인 일을 하지 않아도 되는 것이다.(컨텍스트 스위칭을 줄이는 것)     

이게바로, NGINX가 채택한 Event Driven Model이고(이벤트 기반 구조) 아파치 서버와 가장 큰 차이점이다.  
단, 단점도 있는데 개발자가 기능을 추가했다가 돌아가고 있는 Worker Process를 종료시킬 수 있다.    
이는 곧, 해당 Worker Process가 관리하고 있는 커넥션과 관련된 요청을 더이상 처리할 수 없는 문제가 발생한다.    
그래서 NGINX 는 개발자가 직접 모듈을 만들기는 까다롭다.   
      
하지만, 단점에 비해 장점이 너무나도 명확했다.      
수많은 동시 커넥션을 빠르게 처리하는데, 프로세스를 적게 만들다보니 가볍기까지 했다.     
그리고 프로세스를 적게 만드는 이 구조는 NGINX의 설정을 동적으로 바꾸는 것을 가능하게 했다.     
    
개발자가 설정 파일을 변경하고, NGINX에 해당 설정을 적용하면       
Master Process는 그 설정에 맞는 새로운 Worker Process를 따로 생성한다.   
그리고 기존에 있는 Worker Process 가 더이상 커넥션을 형성하지 않도록 한다.   
   
시간이 지나 기존 Worker Process 가 담당하던 이벤트처리가 모두 끝나면 해당 프로세스를 종료한다.    
그런데 언제 사용할까?      

대표적인 경우로, 여러 동시 커넥션을 관리하는 도중에 뒷단에 서버가 추가되는 경우가 있다.  
그땐, NGINX가 로드밸런서 역할을 하는데(요청을 여러 서버로 분산하는 작업 수행)   
  
NGINX 뒤에 새로운 서버를 추가해야하는데,     
NGINX는 수많은 동시 커넥션을 담당하고 있다면 설정을 바꾸기 위해 NGINX를 종료하는 상황이 좀 어렵다.      
   
그런데, 동적으로 설정을 변경할 수 있다면       
동시 커넥션을 유지한채 그리고 기존 요청을 계속해서 처리하면서 뒷단에 서버를 추가할 수 있다. 
NGINX는 이런 설정 변경을 초당 수십번을 해도 무리 없이 커넥션을 관리하고 요청을 서버에게 전달한다(이벤트 구조여서 가능)   
 
이러한 NGINX도 처음 출시했을 때에는 사용하는 사람이 많이 없었다.    
그러나 2008년부터 아파치 서버의 점유율이 점점 낮아지기 시작했고 NGINX는 빠른 속도로 치고 올라오기 시작했다.   
이는 스마트폰이 보급되면서 동시 커넥션이 더 많이 형성되는 환경이 조성되었기 때문이다.(다양한 정보를 실시간 제공 받고 싶어함)   
     
그리고 웹에 담기는 컨텐츠가 다양해지고 그 용량이 커지면서     
브라우저도 리소스를 빨리 가져오기 위해 여러 TCP 커넥션을 동시에 형성하기 시작했다.   
(그리고 각각의 커넥션을 모두 Keep-Alive로 유지)   

결국 동시 커넥션 문제를 처리해야할 서버가 날이 갈 수록 많아졌다.   
회사들은 빠르게 NGINX 대체제에 눈을 돌리기 시작했고 대규모 사이트를 운영하고 잇는 큰회사들에서 좋아할만한 솔루션이었다.   
  
덕분에 NGINX가 인터넷 트래픽에 관여하는 비중은 멈추지 않고 계속 증가한다.    

아파치 서버도 MPM 이라는 모듈을 추가해서 성능을 개선했다.(Multi Processing Module)   
아파치 서버를 어떤 방식으로 운영할지 선택할 수 있게끔 해주는 모듈이다.   
        
안전성이나 하위호환이 필요하다면 기존의 PREFORK 방식을 사용하고     
성능 향상이 필요하다면, WORKERS 라고 불리는 스레드를 만들어서 WORKERS가 요청을 처리하도록 했다.   
   
그러나 성능 테스트 결과를 보면       
아직까지 동시 커넥션 관련 지표에선 NGINX 가 아파치 서버를 크게 앞서고 있다.     

이 지표는 동시 커넥션 수당 메모리 사용률인데,      
NGINX는 동시 커넥션이 많아져도 메모리 사용률이 낮고 일정하게 나오는 반면 아파치 서버는 굉장히 많이 사용한다.  
동시 커넥션 수가 많아졌을때, 처리하는 초당 요청 횟수는 오히려 NGINX가 훨씬 많고 아파치는 낮다는 것을 볼 수 있다.(최소 2배 이상)   
    
사실 우리는 동시 커넥션이라는 포인트에만 집중해서 그렇지       
아파치가 아직 NGINX와 1,2위를 다투는데에는 그 그만한 이유가 있다.     

* NGINX : 웹 서버 보완(특히 C10K 동시 커넥션 문제)   
* APACHE : 호환성 확장성   

아파치 서버가 등장하기 이전 서버는 버그가 많았다.     
버그 수정을 계기로 시작된게 아파치 서버이기에      
그리고 지금까지 오랜 기간 업데이트를 계속해서 해왔기 때문에   
서버 자체가 다양한 OS에서 안정적이라는 장점이 있다.   
   
NGINX는 그렇지 않아서 Window에서 제대로된 성능을 발휘하지 못한다.     
그리고 기능을 확장하기 쉽다는 장점이 있어서      
아파치 서버로 만들어진 오래된 서비스라고 해도 현재 잘 돌아가고 있고       
모듈로 기능을 계속해서 추가할 수 있다면, 굳이 다른 서버로 옮길 이유가 없다.    
그리고 모듈의 종류는 아파치 서버가 NGINX 서버보다 훨씬 많다.   
   
각 웹서버가 어떠한 이유로 등장했는지 알게되면 그 서버를 왜 선택해야하는지 알 수 있다.  
이 두 서버가 탄생한 이유를 보면 사실 대립관계가 아니다.  
애초에 만들어진 목적 자체가 달랐다.   
  
아파치 서버가 1위를 했을 때는, 안정성과 확장성이 무엇보다 중요했고     
NGXIN가 치고 올라올 때는, 동시 커넥션 문제가 너무나도 중요한 상황이었다.   

## 2021, NGINX를 어떻게 사용해야하는가   

1. 웹서버 기능 
2. 로드밸런서 기능 
     
NGINX는 동시 커넥션을 여러개 유지할 수 있고 그 자체가 가볍다는 장점을 살려서 
이 이외에도 다양한 방법으로 **웹 서버 가속기** 역할을 한다.    

### SSL 터미네이션    
* SSL 터미네이션 : 
    * NGINX가 클라이언트와는 HTTPS 통신   
    * NGINX가 서버와 HTTP 통신    
    * 서버가 복호화 과정을 담당하지 않도록 한다.          
    * 즉, 비즈니스 로직처리에 집중하도록 해준다.(리소스 비즈니스로직에만)         
    * 보통 NGINX와 서버는 같은 네트워크 안에 있기에 HTTP를 사용해도 보안적인 위험이 비교적 적다.   

### 캐싱 
* 캐싱 : 
    * HTTP 프로토콜을 사용해서 전달하는 컨텐츠를 캐싱할 수 있다.     
    * 캐싱을 하는 경우에는 NGINX를 클라이언트와 가깝게 배치하여      
      한번 서버로부터 받은 응답을 스스로 보관하고 클라이언트에게 전달한다.  

이외에도   
1. HSTS 
2. CORS 처리 
3. TCP/UDP 커넥션 부하 분산 
4. HTTP2 

# 정리하자면 아래와 같다.  

* Unix 기반 OS들은 일반적으로 커넥션 요청이 오면, 스레드나 프로세스를 생성하는 작업을 한다.             
* 과거에는 괜찮았으나 인터넷 버블과 스마트폰의 등장으로서 동시 커넥션을 처리하기 힘들어졌다.          
* 메모리는 물론, 커넥션 처리를 위해서 컨택스트 스위칭이 자주 발생하는 것도 문제였다.     
  
* 반면에, NGINX는 마스터 프로세스 밑에 워커 프로세스를 미리 만들어 작업을 진행한다.     
* 이벤트 기반 방식으로, 커넥션 이벤트가 발생하면 큐에 저장하여 워커 프로세스가 순차적으로 데이터를 처리한다.        
* 더불어, 이벤트가 들어오면 큐에 저장을 하고 다시 이벤트 요청을 받는 작업을 진행하는 비동기 방식을 사용한다.       
* 워커 프로세스의 개수는 CPU core 수와 동일하게 생성하여 컨텍스트 스위칭의 횟수를 최소화했다.       





