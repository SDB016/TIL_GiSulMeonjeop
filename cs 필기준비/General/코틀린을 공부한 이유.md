# 당근마켓에서 코틀린을 도입하고 장단점 
      
**선택한 이유 :**      
1. 코틀린 언어적 간결성 + 트랜드  

## 권용권님이 생각한 얻은 3가지 장점  

* 자바와의 상호 운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어이다.  

**코틀린의 철학**
1. 언어의 간결성
    1. 키워드(data)
    2. 풍부한 API 
    3. 단일표현 함수는 식으로 정의 가능     
    * 가독성과 생산성을 높여준다.   
2. 안정성 
    1. NullSafety 하므로, NPE 발생을 방지한다.(NPE한 코드로 유도한다)   
    2. 타입 검사와 캐스트가 한 연산자에 이루어지며, ClassCastException 을 방지한다.  
    3. when 사용시, break가 없어도 되며 열거형/sealed 사용하면 모든 값이 평가되었는지 확인 가능(else도 사용x)   
    4. 그리고 이 모든게 컴파일 타임에서 지원을 해줘서 생산성 + 안정성에 좋다.  
     
2021년도에 다시 만나다

**그만 널 잊으려고**  
* 널러블 타입 ? 을 사용하면 무조건 널 검사를 해야하고 그렇지 않으면 컴파일 타임에서 알 수 있다.     
* 안전한 호출 연산자 `?.` : 널이 아니면 메서드/프로퍼티 호출      
* 엘비스 연산자 `?:` : 널인 경우 호출 구문 작성      
* 널 아님 단언 `!!` : 널 아님을 단언, 단 널일 경우 NPE 발생   
   
**다 놀았니? 이제 할일 하자**      
* 식 -> 값을 만들어 낼 수 있느것이며 다른 하위 요소로 참여 가능하다.       
* 문 -> 블록의 최상위 요소로, 값을 만들어내지 않는다.         
* 자바와 달리 코틀린은 loop 를 제외한 모든 요소가 식이다 -> 코드가 간결해진다.     
    
**봉인해서 까먹지 않기**       
* when 을 통해서 분기 처리할 수 있다.      
* sealed 나 enum 을 사용하면, else를 사용하지 않고도 처리할 수 있다.      
* 뿐만 아니라 is/as 를 통해서 특정 타입으로 캐스팅 + else 로직을 없앨 수도 있다.    
* sealed 는 동일 패키지 내에 존재하는 하위 클래스들만 상속을 보장한다.     
   
**오버하지마**     
* 이름붙인 인자(namedParameter) -> 인자 순서에 자유로워 지고, 명확해진다.     
* 기본 인자 -> 디폴트 값을 주어, 확장에 유연하다, 이름붙인 인자를 같이 이용하면 생성자 오버로딩을 하지 않아도 된다.     
* 익명클래스/람다의 사용 대신`{}` => `{}`만 이용하면 손쉽게 개발 가능 => it를 이용하여 람다 인자 없앨수 있음        

**너의 이름은 함수타입**   
* 코틀린의 함수는 일급 시민이여서 함수 자체를 넘길 수 있다.   

**품행제로(컨벤션)**    
* 자바 라이브러리 사용 자제 
* 콜론은 한 칸 뛰고 
* 세미콜론 사용 X 
* 메서드 닫는 블록과 클래스 닫는 블록은 붙여서 작성   

### 표현력이 풍부한 아이 
#### 뭣이 중헌디   
1. 스코프 함수로 가독성 높이기  
    * let   
    * apply      
    * run    
2. 확장 함수 
    * 클래스 밖에 선언되었지만, 멤버함수처럼 함수    
    * 기존에 존재하는 변경 불가능한 라이브러리에 추가할 수 있다.   
3. 할 일만 간결하게
4. 너니까 너답게 
     * 테스트 코드 작성때, @Autowired가 필요하다. 근데 여러개라면?   
         * `@TestConstructor(autowireMode..)`  
     * MockMvcTest 
         * DSL을 이용하면 목적에 드러나게 코드 작성이 가능하다.   
       
#### 로컬 커머스팀     
커머스에서 로컬의 가치를 찾는 것      
기술을 선택하는 측면에서 유연하고, 비동기로 꾸려보면 어떨까      
