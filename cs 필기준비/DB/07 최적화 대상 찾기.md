# DB 최적화 대상 
 
DB에서 최적화를 할 부분은 아래 3가지이다.     
 
1. Client 
2. DataBase Engine
3. FileSystem

## Client(Application)  

* 복수의 레코드를 한번의 호출로 집합 처리하거나, 
  두개 이상의 쿼리를 한 쿼리로 통합 처리함으로써 호출 수를 줄일 수 있다.  
* JDBC Statement는 `쿼리 문장 분석`, `컴파일`, `실행`의 단계를 캐싱한다.
  JDBC PreParedStatement 는 처음 한번만 세단계를 거친후 캐시에 담아서 재사용한다.  
* DB Connetion Pool 을 사용하여 객체를 생성하는 부분에서 발생하는 대기시간을 줄이고, 네트워크 부담을 줄일 수 있다.   
* FetchSize를 조정하거나 Paging을 활용한다.    
  
## DataBase Engine

* 파일시스템에 저장된 데이터가 조회되면,  
  해당 데이터를 메모리에 저장해 이후 동일 데이터 조회시 파일 시스템의 물리적인 입출력이 발생하지 않도록 한다.(캐싱)  
* 서버 파라미터를 튜닝한다.  
 
## FileSystem  
* HDD 대신, SDD를 사용한다.     
* SQL을 최적화하면 필요 이상의 데이터 블록을 읽는 것을 방지합니다.    
  즉, SQL 튜닝이란 읽는 블록수를 줄여주는 것을 의미한다.   

# SQL 최적화 대상  

## 쿼리 동작 방식 

1. Query Caching 
2. Parsing 
3. Preprocessor
4. Optimization 
5. Handler(Storage Engine) 

### Query Caching 
> SQL문이 Key, 쿼리의 실행결과가 Value인 Map     
  
SQL문을 키값으로 실행 결과를 Value로 저장하여 캐싱하는 방식이다.  
    
* 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?      
* 해당 사용자가 그 결과를 볼 수 있는 권한이 있는가?    
* 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?  
* 호출 시점에 따라 결과가 달라지는 요소가 있는가? (랜덤/현재값)     
* 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가  
* 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?  

### Parsing 
  
사용자로부터 요청된ㄷ SQL을 잘게 쪼개서 서버가 이해할 수 있는 수준으로 분리한다.  

### Preprocessor

해당 쿼리가 문법적으로 틀리지 않은지 확인하여 부정확하다면 여기서 처리를 중단한다.    
(일괄 처리일 경우, 일괄 처리 전체를 취소한다.)    

### Optimization 
Explain(실행 계획)이란 것도 존재하는데, 이 단계에서의 출력을 의미한다.   
     
* 쿼리 분석: Where 절의 검색 조건인지 Join 조건인지 판단한다.      
* 인덱스 선택 : 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정한다.    
* 조인 처리 : 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정한다.  
 
### Handler(Storage Engine)   
MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어오는 역할을 담당한다.     
MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.   

# Index Range Scan VS Table Full Scan 

데이터베이스 테이블에서 데이터를 찾는 방법은 2가지다.   

1. Table Full Scan : 테이블 전체를 스캔한다.  
2. Index Range Scan : 인덱스를 이용한다. 

**Table Full Scan**   
시퀀셜 엑세스와 Multiblock I/O 방식으로 디스크를 읽어 한 블록에 속한 모든 레코드를 한번에 읽어들인다.     
읽을 데이터가 일정량을 넘으면 Index Range Scan 보다 유리하다.      
  
**Index Range Scan**
랜덤 액세스와 Singleblock I/O 방식으로 레코드 하나를 읽기 위해 매번 I/O가 발생한다.   
읽을 데이터가 일정량을 넘으면 Table Full Scan 보다 불리하다.  

OLTP 시스템에서는 트랜잭션 단위로 소량의 데이터를 주로 검색하므로 **인덱스를 효과적으로 사용하는 것이 중요하다.**    
결론만 말하면, Index를 사용할 경우 Random I/O 횟수를 줄이는 것이 목표다.     
(추가적으로, 대량의 데이터를 빠르게 처리하려면 인덱스와 NL 조인보다 Table Full Scan과 해시 조인이 유리하다.      
Tabel Full scan 비용은 파티션 활용 전략과 병렬처리로 줄일 수 있다.)    

## 인덱스 탐색 과정 
  
![GUID-A4C15694-3DB6-43D6-B2C6-9A40905DF972-default](https://user-images.githubusercontent.com/50267433/146512981-4ee10376-4ab8-4e7e-b5c2-f980ea1898a7.gif)

인덱스 탐색 과정은 아래 2가지로 나눌 수 있다. 
 
1. 수직적 탐색 : 스캔 시작지점을 찾는다.    
2. 수평적 탐색 : 조회할 데이터를 찾는다.     

### 수직적 탐색   
수직적 탐색은 루트 블록에서부터 시작한다.    
루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 가진다.   
수직적 탐색 과정에 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동한다.  
  
작으면, 거기서 멈추나보다.  

### 수평적 탐색 

수직적 탐색을 통해 시작 지점을 찾았으면, 수평적 탐색을 통해 데이터를 찾는다.     
인덱스 리프 블록끼리는 양방향 Linked List 이므로 서로 앞뒤에 대한 주소값을 갖는다.   

필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, **그렇지 않을 경우 테이블도 엑세스 해야한다.**        
이 경우 ROWID가 필요하며 ROWID는 데이터블럭 주소 + 로우 번호(블록내 순번)으로 구성된다.     
 
### 테이블 액세스 
   
ROWID가 가리키는 테이블 블록을 버퍼 캐시에서 먼저 찾아보고 못찾을때만 디스크에서 블록을 읽는다.      
우선, 리프 블록에서 읽은 ROWID를 분해해서 DBA(데이터 파일 번호 + 블록 번호) 정보를 얻는다.       
그리고 DBA를 해시함수에 입력해서 해시체인을 찾고, 거기서 버퍼 헤더를 찾는다.       
실제 데이터가 담긴 버퍼블록은 매번 다른 위치에 캐싱되는데, 그 메모리 주소값을 버퍼 헤더가 가지고 잇다.      
  
즉, **모든 데이터가 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA 해싱가 래치 획득 과정을 반복해야한다.**      
동시에 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.     
