# Optimizer
## MySQL 옵티마이저 구조 

![mysql-sql-executor-flow](https://user-images.githubusercontent.com/50267433/146498116-473b07ec-4ed5-44c9-90bc-6030e9aeccbc.png) 

1. SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리
2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
3. 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴 
  
### 1단계 : SQL 파싱      
SQL 파서라는 모듈로 처리하여, 만약 SQL문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.       
또한, 이 단계에서 `SQL Parse Tree`가 만들어진다.    
MySQL 서버는 SQL문장 그자체가 아니라 SQL Parse Tree를 이용해 쿼리를 실행한다.    

### 2단계 : 최적화 및 실행 계획 수립  

SQL Parse Tree를 참조하면서, 아래와 같은 작업을 처리한다.       
* 불필요한 조건의 제거 및 복잡한 연산의 단순화    
* 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정      
* 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정    
* 가져온 레코드들을 임시 테이블에 넣고 다시 가공해야 하는지 결정   

MySQL 옵티마이저에서 처리하고, 완료되면 쿼리의 실행 계획이 만들어진다.   

### 3단계  
수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고,     
MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.    


# 옵티마이저 종류 
## 비용 기반 최적화  
    
비용 기반 최적화는 쿼리를 처리하기 위한 여러가지 가능한 방법을 만들고,        
각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 **각 실행 계획별 비용을 산출한다.**        
**이렇게 산출된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행하게 된다.**     

## 규칙 기반 최적화 
   
각 테이블이나 인덱스의 통계 정보가 거의 없고,      
상대적으로 느린 CPU 연산 탓에 계산 비용 과정이 부담스러웠기 때문에 **사용되었던** 최적화 방법이었다.     
현재는 거의 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며 RDBMS도 마찬가지이다.    
  
# 통계 정보  
MYSQL 통계 정보는, 대략의 레코드 건수와, 인덱스의 유니크한 값의 개수 정도가 전부        
그러나 사용자가 알아채지 못하는 순간 순간 자동으로 변경되기 때문에 상당히 동적인 편이다.     
하지만, 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로   
ANALYZE 명령을 이용해 강제적으로 통계 정보를 갱신해야할 때도 있다.     


**MySQL 옵티마이저**는 비용 기반으로, 어떤 실행 계획으로 쿼리를 실행했을 때 비용이 얼마나 발생하는지를 계산하여 비용이 가장 적은 것을 택한다.   
어디까지나 추정 값이므로 정확한 비용은 실행전까지 정확히 알 수 없다.  

MySQL 8.x 대에서 성능이 2~3배 향상되었다는 얘기도 있다.  
