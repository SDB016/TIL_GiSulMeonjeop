# 개요 
  
서비스 규모가 커지고 DB에 저장하는 데이터의량 또한 대용량으로 커지게 되면     
기존 DBMS의 용량(Storage)의 한계와 성능의 저하를 가져온다.         
       
VLDB 즉 하나의 RDBMS에 너무 큰 테이블이 들어가면 용량과 성능 측면에서 많은 이슈가 발생하게 되는데        
이러한 이슈를 해결하기 위해, 스키마를 복사하고 그 안에 분할된 테이블을 이용하는 샤딩 기법을 이용하면 된다.        
          
# 샤딩이란      
     
* DB애 존재하는 하나의 테이블을 다수의 DB로 분할하여 데이터를 저장하는 방식을 말한다.        
* Application level 에서도 가능하지만 DataBase Level에서도 가능하다.       
      
예를들면, 아래와 같이 여러 DB에 동일한 테이블을 만들되, 저장하는 데이터의 기준을 달리한다.        
 
* A.광명시_주민 테이블 : 철산동 주민 데이터     
* B.광명시_주민 테이블 : 하안동 주민 데이터    
* C.광명시_주민 테이블 : 소하동 주민 데이터   
    
## 고려해야할 점   
**적용에 앞서**    
* 프로그래밍, 운영적인 복잡도는 더 높아진다.              
* 가능하면 샤딩을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선시 된다.      
    * ScaleUp : 컴퓨터 성능 업     
    * Read 부하가 크면? : Chache나 Replication도 하나의 방법    
    * Table 일부 컬럼만 사용된다면 : 수직 파티셔닝도 하나의 방법     
    * 데이터를 핫/웜/콜드로 분리    
  
**적용한 후**
* 분산된 데이터베이스에서 데이터를 어떻게 분산시켜서 저장할 것인가?  
    * 분산이 잘 되지 않고, 한쪽으로 데이터가 몰리면 자연스럽게 **핫스팟**이 되어 성능이 느려진다.  
* 분산된 데이터베이스에서 데이터를 어떻게 Read할 것인가?   


# 방법 
   
**요구사항**   
* 라우팅을 위해 구분할 수 있는 유일한 키값이 있어야 한다.(편의상 아래부터는 PK 또는 샤딩키라고 부릅니다.)
* 올바른 DB를 찾을 수 있도록 라우팅이 돼야 한다.
* 설정으로 쉽게 증설이 가능해야 한다.
   
## 샤드키  
* 나눠진 샤드 중 어떤 샤드를 선택할지 결정하는 키       
* 샤드 키 결정 방식에 따라 샤딩 방법이 나뉜다.    
   
## Router  
* 방식들은 어떤 기준으로 데이터를 분산시킬지에 대한 명세를 정의한 것   
* 실제로 분산된 DB에 접근하기 위한 논리적인 작업은 라우터가 담당하게 됩니다.  
   
## 해시 샤딩(모듈러 샤딩)   
  
<img width="427" alt="thiiing-db-modular-sharding" src="https://user-images.githubusercontent.com/50267433/146634269-17399156-d240-4fbc-8116-93325f7003ab.png">
     
해시(모듈러)샤딩은 PK를 모듈러 연산한 결과로 DB를 특정하는 방식이다.        
데이터량이 일정 수준에서 유지될 것으로 예상되는 데이터 성격을 가진 곳에 적용할 때 어울리는 방식으로        
데이터가 균일하게 분산된다는 점은 트래픽을 안정적으로 소화하면서도 DB리소스를 최대한 활용할 수 있는 방법이다.    
   
**장점**  
* 레인지샤딩에 비해 데이터가 균일하게 분산된다.       
* Hash 크기는 Cluster 안에 있는 Node 개수로 정하게 된다.           
* 아주 간단한 Sharding 기법이다.   
     
**단점** : 
* DB를 추가 증설하는 과정에서 이미 적재된 데이터의 재정렬(ReSharding)이 필요하다.    
* Hash 크기가 변하면 기존 저장된 데이터의 정합성이 깨지기 때문이다.    
* 공간에 대한 효율은 고려하지 않았기에, 한쪽 샤딩에 크기가 큰 데이터만 몰려 들어갈 수 있다.  
     
## 다이나믹 샤딩 (레인지 샤딩)     

<img width="433" alt="thiiing-db-range-sharding" src="https://user-images.githubusercontent.com/50267433/146634893-5a838ce4-74ec-4ffa-8f62-14a3f7088007.png">
   
다이나믹(레인지) 샤딩은 PK의 범위를 기준으로 DB를 특정하는 방식이다.      
참고로 범위는 Locator Service(범위를 나타내는 테이블)이란 곳에 저장을 한다.  
  
**장점**
* 모듈러샤딩에 비해 기본적으로 증설에 재정렬 비용이 들지 않는다.        
  
**단점**   
* 일부 DB에 데이터가 몰릴 수 있다.    
* Locator Service에 문제가 생기면 전체 샤딩에 문제가 생긴다.   
* Data Relocation 을 하게 된다면, Locator Service의 Shard Key Table도 일치시켜줘야 한다.    
* Locator가 성능을 위해 Cache 하거나 Replication을 하면, 잘못된 Routing을 통해 데이터를 찾지 못하고 에러가 발생
* 전체적으로 보면, 로케이터에 의존할 수 밖에 없는 단점      

레인지샤딩의 가장 큰 장점은 증설작업에 드는 비용이 크지 않다는 점이기에     
데이터가 급격히 증가할 여지가 있다면 레인지방식을 선택하는 것도 좋다.       
            
주로 활성유저가 몰린 DB로 트래픽이나 데이터량이 몰릴 수 있다는 문제가 발생하는데       
기껏 분산처리를 했는데 이런 상황이 발생하면 또 다시 부하분산을 위해 해당 DB를 쪼개 재정렬하는 작업이 필요하다.   
반대로 트래픽이 저조한 DB는 통합 작업을 통해 유지비용을 아끼도록 관리해야 하기도 한다.      
  
# 엔티티 그룹      
   
![img (1)](https://user-images.githubusercontent.com/50267433/146794680-e8334da6-a4c0-4b37-a92f-e8b1f5f42cf1.png)    
   
RDBMS의 `join`, `index`, `transaction`을 사용함으로써 Application의 복잡도를 줄이는 효과 얻었다.      
그러나 앞선 샤딩 방식들은 Key-value 구조로 되어 있어 위와 같은 이점을 누리기에 제한적인 사항들이 많다.          
이러한 문제를 해결하기 위해  연관된 테이블도 함께 샤딩을해서 저장하는 즉, 객체들로 구성한 샤딩이 엔티티 그룹이다.                
     
정리하자면, 특정 단일 테이블에 대해서 샤딩을 하는 것이 아니라              
샤딩 대상이 될 테이블과 밀접한 연관이 있는 다른 테이블도 같이 샤딩하는 방식이다.      
      
**장점**
* 하나의 물리적인 Shard에 쿼리를 진행하다면 효율적이다.    
* 하나의 Shard 에 강한 응집도를 가질 수 있다.     
* 데이터는 자연스럽게 사용자별로 분리되어 저장된다.      
* 사용자가 늘어남에 따라 확장성이 좋은 파티셔닝이라고 보면 된다.     
  
**단점**  
* 크로스 파티션 쿼리는, 싱글 파티션 쿼리보다 동시성의 보장과 성능을 잃는다.     
* 그렇기 때문에 이런 쿼리들이 자주 실행되지 않도록 해주어야한다.    

# Pitfall  
> Logical Shard는 반드시 Single Node 안에 있어야 한다.   

* 다이나믹 샤딩을 진행하게 된다면 작업량을 효과적으로 줄일 수 있다.   
* 핫스팟을 찾고 샤딩을 진행한다.   
* 지속적으로 샤딩을 진행하게 된다면 가장 오른쪽 노드만 write을 진행하게 된다.   
* 나머지 Node들은 Read Performance가 향상하는 효과를 얻을 수 있다.  

# 샤딩(Sharding)의 한계

**샤딩의 대표적인 제약 사항**
* 두 개 이상의 샤드에 대한 JOIN 연산을 할 수 없다.
* auto increment 등은 샤드 별로 달라질 수 있다.
* last_insert_id() 값은 유효하지 않다.
* shard key column 값은 update하면 안된다.    
* 하나의 트랜잭션에서 두 개 이상의 샤드에 접근할 수 없다.   
  따라서, 샤딩을 사용할 때는 위와 같은 제약 사항에 문제가 되지 않도록 데이터 모델링을 하는 것이 중요하다.
    

# 정리하며
* Sharding을 피하는 방법을 우선 적용해보고 불가피하다면 적용하는게 좋습니다.
* 반드시 Trade-Off가 있습니다.
    * Locator와 Sync해야하는 비용이 필요합니다.
    * Cross-Partition Query가 발생할 경우 기존의 Query보다 느릴 수 있습니다.



