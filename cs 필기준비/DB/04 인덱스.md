# 인덱스 
지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것을 의미한다.       
          
저장된 데이터를 가지고 목차를 생성하기에,  
`save`, `update`, `delete `과정에서 다소 성능이 떨어질 수 있는데          
여기서 주의할 것은 update, delete 행위 자체가 느린것이지       
`update`, `delete`를 하기 위해 해당 데이터를 먼저 조회하는 과정은 인덱스가 있어 빠르게 처리할 수 있다.     
         
* **만약 인덱스가 없다면?:** 풀 테이블 스캔이 발생할 수 있다.(조회 자체는 가능하다)      
        
# 인덱스 내부 원리     
   
균형 트리는 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 벨런스를 맞추는 트리다.       
또한 정렬된 순서를 보장하고, 멀티레벨 인덱싱을 통한 빠른 검색을 할 수 있기 때문에 DB에서 사용하는 자료구조 중 한 종류이다.        
**MySQL의 인덱스인 클러스터드 인덱스와 보조 인덱스는 모두 내부적으로 균형 트리(B-Tree)로 이루어져있다.**          
           
군형트리에서 데이터가 저장되는 공간을 Node(노드)라고 하는데     
MySQL에서는 이를 **Page(페이지)** 라고 부르며 인덱스는 아래와 같은 구성요소들로 이루어져있다.     

* 루트(Root) 페이지
* 중간(Branch) 페이지
* 리프(Leaf) 페이지
 
## B-Tree    

![B트리 기본 형태](https://user-images.githubusercontent.com/50267433/146778097-4535d58e-66ca-4edd-a3a5-e1440153a344.png)
     
* 각 페이지의 key 와 자식 페이지를 가르키는 페이지번호를 가지고 있다.                  
* key들은 노드 안에서 항상 정렬된 값을 유지한다.(좌-작은값/우-큰값)               
* B트리의 경우, key마다 data를 가진다는 특성도 있다.               
* 페이지가 가득차게 된다면, 중간 값을 상위 페이지로 올리고 페이지 분할을 진행한다.    
   
## B+Tree  

![B플러스 트리 기본 형태](https://user-images.githubusercontent.com/50267433/146759659-21eee053-73db-45f4-ad3b-f1f682fac18e.jpeg)
   
* B-tree와 달리, **리프 노드를 제외한 페이지들의 Key는 데이터를 담아두지 않는다.**      
  즉, 인덱스 Key의 값이 줄어들어 페이지에는 보다 많은 데이터를 담을 수 있게 되었고 트리의 높이는 더 낮아진다.(cache hit를 높일 수 있음)    
* 풀 테이블 스캔 시, **B+tree는 리프 노드에 데이터가 모두 있고 리프 노드들은 더블 링크드 리스트로 연결되어 있다.**             
  즉, 한 번의 선형탐색만 하면 원하는 범위의 데이터를 빠르게 얻을 수 있다(B-tree의 경우에는 모든 노드를 확인해야 한다.)         
* MySQL 5.5 이후부터 InnoDB를 기본 엔진으로 사용하면서 B+tree 를 채택했다.   
      
## Red-Black Tree가 사용되지 않는 이유  

![img](https://user-images.githubusercontent.com/50267433/146783916-71ec428d-7c03-4f0a-be48-22f20c9d5900.png)

Red-Black Tree는 기본적으로 하나의 페이지에 무조건 하나의 데이터만을 넣을 수 있다.      
반면에 B-Tree는 하나의 노드 내에 여러 데이터를 저장할 수 있다.          

만약, Red-Black Tree로 설정했을 경우, 참조해서 여러 페이지를 깊게 들어가야했을 것이다.       
더불어, B-Tree는 실제 메모리 상에 배열처럼 차례대로 저장이 되어있서,           
다른 페이지를 찾기 위한 연산을 하는 Red-Black Tree 보다 물리적인 메모리 처리에서 더 빠른 퍼포먼스를 보여준다.    
  
## 페이지 분할 
        
앞서, 인덱스가 SELECT 성능을 올려주되 SAVE, UPDATE, DELETE 성능을 다소 감소시킨다 했다.           
그 이유는 바로 균형트리의 페이지 분할 기법 때문에 발생하는 트레이드 오프이기 때문이다.       
페이지 분할은, 중간값을 상위 페이지로 올리는데 상위 페이지 또한 가용범위를 넘을 경우 분할 작업을 진행한다.      

![image](https://user-images.githubusercontent.com/50267433/146757493-f954d62f-0451-4927-9f36-f744aafd4302.png)   

데이터를 저장한다고 가정했을 때, 페이지의 가용범위를 넘지 않으면 큰 이슈가 발생하지 않는다.   

![image](https://user-images.githubusercontent.com/50267433/146729229-8da1c9de-7a02-4f4a-b76b-1eb74eec547b.png)

그러나 페이지의 가용범위를 넘게 된다면 새로운 페이지를 만들고 기존 페이지의 데이터를 재분류하는 페이지 분할 작업을 진행해야한다.   
이는 데이터의량과도 관련이 있는데, 데이터량이 많으면 영향을 받는 페이지들 또한 많기 때문에 시간이 보다 오래걸린다.         

## 데이터 페이지    
![146731489-8078aae3-7c70-4e9d-9808-218743b5438a](https://user-images.githubusercontent.com/50267433/146748655-ab76db44-1963-4543-b534-91d5bad6f1d9.png)
             
테이블에 데이터를 저장하면 **데이터 페이지**라는 곳에 저장이 된다.       
데이터 페이지는 인덱스 페이지와 달리, 실제 데이터가 저장된 자료 구조이다.    
    
클러스터드 인덱스가 존재하지 않을 경우 입력된 순서대로 데이터를 저장하지만      
클러스터드 인덱스가 존재할 경우 클러스터드 인덱스를 기준으로 재정렬한다.              
               
**MySQL의 페이지는 innoDB 기준 16KB로 크기가 설정 되어있다.**      
      
* 만약, `인덱스의 키의 크기를 16 Byte`, `자식노드의 주소가 담긴 크기가 12 Byte`로 설정한다면?              
* `16*1024 / (16+12) = 585`로 인해 하나의 페이지에는 585개가 저장될 수 있다.               
* 만약, 인덱스 키를 32 Byte로 증가시키면 하나의 페이지에는 372개가 저장될 수 있다.                 
* 즉, 인덱스 키의 크기가 클 수록 생성되는 페이지 수가 많아지고 이는 역으로 읽는 속도가 저하된다는 이슈가 있다.  
      
보조 인덱스의 경우, 리프 노드의 value 값이 데이터 페이지에 대한 참조값이다.(`데이터페이지의 페이지번호+데이터 순서`)        
반면에 클러스터드 인덱스의 경우, 리프 노드가 곧 데이터 페이지여서 보조 인덱스보다 페이지를 찾는 횟수가 적다.        
더불어, 인덱스가 데이터를 가지고 있다는 특징을 이용해서 실제 데이터에 접근안하고 값을 가져오는 커버링 인덱스도 있다.      
(가장 큰 성능 저하를 일으키는 부분은 인덱스를 검색하고 대상이 되는 row의 나머지 컬럼값을 데이터 블록에서 읽을 때다.)    

# 인덱스 종류    
   
1. 클러스터드 인덱스  
2. 보조 인덱스    

## 클러스터드 인덱스
## 보조 인덱스   
## 사실은...  

![Uploading 999315505E4933DF02.png…]()


# 인덱스 종류    
