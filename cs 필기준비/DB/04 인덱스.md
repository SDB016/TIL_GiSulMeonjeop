# 인덱스 
지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것을 의미한다.       
          
저장된 데이터를 가지고 목차를 생성하기에,  
`save`, `update`, `delete `과정에서 다소 성능이 떨어질 수 있는데          
여기서 주의할 것은 update, delete 행위 자체가 느린것이지       
`update`, `delete`를 하기 위해 해당 데이터를 먼저 조회하는 과정은 인덱스가 있어 빠르게 처리할 수 있다.     
         
**만약 인덱스가 없다면?**             
* 최악의 경우 풀 테이블 스캔이 발생할 수 있다.(조회 자체는 가능하다)      
        
# 인덱스 내부 원리     
## 균형트리 B-Tree 와 B+Tree  
     
균형 트리는 땡땡땡한 자료구조이다.       
그리고 MySQL의 인덱스인 **클러스터드 인덱스와 보조 인덱스는 모두 내부적으로 균형 트리(B-Tree)로 이루어져있다.**       
      
군형트리에서 데이터가 저장되는 공간을 Node(노드)라고 하는데     
MySQL에서는 이를 **Page(페이지)**라고 부르며 인덱스는 아래와 같은 페이지 구성요소들로 이루어져있다.     

* 루트(Root) 페이지
* 중간(Branch) 페이지
* 리프(Leaf) 페이지
  
루트 페이지와 중간 페이지는 **`인덱스 기준이 되는 컬럼이 Key`로 `페이지 번호가 Value`로 들어가있다.**       
리프 페이지는 



## 데이터 페이지    
![146731489-8078aae3-7c70-4e9d-9808-218743b5438a](https://user-images.githubusercontent.com/50267433/146748655-ab76db44-1963-4543-b534-91d5bad6f1d9.png)
           
테이블에 데이터를 저장하면 위와 같이 특정 자료구조에 데이터가 저장된다.              
그리고 이렇게 데이터가 저장되는 공간을 **데이터 페이지**라고 부른다.                  
     
데이터 페이지의 경우, 클러스터드 인덱스가 존재할 경우 인덱스를 기준으로 재정렬한다.        
반대로 클러스터드 인덱스가 존재하지 않을 경우 입력된 순서대로 데이터가 들어가있다.              
          
**MySQL의 페이지는 innoDB 기준 16KB로 크기가 설정 되어있다.**      
      
* 만약, `인덱스의 키의 크기를 16 Byte`, `자식노드의 주소가 담긴 크기가 12 Byte`로 설정한다면?              
* `16*1024 / (16+12) = 585`로 인해 하나의 페이지에는 585개가 저장될 수 있다.               
* 만약, 인덱스 키를 32 Byte로 증가시키면 하나의 페이지에는 372개가 저장될 수 있다.                 
* 즉, 인덱스 키의 크기가 클 수록 생성되는 페이지 수가 많아지고 이는 역으로 읽는 속도가 저하된다는 이슈가 있다.  








# 인덱스 종류 
  
인덱스의 종류는 크게 2가지로 나뉘어져있다.  
   
1. 클러스터드 인덱스  
2. 보조 인덱스    

## 클러스터드 인덱스
## 보조 인덱스   

이 두개는 강의를 보고 

# 참고 

기존 MyISAM이 MySQL의 기본 엔진이었다면 MySQL 5.5부터는 InnoDB가 기본 엔진으로 변경됨   



# 당근마켓에서 코틀린을 도입하고 장단점 
      
**선택한 이유 :**      
1. 코틀린 언어적 간결성 + 트랜드  

## 권용권님이 생각한 얻은 3가지 장점  

* 자바와의 상호 운용성에 초점을 맞춘 실용적이고 간결하며 안전한 언어이다.  

**코틀린의 철학**
1. 언어의 간결성
    1. 키워드(data)
    2. 풍부한 API 
    3. 단일표현 함수는 식으로 정의 가능     
    * 가독성과 생산성을 높여준다.   
2. 안정성 
    1. NullSafety 하므로, NPE 발생을 방지한다.(NPE한 코드로 유도한다)   
    2. 타입 검사와 캐스트가 한 연산자에 이루어지며, ClassCastException 을 방지한다.  
    3. when 사용시, break가 없어도 되며 열거형/sealed 사용하면 모든 값이 평가되었는지 확인 가능(else도 사용x)   
    4. 그리고 이 모든게 컴파일 타임에서 지원을 해줘서 생산성 + 안정성에 좋다.  
     
2021년도에 다시 만나다

**그만 널 잊으려고**  
* 널러블 타입 ? 을 사용하면 무조건 널 검사를 해야하고 그렇지 않으면 컴파일 타임에서 알 수 있다.     
* 안전한 호출 연산자 `?.` : 널이 아니면 메서드/프로퍼티 호출      
* 엘비스 연산자 `?:` : 널인 경우 호출 구문 작성      
* 널 아님 단언 `!!` : 널 아님을 단언, 단 널일 경우 NPE 발생   
   
**다 놀았니? 이제 할일 하자**      
* 식 -> 값을 만들어 낼 수 있느것이며 다른 하위 요소로 참여 가능하다.       
* 문 -> 블록의 최상위 요소로, 값을 만들어내지 않는다.         
* 자바와 달리 코틀린은 loop 를 제외한 모든 요소가 식이다 -> 코드가 간결해진다.     
    
**봉인해서 까먹지 않기**       
* when 을 통해서 분기 처리할 수 있다.      
* sealed 나 enum 을 사용하면, else를 사용하지 않고도 처리할 수 있다.      
* 뿐만 아니라 is/as 를 통해서 특정 타입으로 캐스팅 + else 로직을 없앨 수도 있다.    
* sealed 는 동일 패키지 내에 존재하는 하위 클래스들만 상속을 보장한다.     
   
**오버하지마**     
* 이름붙인 인자(namedParameter) -> 인자 순서에 자유로워 지고, 명확해진다.     
* 기본 인자 -> 디폴트 값을 주어, 확장에 유연하다, 이름붙인 인자를 같이 이용하면 생성자 오버로딩을 하지 않아도 된다.     
* 익명클래스/람다의 사용 대신`{}` => `{}`만 이용하면 손쉽게 개발 가능 => it를 이용하여 람다 인자 없앨수 있음        

**너의 이름은 함수타입**   
* 코틀린의 함수는 일급 시민이여서 함수 자체를 넘길 수 있다.   

**품행제로(컨벤션)**    
* 자바 라이브러리 사용 자제 
* 콜론은 한 칸 뛰고 
* 세미콜론 사용 X 
* 메서드 닫는 블록과 클래스 닫는 블록은 붙여서 작성   

### 표현력이 풍부한 아이 
#### 뭣이 중헌디   
1. 스코프 함수로 가독성 높이기  
    * let   
    * apply      
    * run    
2. 확장 함수 
    * 클래스 밖에 선언되었지만, 멤버함수처럼 함수    
    * 기존에 존재하는 변경 불가능한 라이브러리에 추가할 수 있다.   
3. 할 일만 간결하게
4. 너니까 너답게 
     * 테스트 코드 작성때, @Autowired가 필요하다. 근데 여러개라면?   
         * `@TestConstructor(autowireMode..)`  
     * MockMvcTest 
         * DSL을 이용하면 목적에 드러나게 코드 작성이 가능하다.   
    
