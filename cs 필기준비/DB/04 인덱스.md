# 인덱스 
지정한 컬럼들을 기준으로 메모리 영역에 일종의 목차를 생성하는 것을 의미한다.       
         
저장된 데이터를 가지고 목차를 생성하기에, `save`, `update`, `delete `과정에서 다소 성능이 떨어질 수 있는데        
여기서 주의할 것은 update, delete 행위 자체가 느린것이지     
`update`, `delete`를 하기 위해 해당 데이터를 먼저 조회하는 과정은 인덱스가 있어 빠르게 처리할 수 있다.     
         
**만약 인덱스가 없다면?**             
* 최악의 경우 풀 테이블 스캔이 발생할 수 있다.(조회 자체는 가능하다)      
    
# 인덱스 내부 원리(데이터 페이지와 분할)     

![146731489-8078aae3-7c70-4e9d-9808-218743b5438a](https://user-images.githubusercontent.com/50267433/146748655-ab76db44-1963-4543-b534-91d5bad6f1d9.png)
           
테이블에 데이터를 저장하면 위와 같이 특정 자료구조에 데이터가 저장된다.              
그리고 이렇게 데이터가 저장되는 공간을 **데이터 페이지**라고 부른다.                  
     
데이터 페이지의 경우, 클러스터드 인덱스가 존재할 경우 인덱스를 기준으로 재정렬한다.        
반대로 클러스터드 인덱스가 존재하지 않을 경우 입력된 순서대로 데이터가 들어가있다.              
        
MySQL의 페이지는 innoDB 기준 16KB로 크기가 설정 되어있다.   
    
* 만약, `인덱스의 키의 크기를 16 Byte`, `자식노드의 주소가 담긴 크기가 12 Byte`로 설정한다면?       
* `16*1024 / (16+12) = 585`로 인해 하나의 페이지에는 585개가 저장될 수 있다.         
* 만약, 인덱스 키를 32 Byte로 증가시키면 하나의 페이지에는 372개가 저장될 수 있다.           
* 조회 결과로 500개의 row를 읽는다 가정하면, 인덱스 키가 클수록 페이지 수가 많아진다.    

# 인덱스 종류 
  
인덱스의 종류는 크게 2가지로 나뉘어져있다.  
   
1. 클러스터드 인덱스  
2. 보조 인덱스    

## 클러스터드 인덱스



## 보조 인덱스   
