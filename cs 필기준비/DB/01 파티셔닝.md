# 개요 
서비스 규모가 커지고 DB에 저장하는 데이터의량 또한 대용량 되면     
기존 DBMS의 용량(Storage)의 한계와 성능의 저하를 가져온다.           
        
`VLDB` 즉 하나의 RDBMS에 너무 큰 테이블이 들어가면 용량과 성능 측면에서 많은 이슈가 발생하게 되는데      
이러한 이슈를 해결하기 위해, **파티션**이라는 작은 단위로 나누어 관리하는 **파티셔닝 기법을 사용하면 된다.**      
    
# 파티셔닝           
> 하나의 논리적인 테이블이지만 물리적으로 데이터들을 여러 파티션(테이블)로 나눠서 저장하는 기법    
       
하나의 논리적인 테이블을 다수의 물리적인 파티션(테이블)로 나누어 관리하는 방법을 의미한다.                             
물리적인 데이터 분할이 있더라도 하나의 논리적인 테이블이기 때문에 애플리케이션은 이를 인식하지 못한다.         
       
# 목적   
* **가용성 :**     
    * 여러 파티션으로 분리했기에 전체 데이터에 대한 훼손 가능성을 줄여 데이터 가용성 향상시킨다.         
* **관리 용이성 :**    
    * 큰 테이블을 제거하고 각각의 작은 테이블로 나누었기에 관리를 쉽게 한다.      
* **성능 :**     
    * 특정 DML과 Query의 성능을 향상시킨다.       
    * 주로 대용량 Data Writer 환경에서 효율적이다.        
        * 많은 insert가 있는 OLTP(트랜잭션) 시스템에서 Insert 작업들을 분리된 파티션들로 분산시켜 결합을 줄인다.      
        * 트랜잭션이 하나의 테이블이 아닌, 여러 분산된 파티션(테이블)에서 동시에 사용할 수 있으므로          
   
# 파티셔닝 고려할점   
  
데이터들이 고르게 분산되어야함    
* 특정 파티션에만 부하가 생기는 핫스팟을 방지해야한다.     
    
# 장단점
## 장점 
1. 관리적 측면 :   
    * 전체 데이터를 손실할 가능성이 줄어들어 가용성이 향상된다.    
    * 파티션(테이블)별로 백업 복구가 가능하다.   
    * 파티션 단위로 I/O 분산이 가능하여 Update 성능을 향상시킨다.    
2. 성능적 측면 : 
    * 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가한다.   
        * 즉, Full Scan 에서의 데이터 Access의 범위를 줄여 성능 향상을 가져온다.   
        * 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.(슬로우 쿼리X)  
     
이 외에도, 로그성 데이터들 같은 경우 따로 파티션 테이블로 두어 1~2년 동안 보관하다고 파티션 자체를 날리면 된다.     
  
## 단점     
1. 여러 파티션(테이블)로 분리되었으므로 테이블간의 JOIN 비용이 증가한다.         
2. 테이블과 인덱스를 별도로 파티션할 수 없기 때문에, 필요시 인덱스도 같이 파티셔닝해야 한다.          
        
# DB 파티셔닝의 종류  
  
1. 수평 파티셔닝     
2. 수직 파티셔닝   
   
## 수평 파티셔닝
   
**개념**       
* 행을 기준으로 하나의 테이블을 여러 파티션으로 분할시키는 것이다.          
            
**특징**    
* 퍼포먼스, 가용성을 위해 `파티셔닝 컬럼 키` 기반으로 여러 곳에 분산 저장한다.           
* 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미한다.               
  
**장점**   
* 데이터의 개수를 기준으로 나누어 Partitioning한다.   
* 데이터의 개수가 작아지고 따라서 index의 개수도 작아지게 된다. 자연스럽게 성능은 향상된다.    
     
**단점**     
* 서버간의 연결 과정이 많아진다.    
* 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가하게 된다.   
* 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다.    

**장단점**    
* 장점 : 
    * 데이터의 개수를 기준으로 나누어 파티셔닝한다.  
    * 데이터의 개수가 작아지고 따라서 index의 개수도 작아지게 된다.(자연스럽게 성능은 향상) 
* 단점 : 
    * 서버간의 연결 과정이 많아진다.  
    * 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가하게 된다.  
    * 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다.  

## 수직 파티셔닝 

**개념**   
* 특정 칼럼들을 쪼개서 별도의 테이블로 분할하는 것을 의미한다.           
       
**특징**       
1. 3정규화와 비슷하지만, 수직 파티셔닝은 이미 정규화된 분리하는 과정이다.       
2. OneToOne 으로 쪼개는 작업과도 비슷하다고 이해해도 좋을 것 같다.     
     
**장단점**   
* 장점 :  
    * 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.     
    * 한 테이블을 SELECT하면 결국 모든 컬럼을 메모리에 올리게 되므로   
      필요없는 컬럼까지 올라가서 한번에 읽을 수 있는 ROW가 줄어든다.    
      이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.     
    * 같은 타입의 데이터가 저장되기 때문에 저장시 데이터 압축률을 높일 수 있다.   
       
# 파티셔닝 분할 기준       
* **파티셔닝 컬럼 키를 사용한다.**   
   
## Range 파티셔닝 
   
* 범위, 연속적인 숫자나 날짜를 기준으로 파티셔닝한다.    
* EX) 날짜(년/월/일), 우편번호, 4분기 등등  

## List 파티셔닝 
   
* 특정 주제를 기반으로 파티셔닝한다.     
* 분포도가 비슷하며, 많은 SQL에서 해당 Column의 조건이 많이 들어오는 경우 유용하다.      
* 특정 파티셔닝에 저장될 Data에 대한 명시적 제어가 가능하다.    
* Multi-Column Partition Key 제공이 힘들다.        
* EX) 아시아-{한국, 일본, 중국} / 북유럽-{노르웨이, 스웨덴, 핀란드}    

## hash 파티셔닝
     
* 해시 함수의 값에 따라 파티셔닝한다.            
* 랜덤으로 파티셔닝한다고 생각을 해도 된다.      
  
## composite 파티셔닝(결합) 
* 2개 이상의 파티션 컬럼 키로 결합하는 것이다.           
* 파티션을 나누는 기준이 2개가 되는 만큼, 파티션의 개수가 뻥튀기 된다.(주 파티션의 개수 * 서브 파티션의 개수)     
* 인덱스 경합이 너무 심해서 꼭 나눠야하는 상황이 아닌 이상 지양한다.    
    
# 파티션 프루닝  
     
* 읽지 않아도 되는 파티션은 접근하지 않는 기술이다.    
* 하드파싱이나 실행 시점에서 SQL 조건절을 분석하여 불필요한 파티션 세그먼트를 액세스 대상에서 제외 시키는 기능     
* 옵티마이저가 적절히 프루닝을 실행한다.    
  
# 인덱스 파티션 
## 로컬 파티션 인덱스

* 테이블 파티션 키 컬럼 기준을 똑같이 따라간다.(나뉘는 기준 동일)     
* 즉테이블 파티션 갯수만큼 똑같이 인덱스 파티션도 생성된다.  

오라클의 경우, 테이블의 파티션 구조가 바뀐다거나 파티션이 삭제가 된다거나 했을때도 관리    
   
## 비파티션 인덱스
   
* 테이블은 파티션으로 나뉘어져 있지만 인덱스는 하나로 사용하는 것   

## 글로벌 파티션 인덱스 
  
* 테이블처럼 인덱스로 파티션으로 나뉘어져잇지만, 테이블과 무관하게 파티션이 구성되어있는 것   














