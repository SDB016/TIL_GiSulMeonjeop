# 개요 
서비스 규모가 커지고 DB에 저장하는 데이터의량 또한 대용량 되면     
기존 DBMS의 용량(Storage)의 한계와 성능의 저하를 가져온다.           
        
`VLDB` 즉 하나의 RDBMS에 너무 큰 테이블이 들어가면 용량과 성능 측면에서 많은 이슈가 발생하게 되는데      
이러한 이슈를 해결하기 위해, **파티션**이라는 작은 단위로 나누어 관리하는 **파티셔닝 기법을 사용하면 된다.**                 
# 개념          
> 하나의 논리적인 테이블이지만 물리적으로 데이터들이 여러 파티션으로 나뉘어져서 저장 
   
하나의 논리적인 테이블을 다수의 물리적인 파티션으로 나누어 관리하는 방법을 의미한다.                         
물리적인 데이터 분할이 있더라도 하나의 논리적인 테이블이기 때문에 애플리케이션은 이를 인식하지 못한다.      
    
## 목적 
* **가용성 :**   
    * 여러 파티션으로 분리했기에 전체 데이터에 대한 훼손 가능성을 줄여 데이터 가용성 향상시킨다.       
* **관리 용이성 :**  
    * 큰 테이블을 제거하여 관리를 쉽게 한다.     
* **성능 :**   
    * 특정 DML과 Query의 성능을 향상시킨다.     
    * 주로 대용량 Data Writer 환경에서 효율적이다.      
    * 많은 insert가 있는 OLTP 시스템에서 Insert 작업들을 분리된 파티션들로 분산시켜 결합을 줄인다.

## 장점 
    
1. 관리적 측면 :   
    * 전체 데이터를 손실할 가능성이 줄어들어 가용성이 향상된다.    
    * 파티션별로 백업 복구가 가능하다.   
    * 파티션 단위로 I/O 분산이 가능하여 Update 성능을 향상시킨다.   
2. 성능적 측면 : 
    * 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가한다.   
        * 즉, Full Scan 에서의 데이터 Access의 범위를 줄여 성능 향상을 가져온다.   
        * 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.(슬로우 쿼리X)  
 
## 단점   
1. 테이블간의 JOIN 비용이 증가한다.      
2. 테이블과 인덱스를 별도로 파티션할 수 없기 때문에, 인덱스도 같이 파티셔닝해야 한다.        
       
# DB 파티셔닝의 종류  
## 수평 파티셔닝
  
하나의 테이블의 각 행을 다른 테이블에 분산시키는 것이다.   
    
**개념**    
1. 스키마를 복제한 후 샤드키를 기준으로 데이터를 나누는 것을 말한다.          
2. 즉, 스키마가 같은 데이터를 2개 이상의 테이블에 나누어 저장한다.    
 
**특징**  
1. 퍼포먼스, 가용성을 위해 Key 기반으로 여러 곳에 분산 저장한다.      
2. 일반적으로 분산 저장 기술에서 파티셔닝은 수평 분할을 의미한다.      
3. 보통 수평 분할을 한다고 했을 때는 하나의 데이터베이스 안에서 이루어지는 경우를 지칭한다.   

**예시**   
1. (레인지) : 고객의 데이터를 샤딩하자 
    1. 고객의 데이터 2만개 
    2. 0~10000번 고객, 샤드1에 저장   
    3. 10000~20000번 고객, 샤드2에 저장   
    4. DBA는 데이터 엑세스 패턴과 저장 공간 이슈(로드의 적절한 분산, 데이터의 균등한 저장)를 고려하여 적절한 샤드키를 결정한다.   
2.(리스트) : 같은 주민 데이터를 처리하기 위해 스키마가 같은 `서현동 주민 테이블`, `정자동 주민 테이블`을 사용한다.      
    1. 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것  

**장단점**    
* 장점 : 
    * 데이터의 개수를 기준으로 나누어 파티셔닝한다.  
    * 데이터의 개수가 작아지고 따라서 index의 개수도 작아지게 된다.(자연스럽게 성능은 향상) 
* 단점 : 
    * 서버간의 연결 과정이 많아진다.  
    * 데이터를 찾는 과정이 기존보다 복잡하기 때문에 latency가 증가하게 된다.  
    * 하나의 서버가 고장나게 되면 데이터의 무결성이 깨질 수 있다.  

## 수직 파티셔닝 

테이블의 일부 열을 빼낸 형태로 분할한다.   

**개념**   
1. 모든 칼럼들 중 특정 칼럼들을 쪼개서 따로 저장하는 형태를 의미한다.       
2. 스키마를 나누고 데이터가 따라 옮겨가는 것을 말한다.(운영중에 가능한가?)            
3. 하나의 엔티티를 2개 이상으로 분리하는 작업이다.     
  
**특징**      
1. 3정규화와 비슷하지만, 수직 파티셔닝은 이미 정규화된 분리하는 과정이다.    
2. OneToOne 으로 쪼개는 작업과도 비슷한 것 같다.    
   
**장단점**   
* 장점 :  
    * 자주 사용하는 컬럼 등을 분리시켜 성능을 향상시킬 수 있다.     
    * 한 테이블을 SELECT하면 결국 모든 컬럼을 메모리에 올리게 되므로   
      필요없는 컬럼까지 올라가서 한번에 읽을 수 있는 ROW가 줄어든다.    
      이는 I/O 측면에서 봤을 때 필요한 컬럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.     
    * 같은 타입의 데이터가 저장되기 때문에 저장 시 데이터 압축률을 높일 수 있다.   
       
# 파티셔닝 분할 기준   
DBMS는 분할에 대한 각종 기준을 제공하고 있으며 **분할은 분할 키를 사용한다.**         
즉, 각각의 파티션을 나누는 기준인 분할키에 대해서 알아보고자 한다.     
예를 들어 분할키가 `월`이면, 1월 파티션 - 1월 분할키/ 2월 파티션 -2월 분할키 이런식이다.     

## Range 파티셔닝 

* 연속적인 숫자나 날짜를 기준으로 파티셔닝한다.   
* 손쉬운 관리 기법 제공에 따른 관리 시간의 단축할 수 있다.
* EX) 날짜(년/월/일), 우편번호, 4분기 등등  

## List 파티셔닝 

* 특정 군집화의 조건을 분할키로 세우고, 알맞는 데이터들을 넣어둔다.   
* EX) 아시아-{한국, 일본, 중국} / 북유럽-{노르웨이, 스웨덴, 핀란드}
* 분포도가 비슷하며, 많은 SQL에서 해당 Column의 조건이 많이 들어오는 경우 유용하다.  
* 특정 파티셔닝에 저장될 Data에 대한 명시적 제어가 가능하다. 
* Multi-Column Partition Key 제공이 힘들다.   

## hash 파티셔닝

* 해시 함수의 값에 따라 파티션에 포함할지 여부를 결정한다.   
* 4개의 파티션으로 분할하는 경우 해시함수는 0-3 정수를 돌려준다.
* 키 컬럼을 hash()에 대입해서 어떤 파티션에 저장을 하지 정의  

## composite 파티셔닝(결합) 
* 상기 기술들을 결합하는 것으로 분할 요소들을 결함하는 것이다.   
* 컨시스턴트 해시법은 해시 분할 및 목록 분할의 합성으로 간주될 수 있고 키 공간을 해시 축소함으로써 일람할 수 있게 한다.   
* 파티션을 나누는 기준이 2개가 되는 만큼, 파티션의 개수가 뻥튀기가 됨 
* 주 파티션의 개수 * 서브 파티션의 개수 
* 인덱스 경합이 너무 심해서 꼭 나눠야하는 상황이 아닌 이상 지양한다.  

## 그럼 이렇게 나누면 어떻게 찾아?  

파티션 프루닝 :  
* 하드파싱이나 실행 시점에서 SQL 조건절을 분석하여   
  읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외 시키는 기능  
* 쉽게 설명하면, 읽지 않아도 되는(조회 대상이 없는) 파티션은 접근하지 않는 기술이다.   

위 같은 이유로, 서버 부하나 속도에 유리하다.   
또한, 로그성 데이터들 같은 경우 따로 파티션 테이블로 두어 1~2년 지나고 날리면 된다.   
이때는 리스트 파티셔닝으로 '로그'파티션을 따로 나누면 되지 않을까 생각한다.

# 인덱스 파티션 
## 로컬 파티션 인덱스
> 가장 많이 사용 

테이블 파티션 키 컬럼 기준을 똑같이 따라간다.     
즉, 테이블 파티션 갯수만큼 똑같이 인덱스 파티션도 생성된다.(나뉘는 기준도 동일)  

단, 테이블의 파티션 구조가 바뀐다거나 파티션이 삭제가 된다거나 했을때도   
인덱스 재 생성 필요없이 오라클에서 자동으로 관리해준다.     

## 비파티션 인덱스

테이블은 파티션으로 나뉘어져 있지만     
인덱스는 통짜로 하나로 관리하는것(인덱스 파티션 안함)   

## 글로벌 파티션 인덱스 

테이블처럼 인덱스로 파티션으로 나뉘어져잇지만, 테이블과 무관하게 파티션이 구성되어있다.   

# 파티셔닝 고려할점 

각 파티션에 데이터들이 고르게 분산이 될 수 있도록 키 컬럼과 타입을 설정해주어야 한다.   
그래야지 우리가 특정 파티션에만 부하가 생기는 일이 발생하지 않게끔 해야한다.   
  
인스타 그램이나 트위터는 이 같은 영역에서 좀 신기한데     
일론 머스크의 트윗을 예로 설명하면 몇억명이 팔로우하는데 이 알람기능을 어떻게 처리할 것이냐도 문제   
아니 여긴 파티션을 어떻게 처리하냐 












