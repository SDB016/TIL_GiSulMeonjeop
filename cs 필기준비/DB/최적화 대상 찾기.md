# DB 최적화 대상 
 
DB에서 최적화를 할 부분은 아래 3가지이다.     
 
1. Client 
2. DataBase Engine
3. FileSystem

## Client(Application)  

* 복수의 레코드를 한번의 호출로 집합 처리하거나, 
  두개 이상의 쿼리를 한 쿼리로 통합 처리함으로써 호출 수를 줄일 수 있다.  
* JDBC Statement는 `쿼리 문장 분석`, `컴파일`, `실행`의 단계를 캐싱한다.
  JDBC PreParedStatement 는 처음 한번만 세단계를 거친후 캐시에 담아서 재사용한다.  
* DB Connetion Pool 을 사용하여 객체를 생성하는 부분에서 발생하는 대기시간을 줄이고, 네트워크 부담을 줄일 수 있다.   
* FetchSize를 조정하거나 Paging을 활용한다.    
  
## DataBase Engine

* 파일시스템에 저장된 데이터가 조회되면,  
  해당 데이터를 메모리에 저장해 이후 동일 데이터 조회시 파일 시스템의 물리적인 입출력이 발생하지 않도록 한다.(캐싱)  
* 서버 파라미터를 튜닝한다.  
 
## FileSystem  
* HDD 대신, SDD를 사용한다.     
* SQL을 최적화하면 필요 이상의 데이터 블록을 읽는 것을 방지합니다.    
  즉, SQL 튜닝이란 읽는 블록수를 줄여주는 것을 의미한다.   

# SQL 최적화 대상  

## 쿼리 동작 방식 

1. Query Caching 
2. Parsing 
3. Preprocessor
4. Optimization 
5. Handler(Storage Engine) 

### Query Caching 
> SQL문이 Key, 쿼리의 실행결과가 Value인 Map     
  
SQL문을 키값으로 실행 결과를 Value로 저장하여 캐싱하는 방식이다.  
    
* 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?      
* 해당 사용자가 그 결과를 볼 수 있는 권한이 있는가?    
* 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?  
* 호출 시점에 따라 결과가 달라지는 요소가 있는가? (랜덤/현재값)     
* 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가  
* 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?  

### Parsing 
  
사용자로부터 요청된ㄷ SQL을 잘게 쪼개서 서버가 이해할 수 있는 수준으로 분리한다.  

### Preprocessor

해당 쿼리가 문법적으로 틀리지 않은지 확인하여 부정확하다면 여기서 처리를 중단한다.    
(일괄 처리일 경우, 일괄 처리 전체를 취소한다.)    

### Optimization 
Explain(실행 계획)이란 것도 존재하는데, 이 단계에서의 출력을 의미한다.   
     
* 쿼리 분석: Where 절의 검색 조건인지 Join 조건인지 판단한다.      
* 인덱스 선택 : 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정한다.    
* 조인 처리 : 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정한다.  
 
### Handler(Storage Engine)   
MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고, 디스크로부터 읽어오는 역할을 담당한다.     
MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.   


