# 개요 
대부분의 경우, `인덱스를 설계 == WHERE절에 대한 인덱스 설계`로 바라보지만      
실은 쿼리 전체(SELECT, WHERE, ORDER BY, GROUP BY 등)에 대해 인덱스 설계가 필요하다.         
   
MySQL의 경우에는 인덱스와 함께 데이터를 저장하고 있는데      
조건을 비교하고, 그룹핑하고, 조회하려는 타켓 모두가 인덱스에 있다면 실제 데이터까지 접근할 필요가 전혀 없다.        
이를 쉽게 설명하면, **쿼리를 구성하는 컬럼들이 모두 인덱스 안에 있다면 인덱스로부터만 데이터를 가져오면 된다.**          
    
# 커버링 인덱스 
     
커버링 인덱스란, 쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스를 말한다.      
인덱스는 테이블의 다수의 컬럼을 이용하여 생성할 수 있는데, 쿼리의 컬럼들이 인덱스에 모두 속한 경우를 말한다.   

## 준비물 

```sql
CREATE TABLE PERSON(
    `id` BIGINT NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(256) NOT NULL, 
    `age` BIGINT NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
)
```
* PERSON 테이블을 생성한다.    
* PK를 만들면서 자동적으로 id 클러스터드 인덱스가 생성된다.     

```sql
INSERT INTO PERSON VALUES(1, 'USER1', 21);
INSERT INTO PERSON VALUES(2, '2USER', 22);
INSERT INTO PERSON VALUES(3, 'U3SER', 31);
```
* 데이터를 입력한다.  

```sql
CREATE INDEX IDX_NAME ON PERSON(name)
```

* 예제를 위해서 논 클러스터드 인덱스(name 인덱스)또한 만들어주자    

# 기본 조회 
   
실행 계획의 요소들이 궁금하다면 필자가 정리해놓은 [explain 정리 글](https://github.com/kwj1270/TIL_GiSulMeonjeop/blob/master/cs%20%ED%95%84%EA%B8%B0%EC%A4%80%EB%B9%84/DB/Explain.md) 을 참고하면 된다.   
   
## 전체 조회  

```sql
EXPLAIN SELECT * FROM PERSON
```  
|id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|
|--|------------|-----|---------|----|-------------|----|------|---|----|--------|-----|
|1 | SIMPLE|PERSON|NULL|ALL|NULL|NULL|NULL|NULL|3|100.00|NULL|


* 이무런 인덱스도 타지 않았다.    

## id 조회, id 검색  

```sql
EXPLAIN SELECT PERSON.id FROM PERSON WHERE PERSON.id = 1
```

|id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|
|--|------------|-----|---------|----|-------------|----|------|---|----|--------|-----|
|1|SIMPLE|PERSON|NULL|const|PRIMARY|PRIMARY|8|const|1|100.00|Using index|
     
* 기존에 만들었던 PRIMARY 클러스터드 인덱스를 탔다.          
* EXTRA 의 값이 `Using index`는 점이고 이는 커버링 인덱스를 탔다는 뜻이다.       
  
## name 조회, id 검색 

```sql
EXPLAIN SELECT PERSON.name FROM PERSON WHERE PERSON.id = 1
```

|id|select_type|table|partitions|type|possible_keys|key|key_len|ref|rows|filtered|Extra|
|--|------------|-----|---------|----|-------------|----|------|---|----|--------|-----|
|1|SIMPLE|PERSON|NULL|const|PRIMARY|PRIMARY|8|const|1|100.00|NULL|

* WHERE 조건절이 id(PK)이므로 PRIMARY 인덱스를 사용한 것을 알 수 있다.     
* 하지만 EXTRA 의 값이 NULL 이라는 것은 조회 타깃을 찾기 위해 실제 데이터까지 접근했다는 것을 알 수 있다.     


## name 조회, name 검색 

```sql
 EXPLAIN SELECT name FROM PERSON WHERE PERSON.name = 'USER1'
```

![image](https://user-images.githubusercontent.com/50267433/146541781-18eeaa7a-0f0f-4ab6-8cc5-227cfa38091e.png)

* 이쯤에서 눈치 챘듯이 인덱스의 값으로만 이루어진 경우에는 커버링 인덱스로 동작을 한다.     
* 만약, WHERE는 인덱스인데 SELCT가 인덱스에 이루어진 컬럼이 아니면, EXTRA는 NUll 을 반환한다.  

# 


## id값만 조회 

```sql

```


```sql
EXPLAIN SELECT age FROM MEMBER WHERE member.name = 'H'
```


# 미제 

## id 조회

```sql
EXPLAIN SELECT PERSON.id FROM PERSON
```
![image](https://user-images.githubusercontent.com/50267433/146540803-703b3f97-e8e3-49ae-8b68-b26c36d0a129.png)
  
* 기존에 만들었던 인덱스 IDX_NAME을 탔다.(id를 검색했는데 클러스터드 인덱스가 아닌 이 인덱스가 탔는지는..)     
* 가장 중요한 점은, EXTRA 의 값이 `Using index`는 점이고 이는 커버링 인덱스를 탔다는 뜻이다.   

## id 조회, name 조건  
```sql
EXPLAIN SELECT PERSON.id FROM PERSON WHERE PERSON.name = 'USER1'
```

![image](https://user-images.githubusercontent.com/50267433/146541447-242a6a76-d6e5-4259-ac3a-165ff515d80b.png)

* 커버링 인덱스가 탔다..?(이건 찾아봐야할 듯)   

