# 개요 

데이터가 너무 많아서 검색이 느린데 더 빠르게 해결할 수 있는 방법? 
근데 데이터가 왜 느려? -> 이거 DB 구조 설명할 수 잇어야할 듯 

* 테이블을 나눠서 검색하자 

1. 분산된 데이터베이스에 데이터를 어떻게 잘 분산해서 저잘할 것이냐?(핫스팟 문제) 
2. 분산된 데이터베이스에서 데이터를 어떻게 읽을 것인가?  

* 샤드키가 등장 

나눠진 샤드 중 어떤 샤드를 선택할지 결정하는 키    
샤드 키 결정 방식에 따라 샤딩 방법이 나뉜다.    

## 해시 샤딩
해시 알고리즘을 이용해서 데이터를 각각의 샤드에 분산시키는 것이다.   
구현 자체가 간단하다.(해싱 하면 되니까)   
    
그러나 샤드가 늘어나야된다면, 해시 알고리즘을 수정해야하는데     
그러면 기존 샤드에 저장된 데이터에 대한 정합성이 깨지게 된다는 문제가 잇다(해시 찾는 로직이 깨져서)     
또한, 단순히 키를 기준으로 나누기 때문에 공간에 대한 효율성을 고려하지 않고 해시로만 처리한다.    

## 다이나믹 샤딩 

해시 샤딩의 확장성 문제를 해결하기 위해 등장했다.  

Locate Service를 도입함으로써 이를 해결했다.  
Locate Service는 특정 데이터의 범위는 어느 샤드에 데이터를 접근할지 기록한 테이블이다.     
그렇기 때문에 새로운 데이터가 들어오면, 로케이트 서비스 테이블의 키/value를 추가하면 된다.     
단, 모든 샤드들이 이 로케이트 서비스에 종속적이기 때문에 로케이트 서비스가 문제가 생기면 다 문제 생긴다.   

# 엔티티 그룹 
> 앞선 해시/다이나믹 샤딩은 관계형 데이터베이스보다 NoSQL에 더 적합한 샤딩 방식이었다.  
 
엔티티 그룹은 관계가 있는 엔티티들을 같은 샤드내에서 공유하도록 하는 것이다.     
그래서 유저가 작성한 게시글이나, 댓글을 같은 샤드 내에서 가지고 있도록 구성하는 방식이다.  

**장점**
* 단일 샤드내에서 쿼리가 효율적이다.  
* 단일 샤드내에서 강한 응집도를 가진다.    

**단점** 
* 다른 샤드의 엔티티와 연관이 되는 경우 비효율적이다.   

# 마지막
데이터 베이스를 나누는 것도 다 비용이기 때문에 현재 상황에 맞는 기술을 활용하는 것이 중요하다.    
특히 샤딩같은 경우 데이터의 복잡성이 커지기 때문에 캐싱을 먼저 생각해봐야한다.    




