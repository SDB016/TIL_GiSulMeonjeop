# 개요 

데이터가 너무 많아서 검색이 느린데 더 빠르게 해결할 수 있는 방법? 
근데 데이터가 왜 느려? -> 이거 DB 구조 설명할 수 잇어야할 듯 
  
* DB 스키마를 나눠서 검색하자    
  
1. 분산된 데이터베이스에 데이터를 어떻게 잘 분산해서 저잘할 것이냐?(핫스팟 문제) 
2. 분산된 데이터베이스에서 데이터를 어떻게 읽을 것인가?  

* 샤드키가 등장 

나눠진 샤드 중 어떤 샤드를 선택할지 결정하는 키    
샤드 키 결정 방식에 따라 샤딩 방법이 나뉜다.    

# 샤딩이란 

* 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방식을 말한다.   
* Application level 에서도 가능하지만 DataBase Level에서도 가능하다.   

## 적용에 앞서  
  
* 프로그래밍, 운영적인 복잡도는 더 높아진다.        
* 가능하면 샤딩을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선시 된다.    
    * ScaleUp : 컴퓨터 성능 업
    * Read 부하가 크면? : Chache나 Replication도 하나의 방법
    * Table 일부 컬럼만 사용된다면 : 수직 파티셔닝도 하나의 방법
    * 데이터를 핫/웜/콜드로 분리 

# 샤딩에 필요한 원리 

* 분산된 데이터베이스에서 데이터를 어떻게 Read할 것인가?   
* 분산된 데이터베이스에서 데이터를 어떻게 분산시켜서 저장할 것인가?  
    * 분산이 잘 되지 않고, 한쪽으로 데이터가 몰리면 자연스럽게 **핫스팟**이 되어 성능이 느려진다.  
    * 그렇기 때문에 잘 분산하는 것이 중요한 목표다.  

# 샤딩 방법 
## 해시 샤딩 

* Shard Key : DataBase id를 Hashing 하여 결정한다.  
    * Hash 크기는 Cluster안에 있는 Node 개수로 정하게 된다.   
* 아주 간단한 Sharding 기법이다.   

**단점**    
* Cluster가 포함하는 노드 개수의 변동이 생기면 : 
    * Hash 크기가 변하게 되므로 HashKey 가 변하게 되고   
    * 기존에 있던 Hash Key에 따라 분배된 Data 분산 Rule이 다 어긋난다(정합성 깨짐) 
    * 결국엔 ReSharding이 필요하다.  
* 단순 해싱알고리즘을 사용했기 때문에, 한쪽 샤딩에 크기가 큰 데이터만 몰려 들어갈 수 있다.   
    * 공간에 대한 효율은 고려하지 않았다.  

## 다이나믹 샤딩 
* Naming 그대로 Dynamic 으로 바꿀 수 있다.   
* Locator Service 를 통해 Shard Key를 얻을 수 있다.    
* Cluster가 포함하는 Node 개수를 늘려본다면?  
    * Locator Service에 Shard Key를 추가하면 된다.  
    * 기존의 Data 의 Shard Key는 변경이 없다.  
    * 확장에 유연한 구조이다.    
* 레인지를 키값으로, 샤딩된 DB를 매핑한다.     

**단점**   
* Data Relocation 을 하게 된다면?   
    * Locator Service의 Shard Key Table도 일치시켜줘야 한다.    
* Locator가 성능을 위해 Cache 하거나 Replication을 하면 어떻게 될까?   
    * 잘못된 Routing을 통해 데이터를 찾지 못하고 에러가 발생
    * 로케이터에 의존할 수 밖에 없는 단점  

## 엔티티 그룹 
* Key-value 구조가 아닌 객체들로 구성한 샤딩 
* RBDMS의 join, index, transaction을 사용함으로써 Application의 복잡도를 줄이는 효과 얻었음 
* 이와 유사한 방법으로 Sharding 하는 방법이 Entity Group    

**장점**
* 하나의 물리적인 Shard에 쿼리를 진행하다면 효율적이다.  
* 하나의 Shard 에 강한 응집도를 가질 수 있다.   
* 데이터는 자연스럽게 사용자별로 분리되어 저장된다.    
* 사용자가 늘어남에 따라 확장성이 좋은 파티셔닝이라고 보면 된다.  

**단점**  
* 크로스 파티션 쿼리는, 싱글 파티션 쿼리보다 동시성의 보장과 성능을 잃는다.     
* 그렇기 때문에 이런 쿼리들이 자주 실행되지 않도록 해주어야한다.    

## Pitfall 에 대해 
> Logical Shard는 반드시 Single Node 안에 있어야 한다.   

* 다이나믹 샤딩을 진행하게 된다면 작업량을 효과적으로 줄일 수 있다.   
* 핫스팟을 찾고 샤딩을 진행한다.   
* 지속적으로 샤딩을 진행하게 된다면 가장 오른쪽 노드만 write을 진행하게 된다.   
* 나머지 Node들은 Read Performance가 향상하는 효과를 얻을 수 있다.  

# 정리하며
* Sharding을 피하는 방법을 우선 적용해보고 불가피하다면 적용하는게 좋습니다.
* 반드시 Trade-Off가 있습니다.
    * Locator와 Sync해야하는 비용이 필요합니다.
    * Cross-Partition Query가 발생할 경우 기존의 Query보다 느릴 수 있습니다.

## 해시 샤딩
해시 알고리즘을 이용해서 데이터를 각각의 샤드에 분산시키는 것이다.   
구현 자체가 간단하다.(해싱 하면 되니까)   
    
그러나 샤드가 늘어나야된다면, 해시 알고리즘을 수정해야하는데     
그러면 기존 샤드에 저장된 데이터에 대한 정합성이 깨지게 된다는 문제가 잇다(해시 찾는 로직이 깨져서)     
또한, 단순히 키를 기준으로 나누기 때문에 공간에 대한 효율성을 고려하지 않고 해시로만 처리한다.    

## 다이나믹 샤딩 

해시 샤딩의 확장성 문제를 해결하기 위해 등장했다.  

Locate Service를 도입함으로써 이를 해결했다.  
Locate Service는 특정 데이터의 범위는 어느 샤드에 데이터를 접근할지 기록한 테이블이다.     
그렇기 때문에 새로운 데이터가 들어오면, 로케이트 서비스 테이블의 키/value를 추가하면 된다.     
단, 모든 샤드들이 이 로케이트 서비스에 종속적이기 때문에 로케이트 서비스가 문제가 생기면 다 문제 생긴다.   

# 엔티티 그룹 
> 앞선 해시/다이나믹 샤딩은 관계형 데이터베이스보다 NoSQL에 더 적합한 샤딩 방식이었다.  
 
엔티티 그룹은 관계가 있는 엔티티들을 같은 샤드내에서 공유하도록 하는 것이다.     
그래서 유저가 작성한 게시글이나, 댓글을 같은 샤드 내에서 가지고 있도록 구성하는 방식이다.  

**장점**
* 단일 샤드내에서 쿼리가 효율적이다.  
* 단일 샤드내에서 강한 응집도를 가진다.    

**단점** 
* 다른 샤드의 엔티티와 연관이 되는 경우 비효율적이다.   

# 마지막
데이터 베이스를 나누는 것도 다 비용이기 때문에 현재 상황에 맞는 기술을 활용하는 것이 중요하다.    
특히 샤딩같은 경우 데이터의 복잡성이 커지기 때문에 캐싱을 먼저 생각해봐야한다.    




