# 개요 

데이터가 너무 많아서 검색이 느린데 더 빠르게 해결할 수 있는 방법? 
근데 데이터가 왜 느려? -> 이거 DB 구조 설명할 수 잇어야할 듯 

* 테이블을 나눠서 검색하자 

1. 분산된 데이터베이스에 데이터를 어떻게 잘 분산해서 저잘할 것이냐?(핫스팟 문제) 
2. 분산된 데이터베이스에서 데이터를 어떻게 읽을 것인가?  

* 샤드키가 등장 

나눠진 샤드 중 어떤 샤드를 선택할지 결정하는 키    
샤드 키 결정 방식에 따라 샤딩 방법이 나뉜다.    

# 샤딩이란 

* 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방식을 말한다.   
* Application level 에서도 가능하지만 DataBase Level에서도 가능하다.   

## 적용에 앞서  
  
* 프로그래밍, 운영적인 복잡도는 더 높아진다.        
* 가능하면 샤딩을 피하거나 지연시킬 수 있는 방법을 찾는 것이 우선시 된다.    
    * ScaleUp : 컴퓨터 성능 업
    * Read 부하가 크면? : Chache나 Replication도 하나의 방법
    * Table 일부 컬럼만 사용된다면 : 수직 파티셔닝도 하나의 방법
    * 데이터를 핫/웜/콜드로 분리 

# 샤딩에 필요한 원리 

* 분산된 데이터베이스에서 데이터를 어떻게 Read할 것인가?   
* 분산된 데이터베이스에서 데이터를 어떻게 분산시켜서 저장할 것인가?  
    * 분산이 잘 되지 않고, 한쪽으로 데이터가 몰리면 자연스럽게 **핫스팟**이 되어 성능이 느려진다.  
    * 그렇기 때문에 잘 분산하는 것이 중요한 목표다.  

# 샤딩 방법 
## 해시 샤딩 

 


    * 데이터를 핫/웜/콜드로 분리 ㅍㅣㄹ요
    * 데이터를 핫/웜/콜드로 분리 




## 해시 샤딩
해시 알고리즘을 이용해서 데이터를 각각의 샤드에 분산시키는 것이다.   
구현 자체가 간단하다.(해싱 하면 되니까)   
    
그러나 샤드가 늘어나야된다면, 해시 알고리즘을 수정해야하는데     
그러면 기존 샤드에 저장된 데이터에 대한 정합성이 깨지게 된다는 문제가 잇다(해시 찾는 로직이 깨져서)     
또한, 단순히 키를 기준으로 나누기 때문에 공간에 대한 효율성을 고려하지 않고 해시로만 처리한다.    

## 다이나믹 샤딩 

해시 샤딩의 확장성 문제를 해결하기 위해 등장했다.  

Locate Service를 도입함으로써 이를 해결했다.  
Locate Service는 특정 데이터의 범위는 어느 샤드에 데이터를 접근할지 기록한 테이블이다.     
그렇기 때문에 새로운 데이터가 들어오면, 로케이트 서비스 테이블의 키/value를 추가하면 된다.     
단, 모든 샤드들이 이 로케이트 서비스에 종속적이기 때문에 로케이트 서비스가 문제가 생기면 다 문제 생긴다.   

# 엔티티 그룹 
> 앞선 해시/다이나믹 샤딩은 관계형 데이터베이스보다 NoSQL에 더 적합한 샤딩 방식이었다.  
 
엔티티 그룹은 관계가 있는 엔티티들을 같은 샤드내에서 공유하도록 하는 것이다.     
그래서 유저가 작성한 게시글이나, 댓글을 같은 샤드 내에서 가지고 있도록 구성하는 방식이다.  

**장점**
* 단일 샤드내에서 쿼리가 효율적이다.  
* 단일 샤드내에서 강한 응집도를 가진다.    

**단점** 
* 다른 샤드의 엔티티와 연관이 되는 경우 비효율적이다.   

# 마지막
데이터 베이스를 나누는 것도 다 비용이기 때문에 현재 상황에 맞는 기술을 활용하는 것이 중요하다.    
특히 샤딩같은 경우 데이터의 복잡성이 커지기 때문에 캐싱을 먼저 생각해봐야한다.    




