# 개요  


# Replication이란? 

![image](https://user-images.githubusercontent.com/50267433/146627748-b41cdc70-7f49-4b6b-86ed-49873c19f0d3.png)

한 서버에서 다른 서버로 데이터를 동기화하는 것         
(DB 스토리지 뿐만 아니라, DB서버를 같이 복사되어야한다. 그러지 않으면 그냥 클러스터링)  

* 소스 서버 : 원본 데이터를 가진 서버 
* 레플리카 서버 : 복제된 데이터를 가진 서버 

# 왜 사용하지?  

서비스의 부하를 줄이기 위해서..?    
근데 신입, 그리고 사이드 프로젝트에서 부하를 줄여야할 필요가 있을까?   

그럼 어떤 이점?  

1. 스케일 아웃 
2. 데이터 백업 
3. 데이터 분석 
4. 데이터의 지리적 븐석

## 스케일 아웃  

* 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조  
* 하나의 서버에서 감당하는 쿼리(조회) 처리를 2, 3개의 서버에서 담당   
 
## 데이터 백업 
  
* 레플리카를 안하더라도 백업은 해야한다.         
* 백업 과정은 실제 실행중인 쿼리들에 영향을 줄 수 있다.    
* **레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업시 발생하는 문제점들을 해결**   
    * 이점이 클러스터링과 다른점이라고 생각이든다.    

## 데이터 분석 

* 분석용 쿼리는 대량의 데이터를 조회하고 쿼리 자체가 무거운 경우가 많다.      
* 레플리카 서버에서 분석용 쿼리만 전용으로 하는 것이 좋다.     
   
## 데이터의 지리적 븐석 

* 데이터베이스와 애플리케이션 서버가 멀리 떨어져 있다면 응답을 늦게 받는다.    
* 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는게 좋다.    

# 복제를 어떻게 하지?  
## 바이너리 로그 

MySQL 서버에서 발생하는 모든 변경사항을 별도의 로그 파일에 순서대로 저장  
  
* 데이터의 변경 내역   
* 데이터베이스나 테이블의 구조 변경   
* 계정이나 권한의 정보    

```sql
show binary logs;
```
* 바이너리 로그 파일 목록    
  
```sql
show master status
```
* 바이너리 로그 파일의 파일명과 위치정보(위치 기반으로 식별)  
 
소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고        
레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤   
자신이 가진 데이터에 반영함으로써  소스 서버와 레플리카 서버가 동기화가 이루어진다.     
    
**이러한 복제 과정은 3개의 쓰레드에 의해 동작된다.**        
 
* Binary Log Dump Thread : 소스  
* Replication I/O Thread : 레플리카  
* Replication SQL Thread : 레플리카 

### Binary Log Dump Thread
* Binary Log 를 레플리카 서버로 전송하는 역할 
  
레플리카 서버가 소스 서버에 연결되면,   
소스 서버 내부적으로 Binary Log Dump Thread 를 생성한다.   

## Replication I/O Thread 

바이너리 로그 이벤트를 가져와 로컬 서버의 파일(Relay Log)로 저장하는 역할 

* 소스 서버의 Binary Log Dump Thread 가 보낸   
  Binary Log Event 이벤트를 가져와 '로컬 서버의 파일(Relay Log)'로 저장한다.      
* 복제가 시작되면 스레드가 생성된다.   
* 복제가 멈추면 스레드가 종료된다.    

이때, 소스 서버와 레플리카 서버를 연결할 때 사용하는 정보는 
Connection Metadata 에 있다.  
 
Connection Metadata 의 정보는     
MySQL 데이터베이스 slave_master_info 테이블에 저장된다.  
버전에 따라 파일로 관리되는 경우도 있는데,    
파일로 관리될 경우 MySQL 데이터 디렉토리에 파일 형태로 저장    

* 커넥션 메타 데이터 : 
    * 소스 서버에 연결할 때 사용하는 정보를 가지고 있다.  
    * mysql.slave_master_info 테이블에 저장 
* Relay Log : 
    * 가져온 바이너리 로그 이벤트를 레플리카 서버에 파일로 저장한 것   


## Replication SQL Thread  
릴레이 로그 파일의 이벤트들을 읽고 실행 

* Replication I/O Thread 에 의해 작성된 Realy Log 파일의 에빈트를 읽고 실행하는 역할  
* 어플라이어 : 릴레이 로그에 저장된 소스 서버의 이벤트들을 서버에 적용하는 컴포넌트 
* 어플라이어 메타 데이터 : 이벤트가 저장된 릴레이 로그 파일명과 파일 내 위치 정보를 담고 있으며 
  이 정보를 바탕으로 레플리카 서버에 이벤트들을 적용한다
    
컴포넌트 어플라이어는 MySQL 데이터베이스에      
slave_relay_log_info 테이블에 저장된다.  

Applier Metadata : 소스 서버에 연결할 때 사용하는 정보를 가지고 있다.       
mysql.slave_relay_log_info 테이블에 저장된다.      
   
# 어떻게 변경 내용을 식별하는가?   

바이너리 로그에 변경 내용이 있다는 것을 알고 이를 통해서 복제가 이루어진다.   
그렇다면, 바이너리 로그를 어떻게 식별하는 것일까?    

**바이너리 로그 변경 내역을 찾는 방식**    
1. 바이너리 로그 파일 위치 기반    
2. 글로벌 트랜잭션 ID 기반 (GTID)   

기본적으로 MySQL 복제를 사용하려면 소스 서버에서 반드시 Binary Log가 활성화 되어야한다.     
바이너리 로그가 기록되는지는 show master status를 통해 확인할 수 있다.    
   
## Binary Log 파일 위치 기반 복제    
> 이벤트 하나를 소스 서버의 바이너리 로그 파일명과 위치값의 조합으로 식별한다.    

레플리카 서버에서 소스 서버의     
**바이너리 로그 파일명**과 **파일내에서 위치**로 바이너리 로그 이벤트를 식별해서 복제     
  
여기서 중요한 것은, server_id 이다.      
이벤트 별로 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 MySQL 서버의 server_id 가 이용된다.    
서버 id를 지정하지 않으면, 기본값이 1인데, 레플리케이션을 하게 된다면    
레플리카 서버에서는 반드시 server_id를 지정해줘야한다.      
이 때 레플리케이션에 참여하는 각 서버마다 서로 다른 server_id를 지정해줘야한다.   
  
## 글로벌 트랜잭션 아이디(GTID)  
   
* 복제에 참여한 서버들에서 고유하도록 각 이벤트에 부여된 식별값    
* 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 서버들에서 동일한 고유 식별값을 가진다.  

MySQL 5.5 버전까지는 바이너리 로그 파일 기반 복제만 가능    
그러나 식별 과정이 소스 서버에서만 유효하다는 단점이 있다.     
동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 저장된다는 보장이 없다.  
즉, 어떤 경우에는 동일한 이벤트인데 서로 다른 식별값을 가지는 경우가 있다.   

이를 해결하기위해 각 이벤트들이 복제에 참여한 모든 MySQL 서버들에서 동일한 고유 식별값을 가지면 어떨까?  
라는 생각에 GTID 글로벌 트랜잭션 id로 식별하게 되었다.  

# 바이너리 로그는 어떻게 생겼을까? 

1. Statement 방식 
2. Row 방식 
3. Mixed 방식 

## Statement 방식 
## Row 방식 
## Mixed 방식 
 

# 이중화(Replication) 
  
MySQL Replication의 Master, Slave 관계는 `1:n` 관계다.     
       
1. master는 **갱신쿼리를 바이너리 로그파일로 기록한다**         
2. 로그파일의 내용이 slave로 전송되어 순차적으로 실행함으로써 복제한다     
3. 따라서 MySQL Replication은 준동시성이다.    

**주의점**
    
I/O 스레드가 비동기로 동작하기에      
Master에서 생성한 바이너리 로그가  
Slave에 수신되기 전에 장애가 날 경우 손실이 발생할 수 있다.    
  
**장점**  
* 마스터 : 데이터조작쿼리(INSERT, UPDATE, DELETE) 담당   
* 슬레이브 : 데이터조회쿼리(SELECT) 당당      
* 부하를 분산할 수 있다.     

