# 인덱스 튜닝    
인덱스 튜닝은 크게 2가지가 있다.   
    
1. 인덱스 스캔 효율화    
2. 랜덤 액세스 최소화  
 
## 인덱스 스캔 효율화    
## 랜덤 액세스 최소화      
인덱스 스캔후 테이블 레코드를 액세스할때, 랜덤 I/O 횟수를 줄이는 것  

# 인덱스 스캔 3가지 

## Index Range Scan 

```sql
SELECT * FROM subway.programmer 
WHERE 생년월일 BETWEEN '20200101' AND '20200131'
```

인덱스 컬럼을 가공하지 않아야, 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈출 수 있다.    
즉, 특정 범위(Range)만큼 인덱스 스캔을 할수 있다.     

```sql
SELECT * FROM subway.programmer WHERE  id < 10
SELECT * FROM subway.programmer WHERE  id > 10
```
 
두 쿼리의 실행계획이 다른 이유를 생각해보면,    
10 보다 큰 값은 무한정하지만, 10보다 작은 값은 당연스럽게도 그 범위가 작아 빠르다.  

## Index Full Scan  

```sql
SELECT COUNT(*) FROM subway.programmer 
```
리프 블록 전체를 스캔해야 할때는 Index를 Full Scan 한다.  

## Index Unique Scan
  
인덱스가 존재하는 컬럼이 중복값이 입력되어 있지 않아   
인덱스 키 컬럼을 모두 `=` 조건으로 검색할 때는 데이터를 한건 찾는 순간 더이상 탐색할 필요가 없다.          
다만, Unique 하더라도 범위 검색할 때는 수직적 탐색만으로는 모두 찾을 수 업기 때문에 IndexRange Scan으로 처리된다.   

# 테이블 액세스 최소화   
## 인덱스 손익 분기점  

1건을 조회하든, 1000만건을 다 조회하든 Table Full Scan의 성능은 일정하게 유지된다.          
인덱스를 이용해 테이블을 액세스할 경우 데이터량이 많을 수록 랜덤 액세스 때문에 점점 느려진다.      
  
Table Full Scan은 시퀀셜 액세스인 반면,     
인덱스 ROWID를 이용한 테이블 액세스는  랜덤 액세스 방식이기 때문이다.  

테이블 데이터가 10~100만건 이내의 경우 조회 건수가 5~20% 가량에서 손익분기점이 형성된다.      
조회 건수가 늘수록 데이터를 버퍼 캐시에서 찾을 가능성이 낮아지기 때문에,            
1000만 건중 100만건 이상 액세스한다면 캐시 히트율은 극히 낮을 수밖에 없다.        
게다가 1000만건 정도 테이블이면 클러스터링 팩터도 낮을 가능성이 높다.   
     
## 인덱스 컬럼 추가   
테이블 액세스 최소화를 위해 가장 일반적으로 튜닝 기법은 인덱스에 컬럼을 추가하는 것이다.     

<img width="1185" alt="cba5fa29a82a4250898383282a7a5407" src="https://user-images.githubusercontent.com/50267433/146517183-0e014bc5-4720-419c-9b34-87d16482b8ab.png">
  
```sql
SELECT * FROM emp WHERE deptno = 30 AND sal >= 2000
```
위 질의 결과에 해당하는 데이터는 1개일 뿐인데,        
이를 찾기 위해 테이블에 여섯번 액세스하는 것을 볼 수 있다.       
  
물론, DEPTNO + SAL 순으로 인덱스 구성을 변경하면 해결될 문제이지만,       
실 운영환경에서 인덱스 구성을 변경하기는 쉽지 않다.        
따라서 **기존 인덱스에 SAL 컬럼을 추가하여 테이블 랜덤 액세스 횟수를 줄일 수 있다.**      


 







