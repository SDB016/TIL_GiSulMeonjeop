# 개요  


# Replication이란? 

![image](https://user-images.githubusercontent.com/50267433/146627748-b41cdc70-7f49-4b6b-86ed-49873c19f0d3.png)

한 서버에서 다른 서버로 데이터를 동기화하는 것         
(DB 스토리지 뿐만 아니라, DB서버를 같이 복사되어야한다. 그러지 않으면 그냥 클러스터링)  

* 소스 서버 : 원본 데이터를 가진 서버 
* 레플리카 서버 : 복제된 데이터를 가진 서버 

# 왜 사용하지?  

서비스의 부하를 줄이기 위해서..?    
근데 신입, 그리고 사이드 프로젝트에서 부하를 줄여야할 필요가 있을까?   

그럼 어떤 이점?  

1. 스케일 아웃 
2. 데이터 백업 
3. 데이터 분석 
4. 데이터의 지리적 븐석

## 스케일 아웃  

* 갑자기 늘어나는 트래픽을 대응하는데 유연한 구조  
* 하나의 서버에서 감당하는 쿼리(조회) 처리를 2, 3개의 서버에서 담당   
 
## 데이터 백업 
  
* 레플리카를 안하더라도 백업은 해야한다.         
* 백업 과정은 실제 실행중인 쿼리들에 영향을 줄 수 있다.    
* **레플리카 서버에서 데이터 백업을 실행하여 소스 서버에서 백업시 발생하는 문제점들을 해결**   
    * 이점이 클러스터링과 다른점이라고 생각이든다.    

## 데이터 분석 

* 분석용 쿼리는 대량의 데이터를 조회하고 쿼리 자체가 무거운 경우가 많다.      
* 레플리카 서버에서 분석용 쿼리만 전용으로 하는 것이 좋다.     
   
## 데이터의 지리적 븐석 

* 데이터베이스와 애플리케이션 서버가 멀리 떨어져 있다면 응답을 늦게 받는다.    
* 빠른 응답을 위해 애플리케이션 서버에 가깝게 서버를 구성하는게 좋다.    

# 복제를 어떻게 하지?  
## 바이너리 로그 

MySQL 서버에서 발생하는 모든 변경사항을 별도의 로그 파일에 순서대로 저장  
  
* 데이터의 변경 내역   
* 데이터베이스나 테이블의 구조 변경   
* 계정이나 권한의 정보    

```sql
show binary logs;
```
* 바이너리 로그 파일 목록    
  
```sql
show master status
```
* 바이너리 로그 파일의 파일명과 위치정보(위치 기반으로 식별)  
 
소스 서버에서 생성된 바이너리 로그가 레플리카 서버로 전송되고        
레플리카 서버에서는 해당 내용을 로컬 디스크에 저장한 뒤   
자신이 가진 데이터에 반영함으로써  소스 서버와 레플리카 서버가 동기화가 이루어진다.     
    
**이러한 복제 과정은 3개의 쓰레드에 의해 동작된다.**        
 
* Binary Log Dump Thread : 소스  
* Replication I/O Thread : 레플리카  
* Replication SQL Thread : 레플리카 

### Binary Log Dump Thread
* Binary Log 를 레플리카 서버로 전송하는 역할 
  
레플리카 서버가 소스 서버에 연결되면,   
소스 서버 내부적으로 Binary Log Dump Thread 를 생성한다.   

## Replication I/O Thread 

바이너리 로그 이벤트를 가져와 로컬 서버의 파일(Relay Log)로 저장하는 역할 

* 소스 서버의 Binary Log Dump Thread 가 보낸   
  Binary Log Event 이벤트를 가져와 '로컬 서버의 파일(Relay Log)'로 저장한다.      
* 복제가 시작되면 스레드가 생성된다.   
* 복제가 멈추면 스레드가 종료된다.    

이때, 소스 서버와 레플리카 서버를 연결할 때 사용하는 정보는 
Connection Metadata 에 있다.  
 
Connection Metadata 의 정보는     
MySQL 데이터베이스 slave_master_info 테이블에 저장된다.  
버전에 따라 파일로 관리되는 경우도 있는데,    
파일로 관리될 경우 MySQL 데이터 디렉토리에 파일 형태로 저장    

* 커넥션 메타 데이터 : 
    * 소스 서버에 연결할 때 사용하는 정보를 가지고 있다.  
    * mysql.slave_master_info 테이블에 저장 
* Relay Log : 
    * 가져온 바이너리 로그 이벤트를 레플리카 서버에 파일로 저장한 것   


## Replication SQL Thread  
릴레이 로그 파일의 이벤트들을 읽고 실행 

* Replication I/O Thread 에 의해 작성된 Realy Log 파일의 에빈트를 읽고 실행하는 역할  
* 어플라이어 : 릴레이 로그에 저장된 소스 서버의 이벤트들을 서버에 적용하는 컴포넌트 
* 어플라이어 메타 데이터 : 이벤트가 저장된 릴레이 로그 파일명과 파일 내 위치 정보를 담고 있으며 
  이 정보를 바탕으로 레플리카 서버에 이벤트들을 적용한다
    
컴포넌트 어플라이어는 MySQL 데이터베이스에      
slave_relay_log_info 테이블에 저장된다.  

Applier Metadata : 소스 서버에 연결할 때 사용하는 정보를 가지고 있다.       
mysql.slave_relay_log_info 테이블에 저장된다.      
   
# 어떻게 변경 내용을 식별하는가?   

바이너리 로그에 변경 내용이 있다는 것을 알고 이를 통해서 복제가 이루어진다.   
그렇다면, 바이너리 로그를 어떻게 식별하는 것일까?    

**바이너리 로그 변경 내역을 찾는 방식**    
1. 바이너리 로그 파일 위치 기반    
2. 글로벌 트랜잭션 ID 기반 (GTID)   

기본적으로 MySQL 복제를 사용하려면 소스 서버에서 반드시 Binary Log가 활성화 되어야한다.     
바이너리 로그가 기록되는지는 show master status를 통해 확인할 수 있다.    
   
## Binary Log 파일 위치 기반 복제    
> 이벤트 하나를 소스 서버의 바이너리 로그 파일명과 위치값의 조합으로 식별한다.    

레플리카 서버에서 소스 서버의     
**바이너리 로그 파일명**과 **파일내에서 위치**로 바이너리 로그 이벤트를 식별해서 복제     
  
여기서 중요한 것은, server_id 이다.      
이벤트 별로 이벤트가 최초로 발생한 MySQL 서버를 식별하기 위해 MySQL 서버의 server_id 가 이용된다.    
서버 id를 지정하지 않으면, 기본값이 1인데, 레플리케이션을 하게 된다면    
레플리카 서버에서는 반드시 server_id를 지정해줘야한다.      
이 때 레플리케이션에 참여하는 각 서버마다 서로 다른 server_id를 지정해줘야한다.   
  
## 글로벌 트랜잭션 아이디(GTID)  
   
* 복제에 참여한 서버들에서 고유하도록 각 이벤트에 부여된 식별값    
* 소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 서버들에서 동일한 고유 식별값을 가진다.  

MySQL 5.5 버전까지는 바이너리 로그 파일 기반 복제만 가능    
그러나 식별 과정이 소스 서버에서만 유효하다는 단점이 있다.     
동일한 이벤트가 레플리카 서버에서 동일한 위치와 동일한 파일명으로 저장된다는 보장이 없다.  
즉, 어떤 경우에는 동일한 이벤트인데 서로 다른 식별값을 가지는 경우가 있다.   

이를 해결하기위해 각 이벤트들이 복제에 참여한 모든 MySQL 서버들에서 동일한 고유 식별값을 가지면 어떨까?  
라는 생각에 GTID 글로벌 트랜잭션 id로 식별하게 되었다.  

# 바이너리 로그는 어떻게 생겼을까? 

1. Statement 방식 
2. Row 방식 
3. Mixed 방식 
   
```
mysql> set global binlog_format = 'STATEMENT'와 같은 형식으로 변경할 수 있다.   
```

## Statement 방식   

* MySql 에 바이너리가 처음 도입되었을때부터 존재한 포맷 
* SQL 문을 바이너리 로그에 기록하는 방식   
* **트랜잭션 격리 수준이 반드시 REPEATABLE_READ 이상이어야 한다.**     
    * 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 스냅숍이 달라질 수 있다.   
    * 이로 인해, 복제시 서버와 레플리카 서버의 데이터가 일치하지 않을 수 있기 때문이다.   

**장점**
* 손쉽게 SQL문들을 확인할 수 있다.  

**딘점**
* 비확정적으로 처리될 수 있는 쿼리가 실행된 경우 
   Statement 포맷에서는 복제 시 소스 서버와 레플리카 서버간 데이터가 달라질 수 있다.  
* 비확정적 : delete나 update를 OrderBy 없이 Limit을 사용하게 되면 매번 다른 결과가 나올 수 있는 것처럼 
   매번 다른 결과가 나올 수 있는 상황처럼, 결과가 매번 달라질 수 있는 경우를 말한다.      
  
## Row 방식 

* 데이터 변경이 발생했을 때 `변경된 값 자체`가 바이너리 로그에 기록되는 방식   
  MySQL 5.7.7 버전 이후부터 바이너리 로그 기본 포맷으로 지정되었다.  

**장점**
* 어떤 형태의 쿼리든지 복제시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식
 
**단점**   
* 많은 데이터를 변경하면 모든 데이터가 전부 기록되 바이너리 로그 파일이 단시간에 매우 커진다.     
  
Row 포맷으로 넘어오면 어떤 쿼리들이 넘어왔고 현재 실행중인 쿼리가 어떤 것인지, 레플리카서버에서는 확인할 수 없다.   
  
## Mixed 방식   
* Satement 방식과 Row 방식의 장단점을 서로 보완하기 위해 혼합하여 사용하는 방식       
* binlog_format 을 MIXED로 지정하여 사용할 수 있다.    

쿼리의 대부분은 State 포맷으로 기록될 가능성이 높은데,  
만약 실행된 쿼리가 State 포맷으로 기록되어 복제되었을때 문제가 될 가능성이 있는 안전하지 못한 쿼리라면   
Row 포맷으로 변환되어 기록된다.   

# 복제 동기화 방식 
  
소스 서버가 레플리카 서버에 이벤트들이 잘 보내졌는지 확인하냐 안하냐에 따라 복제 동기화 방식 설정 가능하다.     

1. 비동기 복제 
2. 반동기 복제 

## 비동기 복제 
  
소스 서버가 레플리카 서버에서 변경 이벤트가 정상적으로 전달 되었는지 확인하지 않는다.       
결국 소스 서버는 레플리카 서버에 적용이 잘되었는지 알지 못하게되고   
소스 서버에 장애가 발생하면 소스 서버에서 최근까지 적용된 트랜잭션이 레플리카 서버로 전송되지 않을 수 있다.    

## 반동기 복제 

레플리카 서버로부터 확인 응답을 받고 난 후 커밋하게 되고     
그 이후 클라이언트에게 결과를 반환하게 된다.   
    
적어도 하나의 레플리카 서버에 트랜잭션이 전송되었음을 보장하게 된다.     
하지만 전송이 보장된 것이 실제 적용이 보장된 것이 아니다.     
또한, 서버의 응답을 기다리기 때문에 비동기 방식보다는 트랜잭션 처리가 느려질 수 있다.   
  
반동기 복제에서 응답이 없으면, 무기한으로 기다릴 수 있기 때문에      
소스 서버는 지정된 타임아웃 시간동안 응답이 없으면 비동기 복제 방식으로 전환되다.   

# 구성 방식  

1. 싱글 레플리카 복제
2. 멀티 레플리카 복제
3. 체인 복제
4. 듀얼 소스 복제
5. 멀티 소스 복제 

## 싱글 레플리카 복제

* 하나의 소스 서버에 하나의 레플리카 서버만 연결된 복제 형태      
* 주로 소스 서버에 문제가 생겼을 때, 예비 서버 및 데이터 백업 수행을 위한 용도로 많이 사용한다.   

## 멀티 레플리카 복제

* 하나의 소스 서버에 2개 이상의 레플리카 서버를 연결한 복제 형태이다. 
* 하나의 레플리카 서버를 예비용으로 구성   
* 다른 서버를 읽기 요청 처리를 분산하는 용도로 사용한다.   

## 체인 복제
  
* 하나의 소스 서버에 연결된 레플리카 서버수가 많다면,     
* 바이너리 로그를 읽고 전달하는 작업 자체가 부하가 될 수 있는대 이때 사용하는 방식이다.     
* 소스 서버가 해야할 바이너리 로그 배포 역할을 새로운 서버(레플리카)로 넘길 수 있다.    

## 듀얼 소스 복제

* 두개의 서버가 서로 소스서버이자 레플리카 서버로 구성
* 두 서버 모두 쓰기가 가능하고, 각 서버에서 변경한 데이터는 복제를 통해 다시 각 서버에 적용되므로 양쪽에 쓰기가 발생
* 두 서버는 서로 동일한 데이터를 가지게 된다.   
* 목적에 따라, Active-Passivce / Active-Active 형태로 사용할 수 있다.  
* 싱글 레플리카와 비슷하지만, 쓰기가 가능하니까 전환을 바로 가져갈 수 있다.      
    
## 멀티 소스 복제 
  
* 하나의 레플리카 서버가, 둘 이상의 소스 서버를 갖는 형태를 말한다.         
* 여러 서버에 존재하는 다른 데이터를 하나의 서버로 통합하거나       
* 샤딩 되어있는 테이블 데이터를 하나의 테이블로 통합할 때 사용할 수 있다.      
   
# 이중화(Replication) 
  
MySQL Replication의 Master, Slave 관계는 `1:n` 관계다.     
       
1. master는 **갱신쿼리를 바이너리 로그파일로 기록한다**         
2. 로그파일의 내용이 slave로 전송되어 순차적으로 실행함으로써 복제한다     
3. 따라서 MySQL Replication은 준동시성이다.    

**주의점**
    
I/O 스레드가 비동기로 동작하기에      
Master에서 생성한 바이너리 로그가  
Slave에 수신되기 전에 장애가 날 경우 손실이 발생할 수 있다.    
  
**장점**  
* 마스터 : 데이터조작쿼리(INSERT, UPDATE, DELETE) 담당   
* 슬레이브 : 데이터조회쿼리(SELECT) 당당      
* 부하를 분산할 수 있다.     

