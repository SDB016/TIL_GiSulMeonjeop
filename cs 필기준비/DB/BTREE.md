# 인덱스의 내부 작동 

클러스터형 인덱스와 보조 인덱스는 모두 내부적으로 균형 트리(B-Tree)로 이루어져있다.      

## 균형 트리(B-Tree)의 개념    

균형 트리 구조에서 데이터가 저장되는 공간을 **노드**라고 하며 아래 3가지로 이루어진다.  

1. 루트 노드   
2. 중간(Branch) 노드    
3. 리프 노드(말단)    
       
**MySQL에서는 페이지라고도 부른다.**       
  
1. 루트 페이지     
2. 중간(Branch) 페이지      
3. 리프 페이지(말단)     
    
**만약 이런 트리가 없다면?**         
* 풀 테이블 스캔 : 모든 데이터를 스캔해야한다.            
* 데이터가 몇천만, 몇억 이러면 이걸 다 찾아야하는데 너무 비효율적이다.    
  
### 페이지들   
        
* 상위 페이지는 하위 페이지의 페이지 번호를 가지고 있다.                  
* 리프 페이지는 값을 가지고 있으며, 다른 리프 페이지와 더블 링크드 리스트로 연결되어 있다   
* 이 같은 방식을 이용하면, 페이지(데이터 아님)를 찾는 시간이 줄어든다는 장점이 있다.          
* 즉, 루트 페이지 읽고 - ... 생략 - 리프페이지, 와 같은 구조인데 페이지를 거치는 횟수가 작아 빠르다.   
  
디스크에서 읽는 것은 메모리에서 읽는것보다 성능이 훨씬 떨어집니다.  
결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐,   
인덱스 Root에서 Leaf까지 오고가는 횟수를 얼마나 줄이느냐에 달려있습니다    
    
### 균형트리의 페이지 분할  
    
인덱스를 사용하게 되면 SELECT가 빨라진다.            
반면에 인덱스가 **존재하면** SAVE/UPDATE/DELETE 오히려 속도가 느려진다.       
그리고 그 이유가 페이지 분할 때문이다.     
    
데이터 개수의 변형이 이루어지면 페이지마다 수용할 수 있는 데이터의 양도 달라진다.    

![image](https://user-images.githubusercontent.com/50267433/146729060-5e3f8c04-b34b-4fd1-8a38-0b62b30af328.png)

이 같이 페이지의 변동이 없는 경우는 비교적 큰일은 아니다.     
하지만, 여기서 G를 입력하면 어떻게 될까?    
  
![image](https://user-images.githubusercontent.com/50267433/146729229-8da1c9de-7a02-4f4a-b76b-1eb74eec547b.png)
 
F, G, H, I, J 가 될 것이고 이는 페이지의 수용범위를 넘어서게 되면서        
새로운 페이지를 만들고, 이에 맞추어 페이지의 데이터를 재분류 해줘야한다.       

![image](https://user-images.githubusercontent.com/50267433/146729543-ddd972d2-ceac-4f01-98d2-ca9f19dd2400.png)

또 위 그림에서 P를 넣으면 어떻게 될까? 별 문제없다.       
그렇다면 여기에 추가적으로 Q를 넣으면 어떻게 될까?        
     
리프 페이지는 페이지 분할이 이루어진다.        
그런데 또 문제가 루트 노드의 페이지가 찼기 때문에 루트 페이지를 분할 해줘야한다.      

![image](https://user-images.githubusercontent.com/50267433/146731489-8078aae3-7c70-4e9d-9808-218743b5438a.png)

참고로 innoDB는 16KB가 기본이고, 옛날에는 8KB인 것 같다.    
  
인덱스의 갯수는 3~4개 정도가 적당합니다.       
너무 많은 인덱스는 새로운 Row를 등록할때마다 인덱스를 추가해야하고,       
수정/삭제시마다 인덱스 수정이 필요하여 성능상 이슈가 있습니다.     
인덱스 역시 공간을 차지합니다. 많은 인덱스들은 그만큼 많은 공간을 차지합니다.     
특히 많은 인덱스들로 인해 옵티마이저가 잘못된 인덱스를 선택할 확률이 높습니다.  
 
# 클러스터링 인덱스 VS 보조 인덱스(빠르기)        
## 클러스터링 인덱스 
![image](https://user-images.githubusercontent.com/50267433/146731886-8dc1acc3-fca3-4b76-960b-2ac80dcdeb98.png)
     
* 클러스터형 인덱스는 알파벳 사전과 비슷하다.         
* PK, 또는 Unique 키 NotNull 의 컬럼을 기준으로 정렬을 한 구조이다.        
* 각 하위 노드들은 상위 노드에 의존적이다.   
* 앞서 말했듯이 정렬되어야 하기 때문에 SAVE/UPDATE/DELTE시 데이터와 페이지 변동이 심하다.   

## 보조 인덱스    

![image](https://user-images.githubusercontent.com/50267433/146732633-600161b9-0198-4ca3-a651-48418a9ef03a.png)

유니크키 지정만해도 보조 인덱스가 생성된다.     
보조 인덱스를 구성하고 나면 데이터 페이지는 바꾸지 않는다(클러스터링 기준으로 만들기 때문에)     
대신, 보조 인덱스 페이지들(루트, 중간, 리프)이 각각의 페이지에 맞추어 정렬되고 데이터를 참조한다.   
   
보조 페이지의 리프 페이지는 `데이터페이지+순서` 의 모습으로 데이터를 참조하고 있다.       
참고로 클러스터링 인덱스는 리프페이지 == 데이터 페이지다. -> 실제 데이터 접근하지 않아도 된다.(커버링)           
  
## 데이터를 검색한다면    
     
클러스터링 인덱스는 애초에 정렬되어 있기 때문에 탐색에 있어 유리하고        
더불어서 클러스터링 인덱스는 리프 페이지가 데이터 페이지여서 뎁스가 하나 작다. == 훨씬 빠르다.    
페이지를 찾는 횟수가 곧 속도이므로 클러스터형 인덱스가 빠르다.      
범위 검색을 한다해도 리프 페이지는 링크드 리스트로 이루어져있기에 범위 탐색에 효율적이다.         
  
## 비트리플러스인덱스는?  




# 참고 

https://www.youtube.com/watch?v=vWTDuoSG-YQ&list=PLVsNizTWUw7GCfy5RH27cQL5MeKYnl8Pm&index=17&ab_channel=%ED%95%9C%EB%B9%9B%EB%AF%B8%EB%94%94%EC%96%B4

https://jojoldu.tistory.com/243
