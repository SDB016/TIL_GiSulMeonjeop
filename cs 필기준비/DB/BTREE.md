# 인덱스의 내부 작동 

클러스터형 인덱스와 보조 인덱스는 모두 내부적으로 균형 트리(B-Tree)로 이루어져있다.      

## 균형 트리(B-Tree)의 개념    

균형 트리 구조에서 데이터가 저장되는 공간을 **노드**라고 하며 아래 3가지로 이루어진다.  

1. 루트 노드   
2. 중간(Branch) 노드    
3. 리프 노드(말단)    
       
**MySQL에서는 페이지라고도 부른다.**       
  
1. 루트 페이지     
2. 중간(Branch) 페이지      
3. 리프 페이지(말단)     
    
**만약 이런 트리가 없다면?**         
* 풀 테이블 스캔 : 모든 데이터를 스캔해야한다.            
* 데이터가 몇천만, 몇억 이러면 이걸 다 찾아야하는데 너무 비효율적이다.    
  
### 페이지들   
        
* 상위 페이지는 하위 페이지의 페이지 번호를 가지고 있다.                  
* 리프 페이지는 값을 가지고 있으며, 다른 리프 페이지와 더블 링크드 리스트로 연결되어 있다   
* 이 같은 방식을 이용하면, 페이지(데이터 아님)를 찾는 시간이 줄어든다는 장점이 있다.          
* 즉, 루트 페이지 읽고 - ... 생략 - 리프페이지, 와 같은 구조인데 페이지를 거치는 횟수가 작아 빠르다.   
  
디스크에서 읽는 것은 메모리에서 읽는것보다 성능이 훨씬 떨어집니다.  
결국 인덱스 성능을 향상시킨다는 것은 디스크 저장소에 얼마나 덜 접근하게 만드느냐,   
인덱스 Root에서 Leaf까지 오고가는 횟수를 얼마나 줄이느냐에 달려있습니다    
    
### 균형트리의 페이지 분할  
    
인덱스를 사용하게 되면 SELECT가 빨라진다.            
반면에 인덱스가 **존재하면** SAVE/UPDATE/DELETE 오히려 속도가 느려진다.       
그리고 그 이유가 페이지 분할 때문이다.     
    
데이터 개수의 변형이 이루어지면 페이지마다 수용할 수 있는 데이터의 양도 달라진다.    

![image](https://user-images.githubusercontent.com/50267433/146729060-5e3f8c04-b34b-4fd1-8a38-0b62b30af328.png)

이 같이 페이지의 변동이 없는 경우는 비교적 큰일은 아니다.     
하지만, 여기서 G를 입력하면 어떻게 될까?    
  
![image](https://user-images.githubusercontent.com/50267433/146729229-8da1c9de-7a02-4f4a-b76b-1eb74eec547b.png)
 
F, G, H, I, J 가 될 것이고 이는 페이지의 수용범위를 넘어서게 되면서        
새로운 페이지를 만들고, 이에 맞추어 페이지의 데이터를 재분류 해줘야한다.       

![image](https://user-images.githubusercontent.com/50267433/146729543-ddd972d2-ceac-4f01-98d2-ca9f19dd2400.png)

또 위 그림에서 P를 넣으면 어떻게 될까? 별 문제없다.       
그렇다면 여기에 추가적으로 Q를 넣으면 어떻게 될까?        
     
리프 페이지는 페이지 분할이 이루어진다.        
그런데 또 문제가 루트 노드의 페이지가 찼기 때문에 루트 페이지를 분할 해줘야한다.      

![image](https://user-images.githubusercontent.com/50267433/146731489-8078aae3-7c70-4e9d-9808-218743b5438a.png)

참고로 innoDB는 16KB가 기본이고, 옛날에는 8KB인 것 같다.    
  
인덱스의 갯수는 3~4개 정도가 적당합니다.       
너무 많은 인덱스는 새로운 Row를 등록할때마다 인덱스를 추가해야하고,       
수정/삭제시마다 인덱스 수정이 필요하여 성능상 이슈가 있습니다.     
인덱스 역시 공간을 차지합니다. 많은 인덱스들은 그만큼 많은 공간을 차지합니다.     
특히 많은 인덱스들로 인해 옵티마이저가 잘못된 인덱스를 선택할 확률이 높습니다.  
  
페이지는, 키를 각각의 하위 페이지의 첫번째 Row의 키값을 , Value를 페이지 번호로 가진다.     
단, value를 보조 인덱스의 리프 페이지는 데이터페이지번호+순서로 가진다.    

보조인덱스 범위 찾기 : https://www.youtube.com/watch?v=Prd1Uf7W0hc&list=PLqTUMsvO70nk8WfCyU-IPmc85390CaSqM&index=40&ab_channel=%EA%BF%80%EC%9E%BC%EC%BD%94%EB%94%A9TV  
![image](https://user-images.githubusercontent.com/50267433/146734677-cc15da8e-89ec-41e7-8ad7-9ab5354cca4d.png)

  
실제로는 보조랑 클러스터 인덱스가 같이 있을 것이다.        
앞서 보조 인덱스는 페이지+순서라했는데 이는 클러스터가 없을때 경우다.      
사실 이 같은 경우, 만약 데이터가 추가되어서 페이지가 분할되면,      
보조의 리프 페이지는 값이 불일치 될것이고 이로인해 다시 인덱스를 만드는 과정을 할수있다.     
그렇기에 보조 인덱스의 리프 페이지의 value는, 찾는 대상의 PK값을 가지게 되고   
이를 이용해서 다시 클러스터링 인덱스 균형트리의 루트를 타고 검색을 한다.   

![Uploading image.png…]()


![image](https://user-images.githubusercontent.com/50267433/146735106-eac4bea7-370a-478f-81e1-33ce722c25bd.png)

![image](https://user-images.githubusercontent.com/50267433/146735006-d4c60819-22ca-4228-bcf6-2a76e5247635.png)


# 참고 

https://www.youtube.com/watch?v=vWTDuoSG-YQ&list=PLVsNizTWUw7GCfy5RH27cQL5MeKYnl8Pm&index=17&ab_channel=%ED%95%9C%EB%B9%9B%EB%AF%B8%EB%94%94%EC%96%B4

https://jojoldu.tistory.com/243
