CPU는 프로그램 카운터(레지스터)가 가리키고 있는 메모리 주소에서 인스트럭션을 읽어서 실행한다.         
그러나 인터럽트가 들어오면, 제어권을 운영체제로 넘기고      
인터럽트에 맞는 함수를 인터럽트 벡터를 통해서 찾은 후 호출해서 사용한다.       
인터럽트는 트랩이나 하드웨어 인터럽트로 발생한다.      

# 동기식 입출력과 비동기식 입출력 
   
![image](https://user-images.githubusercontent.com/50267433/140637421-83bd7d3d-e83a-4db2-9a72-3db022f47538.png)    
    
1. 동기식 입출력    
2. 비동기식 입출력     
    
두 경우 모두 I/O 완료는 인터럽트로 알려줌  

## 동기식 입출력 (Synchronous I/O)  
* I/O 요청 후 입출력 작업이 완려된 후에야 제어가 사용자 프로그램에게 넘어감   
* 구현 방법1 
    * I/O가 끝날 때까지 CPU를 낭비시킴    
    * 메시점 하나의 I/O만 일어날 수 있음  
* 구현 방법2
    * I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    * I/O 처리를 기다리는 줄에 그 프로그램 줄을 세움
    * 다른 프로그램에게 CPU를 줌
     
## 비동기식 입출력 (aSynchronous I/O)   
* I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감       
* 주로 write 하는 경우에 사용된다(넣는건 나중에 해도 되니까)   

# DMA(Direct Memory Access)   

* 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용    
* CPU의 중재 없이 Device Controller 가 Device의 Buffer Storage의 내용을 메모리에 block 단위로 직접 전송   
* 바이트 단위가 아니라 block 단위로 인터럽트 발생   
* 쉽게 표현하면, CPU 대신 인터럽트를 처리 -> 버퍼에 저장된 데이터를 받아서 메모리에 카피(블록 단위로)     
      
![image](https://user-images.githubusercontent.com/50267433/140637558-6638e8aa-edfb-42e3-9871-2fb97aad883a.png)

# 서로다른 입출력 명령어  

![image](https://user-images.githubusercontent.com/50267433/140637694-c9bded3e-3dd5-43b2-aa3d-a6fdbc169d81.png)

* I/O를 수행하는 special instruction에 의해    
* memory mapped I/O에 의해    

좌측 그림은 메모리 접근 인스트럭션이 따로있고 I/O를 할려면 그 I/O를 할려는 스페셜 인스트럭션에 의해서 I/O 작업   
우측 그림은 I/O 장치도 메모리 주소에 연장 주소를 붙인 다음에, 접근하는 I/O 작업  

# 저장 장치 계층 구조  
   
![image](https://user-images.githubusercontent.com/50267433/140637769-f205360c-aff7-45f7-9523-811b4ef096d1.png)   
       
**위로 갈 수록**    
* 속도 빠름     
* 가격이 비싸서 용량이 작음    
* 휘발성이 높아짐(사라질 가능성)     
    
**접근**  
* CPU가 직접 처리 가능한 것 -> primary(Executable) -> 바이트 단위로 접근가능    
* CPU가 직접 처리 불가능한 것 -> secondary -> 바이트가 아닌 세컨단위   
   
아래에 있는 내용은 모두 위로 못올릴 것이다.(또한 시간 차이도 있음)      
이런 문제를 위해 캐시를 사용한다.(당장 필요한 것만 위로 올린다.)         

# 프로그램의 실행 
![image](https://user-images.githubusercontent.com/50267433/140637909-632b367d-2bcb-4457-8919-78d36634eaba.png)
   
프로그램은 실행 파일 형태로 하드디스크에 저장되어 있다.           
이 실행 파일을 실행시키면, 메모리에 올라가서 프로세스가 된다.       

![image](https://user-images.githubusercontent.com/50267433/140637927-09c25ba0-1716-4e6a-9ab2-2babfdb55156.png)  
        
정확히 말하면, `가상 메모리`라는 한 단계 더 거친다.        
어떤 프로그램을 실행시키면, 그 프로그램만의 address space가 형성이 된다.         
즉, 각각의 프로그램들은 각각의 address space를 가지고 있는다.(코드(기계어)/데이터(전역변수)/힙/스택(함수 데이터))    
참고로, 커널 또한 프로그램이므로 코드/데이터/스택의 주소공간을 가진다.      
  
address space를 물리적인 메모리에 올려서 실행시키는 것인데              
그러나 물리적인 메모리에 address space의 모든 정보를 올리는 것은 메모리 낭비다.          
그렇기 때문에 지금 당장 필요한 데이터만 메인 메모리에 올린다.    
계속 swap 하는데 이때 메모리에 올랐다가 사용하지 않는 데이터는 디스크의 Swap Area(휘발성)에 다시 넣는다. (SwapIn/Out)      
이러한 기법을 버츄얼 메모리 기법이라한다.     
     
사실 그림을 보면, HDD에서 address space를 구현하는데 이 각각의 영역이 가상 메모리이다.      
  
각각의 address space는 고유한 주소 번지수를 가지는데(0번지 부터 시작)     
이들을 물리적 메모리에 맞는 주소변환을 해주는 것은 Address transaction 을 이용해서 바꾼다.   

# 커널(운영체제 커널) 주소 공간의 내용 
![image](https://user-images.githubusercontent.com/50267433/140638192-c5bf4f3f-7ecd-4e9b-a36c-3de840904b23.png)    


* 코드 
    * 시스템콜, 인터럽트 처리 코드 
    * 자원 관리를 위한 코드
    * 편리한 서비스 제공을 위한 코드  
* 데이터 
    * PCB : 프로세스 제어 블록 -> 프로세스 상태 저장 
    * CPU : 자료구조
    * meme : 자료구조 
    * disk : 자료구조
* 스택 
    * 프로세스 마다의 커널 스택을 가진다.   

# 사용자 프로그램이 사용하는 함수   

![image](https://user-images.githubusercontent.com/50267433/140638308-db321b58-6091-411c-98ff-126fa4dc2f77.png)
   
* 함수 : 
    * 사용자 정의 함수 
        * 자신의 프로그램에서 정의한 함수  
    * 라이브러리 함수
        * 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
        * 자신의 프로그램의 실행 파일에 포함되어 있다.    
    * 커널 함수   
        * 운영체제 프로그램의 함수      
        * 운영체제가 가지고 있으므로 점프가 안되니 인터럽트 발생  
        * 커널 함수의 호출 == 시스템 콜(프로그램이 운영체제에게 실행해달라고 요청)   

# 프로그램의 실행   
  
![image](https://user-images.githubusercontent.com/50267433/140638334-ca79bcef-7abf-4443-88fa-aced53f4d9e0.png)  
 
* CPU가 사용자 프로그램을 잡고 있으면 : 유저모드     
* CPU가 시스템콜이나 운영체제의 커널의 코드를 실행하면 : 커널 모드  

 
