# 교착상태(deadlock) 
  
![image](https://user-images.githubusercontent.com/50267433/141121415-d7ae902d-b495-4cfa-a58d-63050dafa79f.png)   
  
* DeadLock : 
    * 일련의 프로세스들이 서로가 가진 자원을 기다리며 block 된 상태   
* Resource : 
    * 하드웨어, 소프트웨어 등을 포함하는 개념 
    * I/O device, CPU Cycle, memory space, semaphore 등 
    * 프로세스가 자원을 사용하는 절차 
        * request
        * allocate
        * use release
* deadlock exmaple
    * 시스템에 2개의 tape drive가 있다.  
    * 서로 다른 프로세스들이 서로가 원하는 자원을 가지고 있는 경우 
    * Binary semaphores A and B 

## 교착상태 발생 조건 4가지 

* 상호배제 : 매순간 **하나의 프로세스만이 자원을 사용할 수 있다.**      
* 비선점 : 프로세스는 자원을 스스로 내어놓을 뿐 **자원을 강제로 빼앗기지 않는다.**    
* 보유 대기 : 자원을 가진 프로세스가 다른 자원을 기다릴 때 **보유 자원을 놓지 않고 계속 가지고 있음** 
* 순환 대기 : 자원을 기다리는 프로세스간에 **사이클이 형성**되어야 한다.        
   
## 데드락 검증 - 자원할당 그래프  

![image](https://user-images.githubusercontent.com/50267433/141125131-9049ddff-6f24-4d8b-ac97-59f2b86d85df.png)

* 동그라미 : 프로세스   
* 사각형 : 자원     
* 화살표 : 의존성 
    * 머리쪽 프로세스 -> 프로세스가 꼬리족 자원을 사용하고 있다.    
    * 꼬리쪽 프로세스 -> 프로세스가 머리쪽 자원을 원하고 있다.(요청중)     

현재는 데드락이 아니다.  

![image](https://user-images.githubusercontent.com/50267433/141125674-5eee1535-e02b-4321-953e-8543fc77b8d6.png)   
    
그러나 위 같은 상황은 **사이클**이 발생하므로 데드락일 가능성이 높다.     
보다 정확히 말하면 **사이클 + 반환될 자원의 갯수를 제외하고 참조+요구된 프로세스 갯수보다 적으면 데드락이다.**     
      
왼쪽 그림은 2개의 참조가 이미 이루어졌는데 사이클 + 다른 프로세스가 자원을 요구하고 있다.            
오른쪽 그림 또한 사이클 + 갯수오버 이지만, p4 같은 경우 다시 반환될 수 있기에 p3는 r2를 받을 수 있다.       

# 데드락 해결 방법 

* Deadlock Prevention 예방 : 
    * 자원할당시 4가지 필요 요건중 하나 만족시키지 않게 하는 것 
    * 단, 성능저하/처리량감소/기아 문제가 발생할 수 있다.    
* Deadlock Avoidance 회피 : 
    * 자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원할당   
    * 단, 매번 회피 알고리즘을 수행해서 오버헤드 많이 발생됨 
    * 자원의 인스턴스 갯수에 따라 실행 알고리즈 다름 
    * 한 개 
        * 자원 할당 그래프 
        * 지금 요청 시점이 괜찮은지 확인하고, 괜찮으면 할당 안되면 미할당(최악의 상황 가정)   
        * 점선 화살표는 앞으로 적용해야할 자원인데 싸이클 발생하는지 검증 
        * ![image](https://user-images.githubusercontent.com/50267433/141129131-b782f679-3a84-4097-8433-19127f7ba165.png)
    * 여러개 
        * 은행원 알고리즘 -> 최소 한명이 작업을 완료할 정도의 자원은 남겨놓자 
* Deadlock Detection and recovery 탐지 및 복구 : 
    * 자원할당 그래프 통해서 문제 해결   
* Deadlock Ignorance 무시 : 
    * 사람이 직접 해결 
  








        

