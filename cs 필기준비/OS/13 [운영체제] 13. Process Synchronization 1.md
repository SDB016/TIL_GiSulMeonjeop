# 데이터 접근 패턴 

![image](https://user-images.githubusercontent.com/50267433/141056517-88c158bd-d43d-4ae4-8754-f26026cceb6b.png)

1. 데이터를 연산하는 곳 <- 연산요청 <- 데이터가 저장된 곳 
2. 데이터를 연산 
3. 데이터를 연산하는 곳 -> 결과저장 -> 데이터가 저장된 곳 

그러나 이같은 방식에서는 누가 먼저 읽었냐에 따라서 로직에 영향을 갈 수 있다.   

# Race Condition

![image](https://user-images.githubusercontent.com/50267433/141056768-bcc1e8fb-a621-4bd2-939e-ef741ae1145a.png)
        
여러 주체가 하나의 데이터를 접근하려할때 Race Condition 이 발생한다.(마치 경쟁하는 것 같다고해서)              
데이터를 읽고 쓰는 과정에서 서로 값을 저장하고 읽고 삭제하는 작업들을 통해 읽기시 문제가 발생한다.         
이러한 문제를 해결하기 위해 우리는 동기화 작업을 진행해야 한다.     
        
일반적으로 프로세스는 자신의 영역이 독립적으로 존재한다.         
하지만, 여러 CPU가 메모리 접근할 수 있는 멀티 프로세서 시스템 또는       
공유 메모리를 사용하는 멀티 프로세스 구조에서는 문제가 발생할 수 있다.         
         
더 중요한 문제는 운영체제 커널과 관련한 것이다.           
프로세스들은 본인이 직접 처리할 수 없는 것에 대해서 시스템콜을 한다.       
시스템 콜이 발생했다는 것은 커널의 코드를 실행한다는 것인데             
커널내에서도 data/code/stack 같은 영역이 있기 때문에              
뒤이어 커널의 데이터를 접근한다면? 문제가 발생할 것이다.       

# OS 에서 Race Condition이 발생하는 경우 

1. Kernel 수행 중 인터럽트 발생시
2. Process가 system call 하여 kernel model로 수행중인데 context switching이 일어나는 경우 
3. MultiProcessor 에서 shared memory 내의 kernel data

## Kernel 수행 중 인터럽트 발생시   

![image](https://user-images.githubusercontent.com/50267433/141058115-6661680d-c273-4981-a460-24394bba9b50.png)

1. 커널이 count의 값을 읽고 1을 증가시키는 구문을 실행시키려는 와중에 인터럽트가 들어온다.   
2. 인터럽트가 들어왔으므로 기존 작업을 멈추고 인터럽트 처리 루틴으로 흐름이 넘어간다.   
3. 인트럽트 핸들러가 실행되면서 count의 1의 값을 감소시키는 구문이 실행된다.   
4. 인터럽트 처리가 끝나면 다시 커널 로직이 수행이된다.   
5. 그런데, 커널 로직에는 1의 값이 감소되지 않은 전의 값을 기준으로 1을 증가시키는 구문이 실행된다.   
  
**해결 : 이 같은 문제를 해결하기 위해서 -> 인터럽트가 들어와도 현재 로직이 끝나고 인터럽트 처리를 하도록 한다.**      
  
## Process가 system call 하여 kernel model로 수행중인데 context switching이 일어나는 경우








