# Scheduling Algorithm 
## 성능 척도(Scheduling Criteria)   

**시스템 입장에서의 성능 척도** 
* 이용료(CPU utilization) :  
    * 전체 시간중 CPU가 일한 시간의 비율(최대한 바쁘게 일시켜라)    
* 처리량 (throughtput) : 
    * 특정 시간동안 ReadyQueue에 존재하는 프로세스를 끝마친 갯수  
    * CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는것이 유리하다.

**프로그램 입장에서의 성능 척도**
* 소요시간 (tunaround time) : 
    * CPU를 요청한 시점부터 CPU를 다쓰고 CPU Burst가 끝날때까지 걸리는 시간
    * ReadyQueue에서 `기다린 시간 + 실제로 CPU를 사용한 시간`
* 대기시간 (waiting time) : 
    * ReadyQueue에서 CPU를 얻는데까지 걸린 시간.  
    * 한번의 CPU 버스트중에도 ReadyQueue에서 기다린 시간이 여럿 발생 가능   
    * 즉, CPU버스트가 끝날때까지 ReadyQueue에서 기다린 시간들의 합
* 응답시간 (response time) : 
    * ReadyQueue에 들어온 후 첫번째 CPU를 획득하기 까지 기다린 시간  

## 비선점 No preemption
프로세스가 CPU를 점유하면, 다른 CPU가 강제로 빼앗지 않는다.    
즉, 그 프로세스가 자진 반납할 때까지 다른 프로세스는 CPU를 할당받지 못한다.     

### FCFS(First-Come-First-Served)  
 
* 먼저 온 프로세스를 먼저 처리한다.    
* 작업 시간이 긴 프로세스를 작업한다면, 작업 시간이 짧은 프로세스는 오래 대기할 수 있다.    
* convoy effect : 소요시간이 긴 프로세스가 먼저 도달하여 시간을 잡아먹고 있는 부정적인 현상을 의미     

### SJF (Short-Job-First) 

* 작업 시간이 짧은 순서대로 프로세스를 먼저 처리한다.   
* Average Waiting Time 이 가장 작은 알고리즘이다.  

**선점/비선점**
* 비선점 방식 
    * 특정 프로세스가 CPU를 사용하면 종료될때까지 다른 프로세스는 CPU에 접근 못한다
* 선점 방식 
    * Shortest-Remain-Time-First   
    * 특정 프로세스가 CPU를 사용하더라도 다른 프로세스는 CPU에 접근 가능하다(우선순위 따라)  
      
**문제점**
* **기아상태(starvation) :** 작업 시간이 길고 중요한 작업은 계속 대기상태가 될 수 있다.    
* **CPU 사용시간을 미리 측정이 불가능하다. :**   
    * 프로세스 우선순위과 변동되기에 측정이 쉽지 않다.  
    * exponential avaerging 을 통해 예측할 수 있다.(과거 기록 기반)
        *  ![image](https://user-images.githubusercontent.com/50267433/141037423-ed805480-0cc1-4373-acb5-504029f933c1.png)

 
## 선점 preemption     
프로세스가 CPU를 점유했더라도, 다른 CPU가 강제로 빼앗을 수 있다.(타이머 등 이용)         

*
*
*
