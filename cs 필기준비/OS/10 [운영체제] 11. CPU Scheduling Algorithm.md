# Scheduling Algorithm 
## 성능 척도(Scheduling Criteria)   

**시스템 입장에서의 성능 척도** 
* 이용료(CPU utilization) :  
    * 전체 시간중 CPU가 일한 시간의 비율(최대한 바쁘게 일시켜라)    
* 처리량 (throughtput) : 
    * 특정 시간동안 ReadyQueue에 존재하는 프로세스를 끝마친 갯수  
    * CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는것이 유리하다.

**프로그램 입장에서의 성능 척도**
* 소요시간 (tunaround time) : 
    * CPU를 요청한 시점부터 CPU를 다쓰고 CPU Burst가 끝날때까지 걸리는 시간
    * ReadyQueue에서 `기다린 시간 + 실제로 CPU를 사용한 시간`
* 대기시간 (waiting time) : 
    * ReadyQueue에서 CPU를 얻는데까지 걸린 시간.  
    * 한번의 CPU 버스트중에도 ReadyQueue에서 기다린 시간이 여럿 발생 가능   
    * 즉, CPU버스트가 끝날때까지 ReadyQueue에서 기다린 시간들의 합
* 응답시간 (response time) : 
    * ReadyQueue에 들어온 후 첫번째 CPU를 획득하기 까지 기다린 시간  

## 비선점 No preemption
프로세스가 CPU를 점유하면, 다른 CPU가 강제로 빼앗지 않는다.    
즉, 그 프로세스가 자진 반납할 때까지 다른 프로세스는 CPU를 할당받지 못한다.     

### FCFS(First-Come-First-Served)  
 
* 먼저 온 프로세스를 먼저 처리한다.    
* 작업 시간이 긴 프로세스를 작업한다면, 작업 시간이 짧은 프로세스는 오래 대기할 수 있다.    
* convoy effect : 소요시간이 긴 프로세스가 먼저 도달하여 시간을 잡아먹고 있는 부정적인 현상을 의미     

### SJF (Short-Job-First) 

* 작업 시간이 짧은 순서대로 프로세스를 먼저 처리한다.   
* Average Waiting Time 이 가장 작은 알고리즘이다.  

**선점/비선점**
* 비선점 방식 
    * 특정 프로세스가 CPU를 사용하면 종료될때까지 다른 프로세스는 CPU에 접근 못한다
* 선점 방식 
    * Shortest-Remain-Time-First   
    * 특정 프로세스가 CPU를 사용하더라도 다른 프로세스는 CPU에 접근 가능하다(우선순위 따라)  
      
**문제점**
* **기아상태(starvation) :** 작업 시간이 길고 중요한 작업은 계속 대기상태가 될 수 있다.    
* **CPU 사용시간을 미리 측정이 불가능하다. :**   
    * 프로세스 우선순위과 변동되기에 측정이 쉽지 않다.  
    * exponential avaerging 을 통해 예측할 수 있다.(과거 기록 기반)
        *  ![image](https://user-images.githubusercontent.com/50267433/141037423-ed805480-0cc1-4373-acb5-504029f933c1.png)
       
### Priority Scheduling
* 우선순위과 높은 프로세스에게 CPU를 할당한다.       
* SJF는 일종의 Priority Scheduling 이다.          
* 우순선위 숫자가 작을 수록 더 높은 우선순위다.    
  
**문제점 및 해결**
* **문제 - 기아상태(starvation) :** 작업 시간이 길고 중요한 작업은 계속 대기상태가 될 수 있다.    
* **해결 - 나이(aging) :** 우선순위과 높더라도 오래 기다리면 우선순위를 높이자는 기법 -> HRN 알고리즘 
    
### Round Robin(RR) 

* **각 프로세스는 동일한 크기의 할당 시간을 가진다.(일반적으로 10-100ms)**   
* 할당 시간이 지나면 Timer의 interrupt로 인하여 프로세스는 선점 당하고 ReadyQueue에 대기된다.   
* 장점 :  
    * 고정된 `할당 시간`이 있으므로 누구든지 빠르게 CPU를 사용해볼 수 있다.(응답 시간이 빠르다)       
    * 최대 `n-1(프로세 스수) * q(할당시간)`안에는 적어도 1번 CPU를 사용할 수 있다.     
    * 즉, 누구든지 빠르게 CPU를 사용 및 CPU Burst 가 짭은 프로세스는 작업을 일찍 마칠 수 있다.   
    * 사람과 대화하는 대화형 프로세스에 알맞는 알고리즘이다.         
    * CPU 작업 시간에 비례하여 대기시간도 길어지거나 짧아진다.   
    * SJF 보다 turnaround time 이나 waiting time 은 길어질 수 있지만 최초 응답하는 response time은 훨씬 짧다. 

**주의점**   
* 할당 시간을 길게 잡으면 : FCFS -> 기아상태 
* 할당 시간을 짧게 잡으면 : 컨텍스트 스위칭이 빈번히 발생   

**라운드로빈 계산하기**      

|기준|시간|
|----|---|
|할당 시간|20| 
|P1|53|
|P2|17|
|P3|68|
|P4|24|

1. 53 - 20 : 
    * 20소요 
    * 남은 33은 ReadyQueue로 
2. 17 - 20 :
    * 17소요
    * 남은 프로세스 없다.
3. 68 - 20 : 
    * 20소요
    * 남은 48 ReadyQueue로 
4. 24 - 20 : 
    * 20소요
    * 남은 4 ReadyQueue로 
5. 33 - 20 : 
    * 20소요
    * 남은 13 ReadyQueue로 
6. 48 - 20 : 
    * 20소요
    * 남은 28 ReadyQueue로 
7. 4 - 20 :
    * 4 소요
    * 남은 프로세스 없다.  
8. 13 - 20 :
    * 13 소요 
    * 남은 프로세스 없다.
9. 28 - 20 :
    * 20소요
    * 남은 8 ReadyQueue로 
10. 8 - 20 :        
    * 8소요 
    * 남은 프레세스 없다.  
  
#### RR의 특이한 경우        
RR은 CPU 시간이 짧고 긴 작업들이 여럿 혼합되었을 때 사용하기 좋다.        
앞서 언급했듯이 CPU 시간이 짧은 작업들은 빠르게 빠져나갈 수 있기 때문이다.    
     
또환, FCFS 같은 경우 순서대로 프로그램을 실행하고 종료시키지만,      
RR은 시간을 쪼개서 작업하기 때문에, 회차를 기준으로 동시에 여러 프로세스가 종료될 수 있다.       

