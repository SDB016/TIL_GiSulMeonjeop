# 프로세스 생성 
* 부모 프로세스가 자식 프로세스를 생성한다.     
* 즉, 프로세스는 트리(계층)구조를 형성하고 있다.  
* 프로세스는 자원을 필요로 한다.  
    * 운영체제로부터 받는다.   
    * 부모와 공유한다.  
* 자원의 공유
    * 부모와 자식이 모든 자원을 공유하는 모델 
    * 일부를 공유하는 모델
    * 전혀 공유하지 않는 모델 
* 수행
    * 부모와 자식은 공존하며 수행되는 모델     
    * 자식이 종료될 때까지 부모가 기다리는 모델     
        
부모와 자식 프로세스가 데이터를 공유한다는 것은          
사실 자식 프로세스가 부모 프로세스의 메모리를 복제해서 사용하기 때문이다.            
즉, 같은 메모리를 가지고 있기 때문에 공유한다는 표현을 한 것이고       
이처럼 자식 프로세스가 부모 프로세스의 메모리를 복사하는 것을 COW(Copy-on-write)라고 부른다.     
   
## 복제와 덮어쓰기  

* 주소공간(address space)   
    * 자식은 부모의 공간을 복사한다.(binary and os data)        
    * 자식은 그 공간에 새로운 프로그램을 올린다.      
* 유닉스의 예  
    * **fork() :** 시스템 콜이 새로운 프로세스를 생성한다.  
        * 부모를 그대로 복사(OS data except PID + binary)  
        * 주소 공간 할당 
    * fork 다음에 이어지는 **exec()** 시스템콜을 통해 새로운 프로그램을 메모리에 올림  
 
정리하자면,     
메모리(데이터) 복제는 **fork()**    
해당 메모리에 데이터를 덮어쓰는 작업은 **exec()** 이다.      
  
참고로, 시스템콜임을 알 수 있는데       
**사용자 프로그램은 프로세스를 만들수 없고 대신 운영체제에게 만들어달라고 부탁하는 것이다.**      

# 프로세스 종료  
* **exec :** 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다.(정상)      
    * 종료될때 자식이 부모에게 output data를 보낸다.(vai **wait**)     
    * 프로세스의 각종 자원들이 운영체제에게 반납됨   
* **abort :** 부모 프로세스가 자식의 수행을 종료시킴 (강제)   
    * 자식이 할당 자원의 한계치를 넘어섬   
    * 자식에게 할당된 태스크가 더 이상 필요하지 않음   
    * 부모가 종료(exit)하는 경우    
        * 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.   
        * 단계적인 종료 

# fork 시스템 콜 

```c
int main() {
    int pid;
    pid = fork();
    if(pid == 0) printf("\n Hello, I am child\n")
    else if printf("\n Hello, i am parent\n")  
}
```
* 자식 프로세스 == 0  
* 부모 프로세스 > 0    

포크가 이루어진 다음에야 자식 프로세스가 구동한다.        
이때, 포크(CODW)를 하면서 부모 프로세스의 문맥도 가지고 오므로 fork()를 호출한 뒤의 로직이 수행된다.        
   
![image](https://user-images.githubusercontent.com/50267433/140746070-53dc5de3-9d39-40bd-8450-3566e804c378.png)
         
부모프로세스의 `fork()`는 자식 프로세스를 생성하고 그 주소값을 리턴한다.     
그렇기 때문에 양수이면 현재가 부모 프로세스인 것을 알 수 있다.   
          
반면에 복사된 코드       
즉, 자식 프로세스는 `fork()` 호출하면 0을 반환한다.               
이러한 작업을 통해 양수면 부모, 0 이면 자식임을 알 수 있다.     




