# 컴퓨터 시스템 구조 
   
![image](https://user-images.githubusercontent.com/50267433/140633999-30bc7b6b-a10e-4686-9276-8d79859d56c0.png)   
             
* CPU : 메모리에 올라온 프로세스를 빠르게 전환하며넛 실행한다         
* 메모리 : CPU의 작업공간(CPU는 매 순간 메모리에서 기계어를 읽어서 실행한다)        
* I/O 디바이스 : 데이터를 입출력하는 노드     
    
## 디바이스의 작은 컴퓨터 

![image](https://user-images.githubusercontent.com/50267433/140633722-6d523ea6-d4a8-4c04-98d1-276394b1d0d2.png)
  
각각의 IO Device 는 **각각의 디바이스를 전담하는 작은 CPU 인 DeviceController 가 붙는다.**      
즉, 디스크에서 **헤드가 어떻게 움직이고 어떤 데이터를 읽을지 그 디스크 내부를 통제하는 것은      
CPU가 아닌 디바이스에 붙어있는 DeviceController 가 작업을 하는 것이다.**   
  
CPU 하고 I/O 디바이스는 속도 차이가 심하다.    
그렇기 때문에 CPU에서 직접 디바이스를 관장하지 않고 DeviceController 를 사용한다.      

CPU 에는 메모리가 있듯이 **작은 CPU 인 DeviceController 또한 local buffer 가 있다.**     

참고로, 이런 I/O 작업은 `사용자 프로그램`이 못하고 **보안 같은 이유로 OS가 처리하도록 되어있다.**     
즉, 사용자 프로그램은 CPU를 점유하고 있다가도 I/O가 필요하면 CPU를 운영체제에게 넘긴다.  
   
다비이스 컨트롤러를 통해서 요청한 작업을 처리하고 I/O 데이터를 로컬 버퍼에 저장한다.    
그리고 다비이스 컨트롤러는 CPU에게 인터럽트를 건다.   
인터럽트가 걸리면, CPU는 사용자 프로그램을 돌리다가도 운영체제에게 넘어가지는데   
이때, 요청한 프로그램을 찾고 그 프로그램의 메모리에다가 데이터를 카피해준다.   
이 과정에서 도중에 인터셉트 당한 프로그램에게 우선 다시 CPU를 할당해주고  
그 프로그램이 끝나면, 데이터를 받은 프로그램을 실행한다.    


## CPU  
        
CPU의 역할은 매 클럭마다 메모리에서 인스턴스 하나를 읽어서 실행하고 다시 읽어서 실행하는 과정을 반복한다.      

CPU 구성요소 
* Register : 메모리보다 작지만, 훨씬 빠른 연산속도를 가진 저장공간
* Mode Bit : CPU에서 사용되는 프로그램이 운영체제 프로그램인지 사용자 프로그램인지 구분해주는 역할을 한다.     
* interrupt line : 
    * CPU는 항상 메모리에 있는 인스턴스를 실행하는 작업만 한다.(그 외 작업x)    
    * I/O 디바이스의 작업에 대해서 각각의 deviceController 들은 작업 결과를 CPU에게 알려야 한다.  
    * 주변기기가 CPU에게 어떤 사실을 알리는 일을 Interrupt 라고 하고 이들을 저장한 것을 interrupt line(IRQ)이라 한다.    
      
이외에도     
* timer :    
    * 특정 프로세스가 CPU를 무한으로 사용하는 경우를 대비해서 만든 타이머이다.    
    * 타이머 시간이 종료되면 타이머가 CPU에게 interrupt를 걸어서 끝났음을 알린다.

## Mode bit 
* 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요         
* **Mode bit을 통해 하드웨어적으로 2가지 모드의 operation 지원**          

```   
0 모니터 모드: OS 코드 수행 (모든 작업 가능)  
1 사용자 모드: 사용자 프로그램 수행
```      
   
* 보안을 해칠 수 있는 중요한 명령어는 모니터모드에서만 수행 가능한 **특권 명령**으로 규정        
* **interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈**            
* 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅      
* 즉, 모드빗이 1일때, OS만 접근할 수 있는 것들에 대해서 막기 위해서 존재   

![image](https://user-images.githubusercontent.com/50267433/140635863-c0ab6022-e8f6-4739-9ab3-5193b57c5ae2.png)

## Timer
* **타이머**
    * 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생함      
    * 타이머는 매 클럭 틱 때마다 1씩 감소     
    * 타이머 값이 0이 되면 타이머 인터럽트 발생     
    * CPU를 특정 프로그램이 독점하는 것으로부터 보호  
* 타이머는 time sharing 을 구현하기 위해 널리 이용됨 
* 타이머는 현재 시간을 계산하기 위해서도 사용  

## Device Controller

* **I/O Device Controller**  
    * 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
    * CPU의 요청정보 즉, 제어 정보를 저장하기 위해 controller register, status register를 가진다.  
    * local buffer를 가진다.(일종의 data register)   
* I/O는 실제 device와 local buffer 사이에서 일어난다.    
* Device Controller는 I/O가 끝났을 경우 interrupt로 CPU에게 그 사실을 알린다.     
* CPU는 로컬 버퍼에 접근하여 메인 메모리에 그 데이터를 필요한 프로그램의 영역에 복사한다.     
 
**용어**   
* device dirver : OS 코드 중 각 장치별 처리루틴 -> sofrware (각 디바이스를 처리할 수 있도록 하는 SW)    
* device controller : 각 장치를 통제하는 일종의 작은 CPU -> hardware 
   
## DMA Controller 
CPU는 인터럽트가 너무 많이 당한다.     
이 과정에서 기존 작업을 멈추고 다른 작업을 수행할 경우가 높다는건데 이는 별로 효율적이지 않다.   
**이러한 문제를 해결하기 위해 DMA Controller 를 사용한다.**       
    
이름 그대로 메모리를 DMA가 직접 접근할 수 있도록 하는 컨트롤러다.(CPU와 조율해서 사용)     
DMA Controller의 역할은 인터럽트가 발생시, CPU 대신하여 로컬 버퍼의 데이터를 읽고 메모리에 복사하는 일을 한다.     
즉, CPU는 프로그램을 실행하는 역할을 그대로 하되, DMA에서 데이터를 읽고 복사하는 역할을 한다는 것이다.       
이후, DMA는 CPU에게 데이터 복사 완료 여부를 알린다.     
  
## CPU의 운명 

본인이 이번에 실행해야할 인스트럭션의 메모리 주소를    
다음에 실행할 인스트럭션의 주소를 가지고 있는 **프로그램 카운터(PC)라는 레지스터에서** 가져와서 실행한다.       
그리고 그 인스트럭션 중에서 I/O 작업이 필요하면 Device driver 를 통해서 읽기/쓰기 명령을 한다.     
물론, 실제 작업은 Device Controller 가 한다.    

## 입출력(I/O)의 수행  
* 모든 입출력 명령은 특권명령(OS가 수행)     
* 그렇다면 사용자 프로그램은 어떻게 해야 I/O 요청을 하는가?   
    * **시스템콜** : 사용자 프로그램은 **운영체제에게 I/O 요청**, **사용자 프로그램이 운영체제의 터널 함수를 호출하는 것**             
    1. trap 을 사용하여 인터럽트 벡터의 특정 위치로 이동   
    2. 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동 
    3. 올바론 I/O 요청인지 확인 후 I/O 수행   
    4. I/O 완료시 제어권을 시스템콜 다음 명령으로 올림  
* 보다 쉽게 설명하면, 사용자 프로그램이 I/O 요청을 위해 직접 인터럽트를 걸어서 CPU가 OS를 할당하도록 한다.   

## 인터럽트 
* 인터럽트 : 인터럽트 당한 시점의 레지스터와 program counter를 save 한후, CPU의 제어를 인터럽트 처리 루틴에 넘긴다.   
* interrupt(넓은 의미) 
    * interrupt(하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트 
    * Trap(소프트웨어 인터럽트) : 
        * Exception : 프로그램이 오류를 범한 경우 
        * System call : 프로그램이 커널 함수를 호출하는 경우 
* 인터럽트 관련 용어   
    * 인터럽트 벡터 : 
        * 키보드 인터럽트, 타이머 인터럽트와 같이 여러 인터럽트가 있다.    
        * 그리고 각각의 인터럽트마다 운영체제가 해야할 일이(호출할 함수)가 다르다.    
        * 즉, **특정 로컬 데이터에 접근하고 데이터를 복사**한다.        
        * 그러므로 각각의 인터럽트마다 어떤 함수를 호출해야할지 표시해야하는데 이를 벡터에 표시한다.    
        * 즉, 각 인터럽트의 종류마다 어디에 있는 함수를 호출해야할지 그 함수 주소를 정의해놓은 테이블이다.   
        * 해당 인터럽트의 처리 루틴 주소를 가지고 있다.     
    * 인터럽트 처리 루틴(인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수     
        
즉, I/O 요청을 할때는 트랩, I/O 작업이 끝나면 하드웨어 인터럽트를 사용한다.  

## 시스템 콜 
사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것 (운영체제에게 부탁)     

