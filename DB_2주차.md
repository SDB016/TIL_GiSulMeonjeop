# 💡 정규화를 왜 진행하나요?
 
정규화는 왜 하는 것일까? 답은 간단하다 **데이터를 효율적으로 저장하지 못했기 때문이다.**             
그렇다면 데이터를 효율적으로 저장하지 못하면 어떤일이 발생하기에 정규화를 지향하는 것일까?         
           
한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 아래와 같은 일이 발생한다.        
          
* 정보가 중복 저장되어 `저장 공간을 낭비`하게 된다. 
* 중복된 정보로 인해 `갱신 이상`이 발생하게 된다. 
                   
쉽게 말하자면,     
동일한 정보가 여러 릴레이션에 존재하는데,      
한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우        
**어느 것이 정확한 정보인지는 로그를 확인하기 전까지 알 수 없다.**         
              
이러한 문제를 해결하기 위해 정규화 과정을 거치는 것이며           
정규화는 아래와 같은 기준을 바탕으로 진행하도록 권장하고 있다.        
      
* 정보의 중복과 갱신 이상이 생기지 않아야한다.     
* 정보의 손실을 막아야한다.   
* 애트리뷰트들간의 관계를 잘 표현해야 한다.  
* 어떤 무결성 제약조건의 시행을 간단하게 해야한다.   
* 시간적, 공간적 효율성도 고려해야한다.   
       
 # 💡 이상현상에 대해 설명하시오.
     
앞서 데이터의 중복으로 인해 **갱신 이상**이 발생한다고 했다.            
**그렇다면 갱신 이상에는 어떠한 것들이 있을까?**               
* **삽입 이상(insertion anomalies) :**   
  원하지 않는 자료가 삽입된다든지,   
  삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점을 말한다.  
  쉽게 표현하면, 삽입할 때 발생하는 문제
* **삭제 이상(deletion anomalies) :**     
  하나의 자료만 삭제하고 싶지만,     
  그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점을 말한다.   
  쉽게 표현하면, 삭제할 때 발생하는 문제    
* **수정(갱신)이상(modification anomalies) :**   
  정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점을 말한다.
  쉽게 표현하면, 수정할 때 발생하는 문제
    
# 💡 제 3정규형까지설명해주세요.
## 제 1 정규형   
애트리뷰트의 도메인이 오직 원자값만을 포함하고,     
튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.      
즉, 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말한다.   
              
**하나의 컬럼에 2개 이상의 값이 오면 안 된다는 뜻이다.**       
      
## 제 2 정규형   
모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 완전 함수적 종속이면 제 2 정규형을 만족한다고 볼 수 있다.      
완전 함수적 종속이란 X -> Y 라고 가정했을 때,          
X 의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말한다.      
즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말한다.       
     
제 2정규형은 제 1정규형을 만족하면서, **모든 컬럼이 완전종속관계를 가지는 것을 말한다.**    
즉 **후보키 k**와 **K에 속하지 않는 속성 A**가 있을 때,      
A를 결정하기 위해 K의 일부가 아닌 K전체를 참조해야만 하는 경우를 말한다.      
결국, 부분함수종속관계를 전부 완전함수종속 관계로 만드는 것이다!       
        
쉽게 설명하면, **모든 컬럼이 기본키에 의해서만 식별되어야 한다.**      
      
## 제 3 정규형  
어떠한 비주요 애트리뷰트도 기본키에 대해서 이행적으로 종속되지 않으면 제 3 정규형을 만족한다고 볼 수 있다.      
이행 함수적 종속이란 `X - >Y`, `Y -> Z`의 경우에 의해서 추론될 수 있는 `X -> Z`의 종속관계를 말한다.         
즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.            
                  
2정규형에 맞추어, 각 컬럼이 기본키에 종속되도록 만들었지만   
다른 컬럼간에 연관성이 없어서 오해를 불러일으킬 수 있는 테이블이 있다.  
      
|학번|학부|등록금|    
|----|---|-----|      
|201512014|문융대|400만원(감동 실화)|     
|201612014|공과대|350만원|    
|201712014|인문대|2900만원|     
   
* 학번 -> 학부   
* 학부 -> 등록금  
* 학번 -> 등록금 : ---> **?**     

이 같은 경우에 **3정규형을** 수행하도록 한다. 

## BCNF(Boyce-Codd) 정규형  
여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용이다.       
복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있다.       
비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말한다.    
   
각 정규형은 그의 선행 정규형보다 더 엄격한 조건을 갖는다.
    
모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다.
모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다.
모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다.
수많은 정규형이 있지만 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것이다. 
   
추천 사이트 : [링크](https://yaboong.github.io/database/2018/03/09/database-normalization-1/)     
  
# 💡 데이터의 중복을 피할수있는데 역정규화는 왜실행하나요? / 모든 테이블에 정규화를 진행하나요?
역 정규화를 행하는 이유는 크게 2가지로 말할 수 있다.  

1. 성능
2. 개발 생산성 
  
테이블을 작게 분리하면 분리할 수록 장애 발생, 유지보수 관리하는 측면에서 높은 효율을 나타내지만       
반대로 데이터를 호출하고, 통합하는 과정에서 이전보다 작업이 늘어 성능이 저하한다는 문제가 있다.      
성능저하를 일으키는 대표적인 예로 `조인`이 있다.(성능저하를 일으킨다기 보다는 어쩔 수 없는 기능)     
  
개발 생산성 관점에서는 주로, 새로운 기능을 추가할 때 사용되기도 한다      
예를 들어 블로그의 게시글에 `좋아요 기능을 추가하려면?`     
다양한 방법이 있겠지만 공통적으로 `좋아요`라는 상태를 저장하기 위한 컬럼 또는 테이블이 존재해야한다.     
만약 좋아요를 테이블로 관리하면, 관련된 table의 join 연산에 `좋아요 테이블`을 우겨넣어야 하며  
이는 잘못하다 큰 장애를 불러일으킬 수 있다.   
이런 경우 메인 테이블에 `좋아요 기능`을 추가시켜 기존 쿼리를 수정하지 않고 기능을 추가할 수 있다.   
   
**그렇다면 모든 테이블에 정규화를 해야하나? 🤔**         
앞서 보았듯이 역정규화를 하는 이유만 알아도 이에 대한 대답을 할 수 있다. 바로, `no` 이다.       
유지보수 관리 측면에서 정규화를 진행한 테이블을 만드는 것을 권장하지만      
때로는 작업 환경에 따라, 상황에 따라 정규화를 실행하기도 역정규화를 실행하기도 해야한다.      

다만, 이 모든것은 개발자가 편하려고 하는 것이 아니라  
서비스의 퀄리티와 퍼포먼스를 높이기 위해서임을 잊지 말자   
   
# 💡 정규화 단계별 과정에 대해 설명하시오.
  
![992ADD33599D5EF204](https://user-images.githubusercontent.com/50267433/114386209-e48c5300-9bcb-11eb-8013-a7db76cc597a.png)
  
* 도 - 도메인 원자성 
* 부 - 부분적 함수 종속 제거 
* 이 - 이행적 함수 종속 제거 
* 결 - 결정자들 중에서 후보키 아니면 제거 
* 다 - 다치 종속 제거  
* 조 - 조인 종속성 이용  

