# Index  
## 💡 Index란 무엇인가?   
**인덱스 :** 컬럼값과 레코드의 주소를 **KEY와 VALUE로 묶어**서 페이지(목차)를 만드는 것이다.         
인덱스는 `인덱스 컬럼`을 기준으로 **정렬된 상태이기 때문에 원하는 값을 탐색하는데는 빠르다**    
                
읽기 속도는 향상되나 `추가`, `삭제`, `수정 실행` 속도가 느려진다.     
정확히 말하면 `행위`가 느린것이지, update, delete와 같은 행위를 하기 위해      
해당 데이터를 조회하는것은 인덱스가 있으면 빠르게 조회가 된다.       
  
**클러스터형 인덱스**  
```
비유하자면 영어사전
인덱스 열에 대한 자동 정렬이 이루어지고 인덱스 자체가 책의 내용같은 것  
즉 정렬이 되어 있으며 데이터페이지 = 리프 페이지(말단 노드)인 것
테이블당 1개만 만들 수 있다.
```
PK를 지정안해도 Unique Not null 을 사용하면 생성된다.         
만약 UNIQUE NOT NULL 과 PK가 겹치면 PK가 우선순위이다.       
  
**보조 인덱스**
```
비유하자면 책의 <찾아보기>
정렬이 되지 않고 오로지 순서대로만 나열되어 있으며 
데이터페이지 와 인덱스 페이지가 따로 논다.
테이블에 여러개 만들 수 있다.
```
Null도 가능하기에 일반적인 Unique 만으로도 보조 인덱스를 자동으로 생성해주는 키워드가 된다.   
    
## 💡 데이터베이스의 Index 구조에 대해 설명하시오. and 💡 Index의 자료구조는 어떤 것을 사용하나요?
### B+-Tree 인덱스 알고리즘   
일반적으로 사용되는 인덱스 알고리즘은 `B+-Tree` 알고리즘이다.    
`B+-Tree` 인덱스는 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.   
       
이진 트리의 좌우 불균형을 개선하기 위해 등장한 알고리즘  
O(n)의 시간복잡도를 가지고 있다.  
      
### Hash 인덱스 알고리즘  
칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.  
   
하지만 컬럼의 값을 변형해서 인덱싱하므로,  
값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다.(전방 일치에서 사용)  
  
주로 메모리 기반의 데이터베이스에서 많이 사용한다.   
O(1) 복잡도를 가진다.  

    
**왜 index 를 생성하는데 b-tree 를 사용하는가?🤔**   
데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같은데?      
    
**SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다.**    
hash table 을 사용하게 된다면 등호(=) 연산이 아닌 **부등호 연산의 경우에 문제가 발생한다.**   
**동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.**      
     
[보다 자세한 내용](https://helloinyong.tistory.com/296)       
    
## 💡 Index를 따로 설정하지 않은 경우의 테이블은 어떤가요?    
기본키가 `Index`(클러스터드 인덱스)가 된다.   
또는 클러스터드 인덱스 또한 설정하지 않았다면 최악의 경우 모든 데이터를 조회해야한다.  
    
## 💡 모든 칼럼에 Index를 사용하면 좋나요?
        
**그렇다면 `WHERE 문`은 읽기 전용으로 많이 사용하므로 인덱스를 사용하는 것은 좋은 것인가?**             
* **과유불급 :** 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.     
        
보다 자세히 설명하면, 데이터가 새로 들어올 때마다 인덱스는 새롭게 정렬을 이어나간다.            
이때, 인덱스의 구조에 따라 정렬하는 로직이 바뀌며 어떠한 경우 시간이 오래 걸리는 경우도 많다.       
     
## 💡 Index는 어디에 사용하는게 좋아요?
1. **WHERE절에서 사용되는 열에 인덱스를 만들어야 한다.**   
검색을 한다는 것은 `WHERE`를 이용한다는 것이다. 그러니 `WHERE 절`에서 사용되는 열에 만든다.    
그러나, **WHERE절에 사용되더라도 자주 사용해야 가치가 있다.**        
인덱스에 지정된 열을 사용하지 않을 경우 인덱스는 실행되지 않는다.      
또한 자주 사용되지 않는다면 굳이 인덱스를 만들어 사용할 필요가 많이 없다.(공간)    
그러므로 인덱스는 테이블을 정의하는 어느 시점에 생성할 것인지를 잘 설계한 후에 지정하는 것이 바람직하다.    

2. **데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다.**     
앞서 설명햇던 필드의 값이 2개라는 등 그 범위가 적다면 굳이 인덱스를 사용할 필요가 없다.        
오히려 인덱스의 관리에 대한 비용 때문에 인덱스가 없는 편이 나을 수도 있다.     

3. **JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.**    
JOIN은 ```SELECT```를 사용해서 이루어진다.    
그러므로 JOIN에 사용하는 열일 수록 인덱스를 설정하면 빠르게 값을 얻어내 결합할 수 있다           
JOIN외에도 **VIEW**도 ```SELECT```로 이루어진 데이터베이스 객체이므로      
VIEW에 사용되는 열에도 인덱스를 지정해주면 좋을 것 같다.      
      
4. **INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해야 한다.**      
인덱스는 ```SELECT```의 성능을 높이는 반면      
```INSERT/UPDATE/DELETE```의 성능을 저하시킨다.         
그렇기에 ```SELECT```이 많이 사용되는 경우도 봐야하지만      
```INSERT/UPDATE/DELETE```를 많이 사용하는 경우 신중하게 판단을 해야한다.     
            
즉, 인덱스를 만들어 `SELECT`의 성능을 높일 것인지,      
인덱스를 만들지 않아서 `INSERT/UPDATE/DELETE`시에 영향을 최소화할 것인지를 잘 결정해야 한다.       
     
5. **클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.**      
종종 클러스터형 인데스가 꼭 있어야 한다는 생각이있다.         
하지만, 클러스터형 인덱스가 없는 것이 더 나은 경우도 종종 있다.        
         
예를 들어 대용량의 데이터가 계속 입력되는 시스템이라고 가정할 때,        
데이터가 입력될 때 마다 클러스터 인덱스는 필드를 기준으로 정렬을 계속 이어나가고         
페이지 분할도 이루어 질 것이다.          
이럴 경우 **시스템의 성능에 문제가 심각해질 수도 있다.**          
        
그래서 이럴경우에는 클러스터 인덱스가 없는 편이 더 나을 수도 있다.      
즉 ```PK``` 대신에 ```UNIQUE NULL```을 사용한다.(대신 보조키가 생성 되었다. 필요에 따라 삭제 가능)     
단, ```NULL 값```이 들어올수 있으니 응용프로그래밍 화면에서 필수로 입력 되도록 하자.(프로그래밍 언어에서)      
      
## 💡 Index 사용 시 장단점과 사용하면 좋은 경우와 나쁜 경우에 대해 설명하시오.   
   
**장점**    
* 검색 속도가 무척 빨라 질 수 있다.(단, 항상 그런것은 아니다.)   
* 그 결과 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능이 향상된다.  
   
**단점**    
* 인덱스가 DB 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 DB 크기의 10% 정도 추가로 필요하다.   
* 처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다.    
* 데이터의 변경작업이 자주 일어날 경우에는 오히려 성능이 많이 나빠질 수도 있다.   
    
위와 같이 인덱스는 비요을 크게 차지하기에 사용하지 않는 인덱스를 제거함으로써    
공간을 확보할 뿐 아니라 데이터의 입력 시에 발생되는 부하도 많이 줄일 수 있다.  
  
## 💡 FULLTEXT INDEX   
**FULLTEXT INDEX 란?**        
긴 문자로 구성된 구조화 되지 않은 텍스트 데이터등을 빠르게 검색하기 위한 MySQL의 부가적인 기능이다.         
`FULLTEXT INDEX`은 저장된 텍스트의 **키워드 기반의 쿼리를 위해서 빠른 인덱싱이 가능하다.**       
        
우리는 긴 문자를 전부 다 외울 수 없기에 `WHERE 열= 긴문자` 대신에 `LIKE '일부분'`을 사용할 것이다.  
만약 중간에 있는 단어를 통해서 검색을 하고자 한다면 `LIKE '%일부분%'`을 사용해야 할 것이다.    
하지만 이렇게 중간 단어를 찾기 위해 `LIKE`를 사용하는 경우에는 **인덱스를 사용할 수 없다.**      
결과적으로 **FULL TABLE SCAN을 하게 되므로 엄청난 부하가 걸리게 된다.**     
         
전체 텍스트 검색은 이러한 문제를 해결해 준다.        
전체 텍스트 검색은 **첫 글자뿐 아니라 중간의 단어나 문장으로도 인덱스를 생성해 주기 때문에 인덱스를 사용할 수 있다.**        
    
# 심화질문
## 💡 DB 이중화란 무엇인가?     
시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생시       
이를 복구하기 위해 동일한 데이터베이스를 복제하는 것         
        
이중화의 궁극적인 목적은 **무중단 서비스**    
        
사용자는 하나의 데이터베이스에 대해서만 작업을 수행   
데이터베이스 이중화시스템에 연결되어 있는 다른 데이터베이스에도       
작업내용이 동일하게 적용하여 여러개의 데이터베이스를 동시에 관리하도록 한다.     
   
즉, 문제가 발생하더라도 사용자에게는 장애를 못느끼게끔 데이터베이스를 전환하는 작업을 한다.       

## 💡 DB 이중화의 특징은 무엇인가요?
* High Availability
  * 서비스중이던 시스템 또는 S/W 오류 발생 시 사용가능한 시스템으로 즉시 접근이 가능해야 함
* Database Consistency
  * 하나의 데이터베이스 서버 내에서 이중화 트랜잭션과 로컬 트랜잭션이 동시에 같은 데이터를 접근하는 경우가 발생
  * 이런 한 데이터의충돌(conflict) 발생 시 데이터충돌이 해결되어야함
* High Performance
  * 이중화 하는데 수반되는 오버헤드를 최소화
  * 독립시스템(standalone)으로 트랜잭션을 처리할 때의 성능을 유지하도록 해야 함
* Load Balancing & Scalability
  * 다중서버 운영환경에서 서비스하는 트랜잭션들을 두 그룹이상으로 나누어,   
    각각의 트랜잭션이 해당서버에서 수행되도록 해야 함
  * 각 서버에서 변경되는 데이터베이스 내용을 다른 서버들에 반영시킴으로써   
    서버에 걸리는 부하를 분산시킬수 있도록 해야 함

