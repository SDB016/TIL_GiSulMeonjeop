# JVM구조에 대해 설명하시오.   
1. JAVA SOURCE : 사용자가 정의한 자바 파일 
2. COMPILER : 자바를 클래스 파일로 변환    
3. ByteCode : 클래스 파일들       
4. ClassLoader : 클래스 파일들을 JVM으로 로드 및 링크하여 RuntimeDataArea에 배치        
5. ExecutionEngine : 로딩된 클래스 파일들의 바이트 코드를 해석하여 JVM에서 실행가능하도록 한다.         
6. RuntimeDataArea : JVM이라는 프로세스가 프로그램을 수행하기 위하여 OS로부터 받은 메모리 공간      
    
**RuntimeDataArea** -> 메모리 구조      
* 메서드 영역 :        
클래스 정보를 처음 메모리 공간에 올릴때 **초기화되는 대상을 저장하기 위한 메모리 공간**        
클래스파일을 읽어서 분석하여 클래스에 대한 정보를 저장, 클래스 변수도 같이 저장      
    
* 힙 :     
인스턴스가 생성되는 공간, 인스턴스 변수들이 생성되는 공간    
     
* 스택 :     
메서드의 작업에 필요한 공간을 제공         
메서드가 호출되면 호출스택에서 준비한 메모리가 할당된다.            
메서드 작업 종료시 메모리 공간 반환되어 비워짐        


# GC처리 방법에 대해 설명하시오.
* 메모리가 부족할 때 사용되지 않는 메모리 즉, 쓰레기 메모리를 개발자가 해제하는 것이 아니라 JVM에서 해제해주는 것      
* 메모리 부족 요청시 실행 또는 JVM이 한가할 때 동작한다. -> 다른 말로 그전까지는 할당하고 있음      
         
# HashMap vs HashTable vs ConcurrentHashMap의 차이를 설명하시오.     
**공통점 :** Map 인터페이스를 구현한 콜렉션들입니다. -> key/value 구조          
**차이점 :**    
1. HashMap : 주요 메소드에 synchronized 키워드가 없습니다. key, value에 null을 입력할 수 있습니다.     
2. HashTable : 주요 메소드에 synchronized 키워드가 선언, key, value 에 null을 입력할 수 없습니다.           
3. ConcurrentHashMap의 : HashMap을 **thread-safe** 하도록 만든 클래스가 ConcurrentHashMap입니다.     
단, key, value 에 null을 입력할 수 없으며 ```putIfAbsent```라는 메소드 가집니다.       
        
**thread-safe**    
```
멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 
혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다.
```
    
# 접근제어자에 대해 설명하시오.        
**접근 제어자가 사용될 수 있는 곳 :** 클래스, 멤버변수, 메서드, 생성자             
      
**private :**         
같은 클래스 내에서만 접근이 가능합니다.           
                  
**protected :**    
같은 패키지내에서 그리고 해당 클래스를 상속받은 자손클래스에서 접근이 가능          
       
**default :**         
같은 패키지 내에서만 접근이 가능합니다.             
        
**private :**     
접근 제한이 없습니다. -> 아무곳에서나 가능        
       
# interface와 abstract의 차이를 설명하시오.
# StringBuilder와 StringBuffer의 차이에 대해 설명하시오.
String 에 대해서 먼저 설명    
    
* **String :** immutable 클래스로 객체의 값이 변하지 않는다는 특성이 있다.     
그렇기에 ```+``` 연산시에 객체의 값을 바꾸는 것이 아니라 메모리를 새롭게 할당한다는 단점이 있습니다.      
   
* **StringBuffer** : String과 달리 mutable 클래스로 객체의 값이 변할 수 있습니다.   
그렇기에 ```+``` 연산시에 기존 메모리에 append 하는 형식, 그리고 멀티스레드시에 Syncronize 동기화 작용      
      
* **StringBuiler** : StringBuffer와 같이 mutable 클래스로 객체의 값이 변할 수 있습니다.         
그렇기에 ```+``` 연산시에 기존 메모리에 append 하는 형식,       
그러나 Syncronized 동기화를 사용하지 않아 단일 스레드시에 좋습니다.             
    
# try-with-resources에 대해 설명하시오.       
I/O 입출력 관련된 클래스를 사용할때 유용한 기능으로                   
filnally 시 자원 반환을 하는 것을 생략하여 코드를 더욱 간결하게 만들어줍니다.              
    
# Synchronize에 대해 설명하시오.
멀티스레드 프로그램을 돌리면,              
여러개의 스레드가 한개의 자원을 공유하기에 data의 안정성과 신뢰성을 보장할 수 없습니다.    
이러한 문제점을 해결하기 위해 Synchronize라는 개념이 생겨났고    
Synchronize는 데이터를 사용하고 있는 스레드를 제외하고       
나머지 스레드들은 데이터에 접근 할 수 없도록 막아줍니다.          
      
# Synchronize를 하기 위한 방법은 무엇이 있나요?
Java 에서는 `synchronized` 키워드를 사용하여 스레드 간 race condition 을 통제합니다.    
이 키워드를 기반으로 구현된 Collection 들도 많이 존재한다.    
`List`를 대신하여 `Vector`를 사용할 수 있고, 
`Map`을 대신하여 `HashTable`을 사용할 수 있다. 
하지만 이 Collection 들은 제공하는 API 가 적고 성능도 좋지 않다.

기본적으로는 `Collections`라는 util 클래스에서 제공되는 static 메소드를 통해 이를 해결할 수 있다.     
`Collections.synchroziedList()`,     
`Collections.synchroziedSet()`,    
`Collections.synchroziedMap()` 등이 존재한다.    

# static은 메모리 구조 중 어디에 올라가나요?    
staic은 메서드 영역에 올라갑니다.          
 
**메서드 영역 :** 
클래스 정보를 처음 메모리 공간에 올릴때 **초기화되는 대상을 저장하기 위한 메모리 공간**          
클래스파일을 읽어서 분석하여 클래스에 대한 정보를 저장, 클래스 변수도 같이 저장           
       
# 컬렉션 프레임워크에 대해 설명하시오.
널리 알려진 자료구조와 알고리즘을 제네릭 기반의 클래스와 메서드 형태로 미리 구현해 놓은것     
라이브러리라 말하지 않고 프레임워크라 한 것은 이러한 자료구조와 알고리즘은 구조와 형태를 가지고 있기 때문입니다.       
    
**배열과 ArrayList 차이점은?**      
* 배열은 크기가 고정되어있지만 ArrayList는 크기가 동적인 배열    
* 배열은 원시값, 클래스 등을 담을 수 있지만 ArrayList 는 클래스만 담을 수 있음    
* ArrayList는 타입 안정성을 보장해주는 제네릭을 사용  
* ArrayList는 조상 클래스로 컬렉션 인터페이스를 사용하므로 해당 기능을 사용할 수 있음   
  
**컬렉션 인터페이스**    
선형구조를 가지는 자료구조를 지원해주는 인터페이스  
iterator 사용이 가능하여 순차적 접근이 가능하다.   
list, set 이 있으며 Map 은 컬렉션 인터페이스가 아니다  
  
# 제네릭에 대해 설명해주시고, 왜 쓰는지 어디서 써 봤는지 알려주세요.       
제네릭은 다양한 타입의 객체들을 다루는 메서드나 클래스에서 사용하는 것으로, 자바에서 안정성을 맡고 있다고 할 수 있습니다.            
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여줍니다.        
자연스럽게 코드도 더 간결해진다            
또한 api 를 설계하는데 있어서 보다 명확한 의사전달이 가능해진다.          
     
# Vector와 List 차이에 대해 설명하시오.   
Vector 와 List 는 가변 배열이라는 동일한 개념이 있지만      
Vector 는 Syncronized로 멀티스레드에서는 유용하지만 단일 스레드에서는 비효율적입니다.       
List 는 Syncronized가 아니여서 단일 스레드에서는 유용하지만 멀티스레드에서는 비효율적입니다.    

# 오버로딩과 오버라이딩의 차이는?   
**오버라이딩(Overriding)**  
상위 클래스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다.       
   
**오버로딩(Overloading)**    
상위 클래스의 메소드와 이름, return 값은 동일하지만, 매개변수만 다른 메소드를 만드는 것을 의미한다.     
다양한 상황에서 메소드가 호출될 수 있도록 한다.    

# CheckedException과 UnCheckedException의 차이를 설명하시오.   
**CheckedException :**      
반드시 명시적으로 처리해야 하기 때문에 Checked Exception이라고 하며,        
Rollback 안되기에 try catch를 해서 에러를 잡든 throws를 통해서 호출한 메서드로 예외를 던져야 합니다.          
예를 들면 : IOException , SQLException      

       
**UnCheckedException :**    
명시적인 예외 처리를 강제하지 않는 특징이 있기 때문에 Unchecked Exception이라 하며, 
Rollback 진행하기에 catch로 잡거나 throw로 호출한 메서드로 예외를 던지지 않아도 상관이 없습니다.         
예를 들면 : IllegalArgumentException, NullpointerException   
   
   
# OOP란 무엇인가요?    
Object Oriented Programing 의 약자로 객체지향 프로그래밍을 의미합니다.           
현실세계에 존재하는 개체를 객체로 만들고 이를 조립하여 프로그래밍 하는 기법으로       
자바에서 처럼 여러 연관된 속성과 메서드를 모아 놓은 클래스를 이용하여 프로그래밍 하는 기법입니다.       
          
추상화, 캡슐화, 상속, 다형성을 가집니다.          
   
# final / finally / finalize 의 차이를 설명하시오.
**final class**     
다른 클래스에서 상속하지 못한다.   
   
**final method**    
다른 메소드에서 오버라이딩하지 못한다.   
   
**final variable**   
변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 된다.      

추가적으로 혼동할 수 있는 두 가지를 추가해봤다.
   
**finally**  
try-catch or try-catch-resource 구문을 사용할 때,         
정상적으로 작업을 한 경우와 에러가 발생했을 경우를 포함하여       
마무리 해줘야하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.      

**finalize()**           
keyword 도 아니고 code block 도 아닌 메소드이다.        
GC에 의해 호출되는 함수로 절대 호출해서는 안 되는 함수이다.          
Object 클래스에 정의되어 있으며 GC 가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없다.        
또한 finalize() 메소드가 오버라이딩 되어 있으면 GC 가 이루어질 때 바로 Garbage Collecting 되지 않는다.          
GC 가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있다.          
    
# new String()과 ""의 차이에 대해 설명해주세요.    
new String()은 힙 메모리 영역에 새로운 인스턴스를 생성하는 것이고       
""는 기존 메모리에 저장된 ""을 찾아 참조하게 됩니다.           
       
# 스프링 IOC가 무엇인가요?   
객체에 대한 제어권이 개발자로부터 스프링 컨테이너(빈팩토리, 어플리케이션 컨텍스트)에게 넘어가면서            
객체의 생성부터 생명주기 관리까지의 모든 것을 컨테이너가 맡아서 하게됩니다.                   
이를 일반적인 제어권의 흐름이 바뀌었다고 하여 IoC(Inversion of Control : 제어의 역전)라고 합니다.  
          
또 다른 접근으로는 어떠한 클래스를 사용함에 있어서 100개의 파일에서 new 생성하는 것이 아니라         
상위 개념의 컨테이너에서 해당 객체를 내려 받는식의 방법도 고려할 수 있다.         
      
# OOP와 AOP에 대한 차이를 설명해주세요.        
OOP 객체지향 프로그램    
AOP 관점지향 프로그램     
   
AOP는 OOP를 더욱 OOP답게 프로그래밍 할 수 있게 도와주는 것으로           
애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해, Aspect라는 모듈로 만들어 설계하고 개발하는 방법이다.             
예를 들면 캡슐화된 어떠한 클래스를 대상으로 핵심기능과 부가적인 기능의 관점으로      
공통으로 사용하는 부가적인 기능들을 외부의 독립된 클래스로 분리하고,  이를 모듈화하여 재사용할 수 있게끔 하는 프로그래밍 기법입니다.         
    
# POJO가 무엇인가요?   
Plain old java object 의 약어로      
'오래된' 방식의 '순수한' 자바객체라는 말입니다.      
기존 EJB는 Java EE 등의 중량 프레임워크들을 사용하게 되면서      
해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다.       

POJO란 말 그대로 평범한 옛날 자바 객체를 의미한다.  
POJO를 좀 더 쉽게 이해하기 위해서 반대로 POJO가 아닌 클래스가 무엇인지 이해하면 된다.  
대표적인 Not POJO 클래스가 Servlet 클래스이다. Servlet 클래스는 우리 마음대로 만들 수 없으며,  
반드시 Servlet에서 요구하는 규칙에 맞게 클래스를 만들어야 실행할 수 있다.  
다음은 Servlet 클래스 작성 규칙이다.  
  
-javax.servlet, javax.servlet.http 패키지를 import 해야한다.  
-public 클래스로 선언되어야 한다.  
-기본 생성자가 있어야 한다.  
-생명주기에 해당하는 메소드를 재정의해야한다. 

# ORM이란?   
객체지향 프로그래밍 언어와 관계형 데이터베이스간의 호환되지 않는 데이터를 변환 매핑하는 프로그래밍 기법입니다.   
즉, 클래스와 테이블 데이터를 변환하여 매핑하는 것입니다.      
       
ORM의     
장점 : OOP언어 그대로 사용이 가능하며 RDBMS에 종속적이지 않습니다.         
단점 : 어려운 쿼리를 사용하고자 한다면 어렵고, 속도나 생산성이 저하될 가능성도 있습니다.      

  


 
