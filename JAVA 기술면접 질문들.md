# JVM   
* JAVA와 OS 사이에서 중개자 역할을 수행하여 JAVA가 OS 구애받지 않고 사용할 수 있게끔 해줍니다.        
    
# JVM구조에 대해 설명하시오.   
1. JAVA SOURCE : 사용자가 정의한 자바 파일 
2. COMPILER : 자바를 클래스 파일로 변환    
3. ByteCode : 클래스 파일들       
4. ClassLoader : 클래스 파일들을 JVM으로 로드 및 링크하여 RuntimeDataArea에 배치        
5. ExecutionEngine : 로딩된 클래스 파일들의 바이트 코드를 해석하여 JVM에서 실행가능하도록 한다.         
6. RuntimeDataArea : JVM이라는 프로세스가 프로그램을 수행하기 위하여 OS로부터 받은 메모리 공간      
    
**RuntimeDataArea** -> 메모리 구조      
* 메서드 영역 :        
클래스 파일을 읽고 분석하여 **초기화되는 대상을 저장하기 위한 메모리 공간**           
                
* 힙 :        
인스턴스, 인스턴스 변수들이 생성되는 공간         
메소드의 호출이 끝나도 메모리가 해제되지 않지만 GC의 실행으로 비워지게 됩니다.    
            
* 스택 :     
메서드의 지역변수, 매개변수가 저장되는 공간으로         
메서드가 호출되면 준비한 메모리가 할당되고 메서드 작업 종료시 반환되어 비어짐       
       
# GC처리 방법에 대해 설명하시오.
* 메모리가 부족할 때 사용되지 않는 메모리를 개발자가 해제하는 것이 아니라 JVM에서 해제해주는 것         
* 메모리 부족 요청시 실행 또는 JVM이 한가할 때 동작한다.       
             
# HashMap vs HashTable vs ConcurrentHashMap의 차이를 설명하시오.     
**공통점 :** Map 인터페이스를 구현한 콜렉션들입니다. -> key/value 구조          
**차이점 :**    
1. HashMap : 주요 메소드에 synchronized 키워드가 없습니다. key, value에 null을 입력할 수 있습니다.     
2. HashTable : 주요 메소드에 synchronized 키워드가 선언, key, value 에 null을 입력할 수 없습니다.           
3. ConcurrentHashMap의 : HashMap을 **thread-safe** 하도록 만든 클래스가 ConcurrentHashMap입니다.     
단, key, value 에 null을 입력할 수 없으며 ```putIfAbsent```라는 메소드 가집니다.       
        
**thread-safe**    
```
멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 
혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다.
```
    
# 접근제어자에 대해 설명하시오.        
**접근 제어자가 사용될 수 있는 곳 :** 클래스, 멤버변수, 메서드, 생성자             
      
**private :**         
같은 클래스 내에서만 접근이 가능합니다.           
                  
**protected :**    
같은 패키지내에서 그리고 해당 클래스를 상속받은 자손클래스에서 접근이 가능          
       
**default :**         
같은 패키지 내에서만 접근이 가능합니다.             
        
**private :**     
접근 제한이 없습니다. -> 아무곳에서나 가능        
       
# interface와 abstract의 차이를 설명하시오.           
인터페이스와 추상클래스 둘다 추상 메서드를 가지고 있지만      
추상 클래스도 엄연히 클래스이므로 1개 밖에 상속을 받을 수 없으나 interface는 다중 구현이 가능합니다.       
      
# StringBuilder와 StringBuffer의 차이에 대해 설명하시오.
String 에 대해서 먼저 설명    
    
* **String :** immutable 클래스로 객체의 값이 변하지 않는다는 특성이 있다.     
그렇기에 ```+``` 연산시에 객체의 값을 바꾸는 것이 아니라 메모리를 새롭게 할당한다는 단점이 있습니다.      
   
* **StringBuffer** : String과 달리 mutable 클래스로 객체의 값이 변할 수 있습니다.   
그렇기에 ```+``` 연산시에 기존 메모리에 append 하는 형식, 그리고 멀티스레드시에 Syncronize 동기화 작용      
      
* **StringBuiler** : StringBuffer와 같이 mutable 클래스로 객체의 값이 변할 수 있습니다.         
그렇기에 ```+``` 연산시에 기존 메모리에 append 하는 형식,       
그러나 Syncronized 동기화를 사용하지 않아 단일 스레드시에 좋습니다.             
    
# try-with-resources에 대해 설명하시오.       
자원을 반환 하는 클래스를 사용할때 유용한 기능으로                      
filnally 시 자원 반환을 하는 것을 생략하여 코드를 더욱 간결하게 만들어줍니다.                
    
# Synchronize에 대해 설명하시오.   
Synchronize는 자원 사용하고 있는 스레드 외의 나머지 스레드들이 해당 자원에 접근 할 수 없도록 막아줍니다.                  
        
# Synchronize를 하기 위한 방법은 무엇이 있나요?
Java 에서는 `synchronized` 키워드를 사용하여 동기화를 사용합니다.        
synchronized 키워드를 사용하는 동기화 메서드와 동기화 블록이 있습니다.        
     
# static은 메모리 구조 중 어디에 올라가나요?    
staic은 메서드 영역에 올라갑니다.          
     
**메서드 영역 :** 
클래스 정보를 처음 메모리 공간에 올릴때 **초기화되는 대상을 저장하기 위한 메모리 공간**             
       
# 컬렉션 프레임워크에 대해 설명하시오.    
널리 알려진 자료구조와 알고리즘을 제네릭 기반의 클래스와 메서드 형태로 미리 구현해 놓은것         
라이브러리라 말하지 않고 프레임워크라 한 것은 이러한 자료구조와 알고리즘은 구조와 형태를 가지고 있기 때문입니다.       
       
**배열과 ArrayList 차이점은?**      
* 배열은 크기가 고정되어있지만 ArrayList는 크기가 동적인 배열    
* 배열은 원시값, 클래스 등을 담을 수 있지만 ArrayList 는 클래스만 담을 수 있음    
* ArrayList는 타입 안정성을 보장해주는 제네릭을 사용  
* ArrayList는 조상 클래스로 컬렉션 인터페이스를 사용하므로 해당 기능을 사용할 수 있음   
  
**컬렉션 인터페이스**    
선형구조의 자료구조를 지원해주는 인터페이스  
iterator 사용이 가능하여 순차적 접근이 가능하다.   
list, set 이 있으며 Map 은 컬렉션 인터페이스가 아니다  
  
# 제네릭에 대해 설명해주시고, 왜 쓰는지 어디서 써 봤는지 알려주세요.       
제네릭은 다양한 타입의 객체들을 다루는 메서드나 클래스에서 사용하는 것으로,                    
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여줍니다.          
         
주로 컬렉션 프레임워크와 repository 인터페이스에서 사용했던 기억이 있습니다.          
동일한 포맷을 이용하여 다양한 객체를 동일하게 처리할 수 있다는게 인상적이었습니다.        
 
  
# 와일드 카드 
* 제네릭과 동일한 기능을 하지만 제네릭과 상호 호한적인 동작이 가능한 기능       
* 제네릭보다 간결하여 제네릭보다 선호하여 사용   
* 제네릭에서는 ```<Object>``` 와 ```<String>``` 은 아무 상관이 없기에 사용이 불가능 이를 해결하고자 와일드 카드 등장    
* ```<? extends A>``` 를 하게 되면 A와 그 자손들만 사용가능 -> ```A = new ?``` 생각하면 됨         
* ```<? Supper A>``` 를 하게 되면 A와 그 상위 클래스만 사용 가능 -> ```? = new A()``` 라 생각하면 됨         
   
# Vector와 List 차이에 대해 설명하시오.   
Vector 와 List 는 가변 배열이라는 동일한 개념이 있지만      
Vector 는 Syncronized로 멀티스레드에서는 유용하지만 단일 스레드에서는 비효율적입니다.       
List 는 Syncronized가 아니여서 단일 스레드에서는 유용하지만 멀티스레드에서는 비효율적입니다.    

# 오버로딩과 오버라이딩의 차이는?   
**오버라이딩(Overriding)**  
상위 클래스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다.       
        
**오버로딩(Overloading)**    
메소드의 이름 return 값은 동일하지만 매개변수만 다른 메소드를 만드는 것을 의미한다.        
다양한 상황에서 메소드가 호출될 수 있도록 하는 것입니다.     
     
# CheckedException과 UnCheckedException의 차이를 설명하시오.   
**CheckedException :**      
반드시 명시적으로 예외 처리를 해야 하는 예외 사항들을 의미합니다.        
try catch를 해서 에러를 잡든 throws를 통해서 호출한 메서드로 예외를 던져야 합니다.          
예를 들면 : IOException , SQLException      

**UnCheckedException :**    
명시적인 예외 처리를 강제하지 않는 예외 사항들을 의미합니다.      
catch로 잡거나 throw로 호출한 메서드로 예외를 던지지 않아도 상관이 없습니다.         
예를 들면 : IllegalArgumentException, NullpointerException   
   
# 내부 클래스   
1. 인스턴스 클래스 : 외부 클래스의 instance 멤버처럼 사용, instatnce 메서드와 같이 사용위함            
2. 스태틱 클래스 : 외부 클래스의 static 멤버처럼 사용, static 메서드와 같이 사용위함         
3. 지역 클래스 : 외부 클래스의 **메서드 안이나 초기화 블럭에 사용** -> 선언된 영역에서만 사용가능   
4. 익명 클래스 : 클래스의 선언과 객체의 생성을 동시에 하는 클래스 -> 이름이 없고 1회용이다.   
   
# 람다      
* 즉, 추상 메서드가 1개인 인터페이스에 대하여 익명 클래스를 구현하지 않고 바로 정의하여 사용가능하게 해줍니다.            
   
# 스트림   
* 자바에서의 데이터 흐름     
* 여러 데이터가 존재할 시 데이터를 하나씩 꺼내서 각각의 메서드에 맞게 처리      
* 기준 데이터 소스를 바꾸지 않고 새롭게 메모리를 할당하여 리턴하는 형식     
* 스트림에서 사용되는 메서드는 대부분 추상 메서드가 1개인 인터페이스를 사용하므로 람다가 매우 효율좋음     
    
# Optional      
* 제네릭 클래스로 해당 클래스를 감싸는 래퍼클래스이다.      
* 반환된 결과가 null인지 매번 if문을 사용하지 않고 Optional 메서드로 간단하게 처리 가능     
* NullPointerException이 발생하지 않는 보다 간결하고 안전한 코드를 작성 가능      
* ofNullable(대상) -> isPresent() 있는것     
* of(대상) -> 기존대로 하다가 없을 것 같으면 ```.orElse(다른 값)```으로 처리          
        
# 생성자        
       
생성자 :            
* 인스턴스 초기화 메서드로 리턴값이 없다.           
* 마찬가지로 오버라이딩이 가능하다            
* 생성자를 정의하지 않으면 디폴트 생성자가 생기지만 정의할 경우 디폴트 생성자는 사라진다.           
           
# 상속           
* 부모 클래스의 요소를 자식 클래스가 물려받는것           
* 흔히들 재사용 관점으로 얘기하지만 본질적의미로는 **연관된 특성을 가진 클래스들을 묶어주는 것**          
* AA is a BB 관계 성립 -> 원은 점이다. -> ```Circle extends Point``` -> ```Point p = new Circle()```         
          
**super**      
상위 클래스의 요소를 사용하는 것       

# 다형성      
한 타입의 참조변수로 여러 타입의 인스턴스를를 참조할 수 있는 것            
      
```a instanceOf AA``` a 변수가 AA를 참조할 수 있느냐 -> 동등하거나 자식 객체냐   
    
# 제어자   
1. static, final, abstract      
2. private 같클, public 아무나, protected 같패+해당클래스 상속받을시, default 같패     

# 추상클래스        
* 변수와 추상 메서드를 가진 클래스       
* 인스턴스화가 불가능하며 상속의 용도로 사용되는 클래스        
* 인터페이스에서 변수가 추가된 형태라고 보면 되고, 추상 메서드 외에도 정의된 메서드도 정의 가능하다.          
   
# 인터페이스   
* 일종의 사용 설명서 같은 것   
* 원래는 추상 메서드로 이루어져있지만 자바8 버전부터 디폴트 메서드, static final 변수 지원   
* 이는 기존에 인터페이스를 구현한 클래스들에게서 공통적으로 메서드를 추가해야할 때 사용 

# 박싱 언박싱 그리고 오토 박싱 언박싱       
**래퍼 클래스 :**      
* 기본 자료형을 클래스/객체로 사용하고자 할 때 사용하는 클래스      
    
**박싱/언박싱 :**      
* 기본 자료형을 클래스로 바꾸거나 래퍼 클래스를 기본 자료형으로 바꾸는 과정      
    
**오토 박싱/언박싱 :**      
박싱과 언박싱에 대한 형변환 처리를 자동으로 해준다.   
예를 들면 ```Integer a = 1``` 또는 ``` int num = a``` 이런식으로 가능  
# final / finally / finalize 의 차이를 설명하시오.
**final class**     
다른 클래스에서 상속하지 못한다.   
   
**final method**    
다른 메소드에서 오버라이딩하지 못한다.   
   
**final variable**   
변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 된다.      

추가적으로 혼동할 수 있는 두 가지를 추가해봤다.
   
**finally**  
try-catch or try-catch-resource 구문을 사용할 때,         
정상적으로 작업을 한 경우와 에러가 발생했을 경우를 포함하여       
마무리 해줘야하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록이다.      

**finalize()**           
GC에 의해 호출되는 함수로 절대 호출해서는 안 되는 함수이다.               
Object 클래스에 정의되어 있으며 GC 가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없다.          
        
# new String()과 ""의 차이에 대해 설명해주세요.      
new String()은 힙 메모리 영역에 새로운 인스턴스를 생성하는 것이고              
""는 우선 기존 메모리에 할당된 ""을 찾아서 참조하거 없으면 새롭게 메모리를 할당하여 이를 참조합니다.            
      
         
